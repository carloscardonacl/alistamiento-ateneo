{"remainingRequest":"C:\\Users\\User\\Desktop\\Master-Sigespro\\sigespro\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--3-1!C:\\Users\\User\\Desktop\\Master-Sigespro\\sigespro\\node_modules\\ng2-archwizard\\dist\\navigation\\strict-navigation-mode.js","dependencies":[{"path":"C:\\Users\\User\\Desktop\\Master-Sigespro\\sigespro\\node_modules\\ng2-archwizard\\dist\\navigation\\strict-navigation-mode.js","mtime":1535664060968},{"path":"C:\\Users\\User\\Desktop\\Master-Sigespro\\sigespro\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1535664048428},{"path":"C:\\Users\\User\\Desktop\\Master-Sigespro\\sigespro\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1535664036292}],"contextDependencies":[],"result":["import { __extends } from \"tslib\";\r\nimport { NavigationMode } from './navigation-mode.interface';\r\nimport { MovingDirection } from '../util/moving-direction.enum';\r\n/**\r\n * A [[NavigationMode]], which allows the user to navigate with strict limitations.\r\n * The user can only navigation to a given destination step, if:\r\n * - the current step can be exited in the direction of the destination step\r\n * - all previous steps to the destination step have been completed or are optional\r\n *\r\n * @author Marc Arndt\r\n */\r\nvar StrictNavigationMode = /*@__PURE__*/ (function (_super) {\r\n    __extends(StrictNavigationMode, _super);\r\n    /**\r\n     * Constructor\r\n     *\r\n     * @param {WizardState} wizardState The state of the wizard, that is configured with this navigation mode\r\n     */\r\n    function StrictNavigationMode(wizardState) {\r\n        return _super.call(this, wizardState) || this;\r\n    }\r\n    /**\r\n     * Checks whether the wizard can be transitioned to the given destination step.\r\n     * A destination wizard step can be entered if:\r\n     * - it exists\r\n     * - the current step can be exited in the direction of the destination step\r\n     * - all previous steps to the destination step have been completed or are optional\r\n     *\r\n     * @param {number} destinationIndex The index of the destination wizard step\r\n     * @returns {boolean} True if the destination wizard step can be entered, false otherwise\r\n     */\r\n    StrictNavigationMode.prototype.canGoToStep = function (destinationIndex) {\r\n        var _this = this;\r\n        var hasStep = this.wizardState.hasStep(destinationIndex);\r\n        var movingDirection = this.wizardState.getMovingDirection(destinationIndex);\r\n        var canExitCurrentStep = function (previous) {\r\n            return previous ? _this.wizardState.currentStep.canExitStep(movingDirection) : Promise.resolve(false);\r\n        };\r\n        var canEnterDestinationStep = function (previous) {\r\n            return previous ? _this.wizardState.getStepAtIndex(destinationIndex).canEnterStep(movingDirection) : Promise.resolve(false);\r\n        };\r\n        var allPreviousStepsComplete = function (previous) {\r\n            if (previous) {\r\n                return Promise.resolve(_this.wizardState.wizardSteps\r\n                    .filter(function (step, index) { return index < destinationIndex && index !== _this.wizardState.currentStepIndex; })\r\n                    .every(function (step) { return step.completed || step.optional; }));\r\n            }\r\n            else {\r\n                return Promise.resolve(false);\r\n            }\r\n        };\r\n        return Promise.resolve(hasStep)\r\n            .then(canExitCurrentStep)\r\n            .then(canEnterDestinationStep)\r\n            .then(allPreviousStepsComplete);\r\n    };\r\n    /**\r\n     * Tries to enter the wizard step with the given destination index.\r\n     * When entering the destination step, the following actions are done:\r\n     * - the old current step is set as completed\r\n     * - the old current step is set as unselected\r\n     * - the old current step is exited\r\n     * - all steps between the old current step and the destination step are marked as incomplete\r\n     * - the destination step is set as selected\r\n     * - the destination step is entered\r\n     *\r\n     * When the destination step couldn't be entered, the following actions are done:\r\n     * - the current step is exited and entered in the direction `MovingDirection.Stay`\r\n     *\r\n     * @param {number} destinationIndex The index of the destination wizard step, which should be entered\r\n     * @param {EventEmitter<void>} preFinalize An event emitter, to be called before the step has been transitioned\r\n     * @param {EventEmitter<void>} postFinalize An event emitter, to be called after the step has been transitioned\r\n     */\r\n    StrictNavigationMode.prototype.goToStep = function (destinationIndex, preFinalize, postFinalize) {\r\n        var _this = this;\r\n        this.canGoToStep(destinationIndex).then(function (navigationAllowed) {\r\n            if (navigationAllowed) {\r\n                var movingDirection = _this.wizardState.getMovingDirection(destinationIndex);\r\n                /* istanbul ignore if */\r\n                if (preFinalize) {\r\n                    preFinalize.emit();\r\n                }\r\n                // leave current step\r\n                _this.wizardState.currentStep.completed = true;\r\n                _this.wizardState.currentStep.exit(movingDirection);\r\n                _this.wizardState.currentStep.selected = false;\r\n                // set all steps after the destination step to incomplete\r\n                _this.wizardState.wizardSteps\r\n                    .filter(function (step, index) { return _this.wizardState.currentStepIndex > destinationIndex && index > destinationIndex; })\r\n                    .forEach(function (step) { return step.completed = false; });\r\n                _this.wizardState.currentStepIndex = destinationIndex;\r\n                // go to next step\r\n                _this.wizardState.currentStep.enter(movingDirection);\r\n                _this.wizardState.currentStep.selected = true;\r\n                /* istanbul ignore if */\r\n                if (postFinalize) {\r\n                    postFinalize.emit();\r\n                }\r\n            }\r\n            else {\r\n                // if the current step can't be left, reenter the current step\r\n                _this.wizardState.currentStep.exit(MovingDirection.Stay);\r\n                _this.wizardState.currentStep.enter(MovingDirection.Stay);\r\n            }\r\n        });\r\n    };\r\n    StrictNavigationMode.prototype.isNavigable = function (destinationIndex) {\r\n        // a wizard step can be navigated to through the navigation bar, iff it's located before the current wizard step\r\n        return destinationIndex < this.wizardState.currentStepIndex;\r\n    };\r\n    /**\r\n     * Resets the state of this wizard.\r\n     * A reset transitions the wizard automatically to the first step and sets all steps as incomplete.\r\n     * In addition the whole wizard is set as incomplete\r\n     */\r\n    StrictNavigationMode.prototype.reset = function () {\r\n        var _this = this;\r\n        // the wizard doesn't contain a step with the default step index\r\n        if (!this.wizardState.hasStep(this.wizardState.defaultStepIndex)) {\r\n            throw new Error(\"The wizard doesn't contain a step with index \" + this.wizardState.defaultStepIndex);\r\n        }\r\n        // at least one step is before the default step, that is not optional\r\n        var illegalDefaultStep = this.wizardState.wizardSteps\r\n            .filter(function (step, index) { return index < _this.wizardState.defaultStepIndex; })\r\n            .some(function (step) { return !step.optional; });\r\n        if (illegalDefaultStep) {\r\n            throw new Error(\"The default step index \" + this.wizardState.defaultStepIndex + \" is located after a non optional step\");\r\n        }\r\n        // reset the step internal state\r\n        this.wizardState.wizardSteps.forEach(function (step) {\r\n            step.completed = false;\r\n            step.selected = false;\r\n        });\r\n        // set the first step as the current step\r\n        this.wizardState.currentStepIndex = this.wizardState.defaultStepIndex;\r\n        this.wizardState.currentStep.selected = true;\r\n        this.wizardState.currentStep.enter(MovingDirection.Forwards);\r\n    };\r\n    return StrictNavigationMode;\r\n}(NavigationMode));\r\nexport { StrictNavigationMode };\r\n//# sourceMappingURL=strict-navigation-mode.js.map \r\n",null]}