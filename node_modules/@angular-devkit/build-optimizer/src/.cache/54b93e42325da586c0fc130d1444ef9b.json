{"remainingRequest":"C:\\wamp64\\www\\sigespro\\front\\sigespro\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--3-1!C:\\wamp64\\www\\sigespro\\front\\sigespro\\node_modules\\core-js\\modules\\es7.observable.js","dependencies":[{"path":"C:\\wamp64\\www\\sigespro\\front\\sigespro\\node_modules\\core-js\\modules\\es7.observable.js","mtime":1594653264000},{"path":"C:\\wamp64\\www\\sigespro\\front\\sigespro\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1594653262000},{"path":"C:\\wamp64\\www\\sigespro\\front\\sigespro\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1594653256000}],"contextDependencies":[],"result":["'use strict';\r\n// https://github.com/zenparsing/es-observable\r\nvar $export = require('./_export');\r\nvar global = require('./_global');\r\nvar core = require('./_core');\r\nvar microtask = require('./_microtask')();\r\nvar OBSERVABLE = require('./_wks')('observable');\r\nvar aFunction = require('./_a-function');\r\nvar anObject = require('./_an-object');\r\nvar anInstance = require('./_an-instance');\r\nvar redefineAll = require('./_redefine-all');\r\nvar hide = require('./_hide');\r\nvar forOf = require('./_for-of');\r\nvar RETURN = forOf.RETURN;\r\n\r\nvar getMethod = function (fn) {\r\n  return fn == null ? undefined : aFunction(fn);\r\n};\r\n\r\nvar cleanupSubscription = function (subscription) {\r\n  var cleanup = subscription._c;\r\n  if (cleanup) {\r\n    subscription._c = undefined;\r\n    cleanup();\r\n  }\r\n};\r\n\r\nvar subscriptionClosed = function (subscription) {\r\n  return subscription._o === undefined;\r\n};\r\n\r\nvar closeSubscription = function (subscription) {\r\n  if (!subscriptionClosed(subscription)) {\r\n    subscription._o = undefined;\r\n    cleanupSubscription(subscription);\r\n  }\r\n};\r\n\r\nvar Subscription = function (observer, subscriber) {\r\n  anObject(observer);\r\n  this._c = undefined;\r\n  this._o = observer;\r\n  observer = new SubscriptionObserver(this);\r\n  try {\r\n    var cleanup = subscriber(observer);\r\n    var subscription = cleanup;\r\n    if (cleanup != null) {\r\n      if (typeof cleanup.unsubscribe === 'function') cleanup = function () { subscription.unsubscribe(); };\r\n      else aFunction(cleanup);\r\n      this._c = cleanup;\r\n    }\r\n  } catch (e) {\r\n    observer.error(e);\r\n    return;\r\n  } if (subscriptionClosed(this)) cleanupSubscription(this);\r\n};\r\n\r\nSubscription.prototype = redefineAll({}, {\r\n  unsubscribe: function unsubscribe() { closeSubscription(this); }\r\n});\r\n\r\nvar SubscriptionObserver = function (subscription) {\r\n  this._s = subscription;\r\n};\r\n\r\nSubscriptionObserver.prototype = redefineAll({}, {\r\n  next: function next(value) {\r\n    var subscription = this._s;\r\n    if (!subscriptionClosed(subscription)) {\r\n      var observer = subscription._o;\r\n      try {\r\n        var m = getMethod(observer.next);\r\n        if (m) return m.call(observer, value);\r\n      } catch (e) {\r\n        try {\r\n          closeSubscription(subscription);\r\n        } finally {\r\n          throw e;\r\n        }\r\n      }\r\n    }\r\n  },\r\n  error: function error(value) {\r\n    var subscription = this._s;\r\n    if (subscriptionClosed(subscription)) throw value;\r\n    var observer = subscription._o;\r\n    subscription._o = undefined;\r\n    try {\r\n      var m = getMethod(observer.error);\r\n      if (!m) throw value;\r\n      value = m.call(observer, value);\r\n    } catch (e) {\r\n      try {\r\n        cleanupSubscription(subscription);\r\n      } finally {\r\n        throw e;\r\n      }\r\n    } cleanupSubscription(subscription);\r\n    return value;\r\n  },\r\n  complete: function complete(value) {\r\n    var subscription = this._s;\r\n    if (!subscriptionClosed(subscription)) {\r\n      var observer = subscription._o;\r\n      subscription._o = undefined;\r\n      try {\r\n        var m = getMethod(observer.complete);\r\n        value = m ? m.call(observer, value) : undefined;\r\n      } catch (e) {\r\n        try {\r\n          cleanupSubscription(subscription);\r\n        } finally {\r\n          throw e;\r\n        }\r\n      } cleanupSubscription(subscription);\r\n      return value;\r\n    }\r\n  }\r\n});\r\n\r\nvar $Observable = function Observable(subscriber) {\r\n  anInstance(this, $Observable, 'Observable', '_f')._f = aFunction(subscriber);\r\n};\r\n\r\nredefineAll($Observable.prototype, {\r\n  subscribe: function subscribe(observer) {\r\n    return new Subscription(observer, this._f);\r\n  },\r\n  forEach: function forEach(fn) {\r\n    var that = this;\r\n    return new (core.Promise || global.Promise)(function (resolve, reject) {\r\n      aFunction(fn);\r\n      var subscription = that.subscribe({\r\n        next: function (value) {\r\n          try {\r\n            return fn(value);\r\n          } catch (e) {\r\n            reject(e);\r\n            subscription.unsubscribe();\r\n          }\r\n        },\r\n        error: reject,\r\n        complete: resolve\r\n      });\r\n    });\r\n  }\r\n});\r\n\r\nredefineAll($Observable, {\r\n  from: function from(x) {\r\n    var C = typeof this === 'function' ? this : $Observable;\r\n    var method = getMethod(anObject(x)[OBSERVABLE]);\r\n    if (method) {\r\n      var observable = anObject(method.call(x));\r\n      return observable.constructor === C ? observable : new C(function (observer) {\r\n        return observable.subscribe(observer);\r\n      });\r\n    }\r\n    return new C(function (observer) {\r\n      var done = false;\r\n      microtask(function () {\r\n        if (!done) {\r\n          try {\r\n            if (forOf(x, false, function (it) {\r\n              observer.next(it);\r\n              if (done) return RETURN;\r\n            }) === RETURN) return;\r\n          } catch (e) {\r\n            if (done) throw e;\r\n            observer.error(e);\r\n            return;\r\n          } observer.complete();\r\n        }\r\n      });\r\n      return function () { done = true; };\r\n    });\r\n  },\r\n  of: function of() {\r\n    for (var i = 0, l = arguments.length, items = new Array(l); i < l;) items[i] = arguments[i++];\r\n    return new (typeof this === 'function' ? this : $Observable)(function (observer) {\r\n      var done = false;\r\n      microtask(function () {\r\n        if (!done) {\r\n          for (var j = 0; j < items.length; ++j) {\r\n            observer.next(items[j]);\r\n            if (done) return;\r\n          } observer.complete();\r\n        }\r\n      });\r\n      return function () { done = true; };\r\n    });\r\n  }\r\n});\r\n\r\nhide($Observable.prototype, OBSERVABLE, function () { return this; });\r\n\r\n$export($export.G, { Observable: $Observable });\r\n\r\nrequire('./_set-species')('Observable');\r\n",null]}