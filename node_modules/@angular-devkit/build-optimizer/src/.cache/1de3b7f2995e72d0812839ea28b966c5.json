{"remainingRequest":"C:\\wamp64\\www\\sigespro\\front\\sigespro\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--3-1!C:\\wamp64\\www\\sigespro\\front\\sigespro\\src\\assets\\charts\\amchart\\pie.js","dependencies":[{"path":"C:\\wamp64\\www\\sigespro\\front\\sigespro\\src\\assets\\charts\\amchart\\pie.js","mtime":1598543100635},{"path":"C:\\wamp64\\www\\sigespro\\front\\sigespro\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1594653262000},{"path":"C:\\wamp64\\www\\sigespro\\front\\sigespro\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1594653256000}],"contextDependencies":[],"result":["(function () { var k = window.AmCharts; k.AmSlicedChart = k.Class({ inherits: k.AmChart, construct: function (a) { this.createEvents(\"rollOverSlice\", \"rollOutSlice\", \"clickSlice\", \"pullOutSlice\", \"pullInSlice\", \"rightClickSlice\"); k.AmSlicedChart.base.construct.call(this, a); this.colors = \"#FF0F00 #FF6600 #FF9E01 #FCD202 #F8FF01 #B0DE09 #04D215 #0D8ECF #0D52D1 #2A0CD0 #8A0CCF #CD0D74 #754DEB #DDDDDD #999999 #333333 #000000 #57032A #CA9726 #990000 #4B0C25\".split(\" \"); this.alpha = 1; this.groupPercent = 0; this.groupedTitle = \"Other\"; this.groupedPulled = !1; this.groupedAlpha = 1; this.marginLeft = 0; this.marginBottom = this.marginTop = 10; this.marginRight = 0; this.hoverAlpha = 1; this.outlineColor = \"#FFFFFF\"; this.outlineAlpha = 0; this.outlineThickness = 1; this.startAlpha = 0; this.startDuration = 1; this.startEffect = \"bounce\"; this.sequencedAnimation = !0; this.pullOutDuration = 1; this.pullOutEffect = \"bounce\"; this.pullOnHover = this.pullOutOnlyOne = !1; this.labelsEnabled = !0; this.labelTickColor = \"#000000\"; this.labelTickAlpha = .2; this.hideLabelsPercent = 0; this.urlTarget = \"_self\"; this.autoMarginOffset = 10; this.gradientRatio = []; this.maxLabelWidth = 200; this.accessibleLabel = \"[[title]]: [[percents]]% [[value]] [[description]]\"; k.applyTheme(this, a, \"AmSlicedChart\"); }, initChart: function () { k.AmSlicedChart.base.initChart.call(this); this.dataChanged && (this.parseData(), this.dispatchDataUpdated = !0, this.dataChanged = !1, this.setLegendData(this.chartData)); this.drawChart(); }, handleLegendEvent: function (a) { var b = a.type, c = a.dataItem, d = this.legend; if (c.wedge && c) {\r\n        var g = c.hidden;\r\n        a = a.event;\r\n        switch (b) {\r\n            case \"clickMarker\":\r\n                g || d.switchable || this.clickSlice(c, a);\r\n                break;\r\n            case \"clickLabel\":\r\n                g || this.clickSlice(c, a, !1);\r\n                break;\r\n            case \"rollOverItem\":\r\n                g || this.rollOverSlice(c, !1, a);\r\n                break;\r\n            case \"rollOutItem\":\r\n                g || this.rollOutSlice(c, a);\r\n                break;\r\n            case \"hideItem\":\r\n                this.hideSlice(c, a);\r\n                break;\r\n            case \"showItem\": this.showSlice(c, a);\r\n        }\r\n    } }, invalidateVisibility: function () { this.recalculatePercents(); this.initChart(); var a = this.legend; a && a.invalidateSize(); }, addEventListeners: function (a, b) { var c = this; a.mouseover(function (a) { c.rollOverSlice(b, !0, a); }).mouseout(function (a) { c.rollOutSlice(b, a); }).touchend(function (a) { c.rollOverSlice(b, a); }).mouseup(function (a) { c.clickSlice(b, a); }).contextmenu(function (a) { c.handleRightClick(b, a); }); }, formatString: function (a, b, c) { a = k.formatValue(a, b, [\"value\"], this.nf, \"\", this.usePrefixes, this.prefixesOfSmallNumbers, this.prefixesOfBigNumbers); var d = this.pf.precision; isNaN(this.tempPrec) || (this.pf.precision = this.tempPrec); a = k.formatValue(a, b, [\"percents\"], this.pf); a = k.massReplace(a, { \"[[title]]\": b.title, \"[[description]]\": b.description }); this.pf.precision = d; -1 != a.indexOf(\"[[\") && (a = k.formatDataContextValue(a, b.dataContext)); a = c ? k.fixNewLines(a) : k.fixBrakes(a); return a = k.cleanFromEmpty(a); }, startSlices: function () { var a; for (a = 0; a < this.chartData.length; a++)\r\n        0 < this.startDuration && this.sequencedAnimation ? this.setStartTO(a) : this.startSlice(this.chartData[a]); }, setStartTO: function (a) { var b = this; a = setTimeout(function () { b.startSequenced.call(b); }, b.startDuration / b.chartData.length * 500 * a); b.timeOuts.push(a); }, pullSlices: function (a) { var b = this.chartData, c; for (c = 0; c < b.length; c++) {\r\n        var d = b[c];\r\n        d.pulled && this.pullSlice(d, 1, a);\r\n    } }, startSequenced: function () { var a = this.chartData, b; for (b = 0; b < a.length; b++)\r\n        if (!a[b].started) {\r\n            this.startSlice(this.chartData[b]);\r\n            break;\r\n        } }, startSlice: function (a) { a.started = !0; var b = a.wedge, c = this.startDuration, d = a.labelSet; b && 0 < c && (0 < a.alpha && b.show(), b.translate(a.startX, a.startY), this.animatable.push(b), b.animate({ opacity: 1, translate: \"0,0\" }, c, this.startEffect)); d && 0 < c && (0 < a.alpha && d.show(), d.translate(a.startX, a.startY), d.animate({ opacity: 1, translate: \"0,0\" }, c, this.startEffect)); }, showLabels: function () { var a = this.chartData, b; for (b = 0; b < a.length; b++) {\r\n        var c = a[b];\r\n        if (0 < c.alpha) {\r\n            var d = c.label;\r\n            d && d.show();\r\n            (c = c.tick) && c.show();\r\n        }\r\n    } }, showSlice: function (a) { isNaN(a) ? a.hidden = !1 : this.chartData[a].hidden = !1; this.invalidateVisibility(); }, hideSlice: function (a) { isNaN(a) ? a.hidden = !0 : this.chartData[a].hidden = !0; this.hideBalloon(); this.invalidateVisibility(); }, rollOverSlice: function (a, b, c) { isNaN(a) || (a = this.chartData[a]); clearTimeout(this.hoverInt); if (!a.hidden) {\r\n        this.pullOnHover && this.pullSlice(a, 1);\r\n        1 > this.hoverAlpha && a.wedge && a.wedge.attr({ opacity: this.hoverAlpha });\r\n        var d = a.balloonX, g = a.balloonY;\r\n        a.pulled && (d += a.pullX, g += a.pullY);\r\n        var f = this.formatString(this.balloonText, a, !0), h = this.balloonFunction;\r\n        h && (f = h(a, f));\r\n        h = k.adjustLuminosity(a.color, -.15);\r\n        f ? this.showBalloon(f, h, b, d, g) : this.hideBalloon();\r\n        0 === a.value && this.hideBalloon();\r\n        this.fire({ type: \"rollOverSlice\", dataItem: a, chart: this, event: c });\r\n    } }, rollOutSlice: function (a, b) { isNaN(a) || (a = this.chartData[a]); a.wedge && a.wedge.attr({ opacity: 1 }); this.hideBalloon(); this.fire({ type: \"rollOutSlice\", dataItem: a, chart: this, event: b }); }, clickSlice: function (a, b, c) { this.checkTouchDuration(b) && (isNaN(a) || (a = this.chartData[a]), a.pulled ? this.pullSlice(a, 0) : this.pullSlice(a, 1), k.getURL(a.url, this.urlTarget), c || this.fire({ type: \"clickSlice\", dataItem: a, chart: this, event: b })); }, handleRightClick: function (a, b) { isNaN(a) || (a = this.chartData[a]); this.fire({ type: \"rightClickSlice\", dataItem: a, chart: this, event: b }); }, drawTicks: function () { var a = this.chartData, b; for (b = 0; b < a.length; b++) {\r\n        var c = a[b];\r\n        if (c.label && !c.skipTick) {\r\n            var d = c.ty, d = k.line(this.container, [c.tx0, c.tx, c.tx2], [c.ty0, d, d], this.labelTickColor, this.labelTickAlpha);\r\n            k.setCN(this, d, this.type + \"-tick\");\r\n            k.setCN(this, d, c.className, !0);\r\n            c.tick = d;\r\n            c.wedge.push(d);\r\n            \"AmFunnelChart\" == this.cname && d.toBack();\r\n        }\r\n    } }, initialStart: function () { var a = this, b = a.startDuration, c = setTimeout(function () { a.showLabels.call(a); }, 1E3 * b); a.timeOuts.push(c); a.chartCreated ? a.pullSlices(!0) : (a.startSlices(), 0 < b ? (b = setTimeout(function () { a.pullSlices.call(a); }, 1200 * b), a.timeOuts.push(b)) : a.pullSlices(!0)); }, pullSlice: function (a, b, c) { var d = this.pullOutDuration; !0 === c && (d = 0); if (c = a.wedge)\r\n        0 < d ? (c.animate({ translate: b * a.pullX + \",\" + b * a.pullY }, d, this.pullOutEffect), a.labelSet && a.labelSet.animate({ translate: b * a.pullX + \",\" + b * a.pullY }, d, this.pullOutEffect)) : (a.labelSet && a.labelSet.translate(b * a.pullX, b * a.pullY), c.translate(b * a.pullX, b * a.pullY)); 1 == b ? (a.pulled = !0, this.pullOutOnlyOne && this.pullInAll(a.index), a = { type: \"pullOutSlice\", dataItem: a, chart: this }) : (a.pulled = !1, a = { type: \"pullInSlice\", dataItem: a, chart: this }); this.fire(a); }, pullInAll: function (a) { var b = this.chartData, c; for (c = 0; c < this.chartData.length; c++)\r\n        c != a && b[c].pulled && this.pullSlice(b[c], 0); }, pullOutAll: function () { var a = this.chartData, b; for (b = 0; b < a.length; b++)\r\n        a[b].pulled || this.pullSlice(a[b], 1); }, parseData: function () { var a = []; this.chartData = a; var b = this.dataProvider; isNaN(this.pieAlpha) || (this.alpha = this.pieAlpha); if (void 0 !== b) {\r\n        var c = b.length, d = 0, g, f, h;\r\n        for (g = 0; g < c; g++) {\r\n            f = {};\r\n            var e = b[g];\r\n            f.dataContext = e;\r\n            null !== e[this.valueField] && (f.value = Number(e[this.valueField]));\r\n            (h = e[this.titleField]) || (h = \"\");\r\n            f.title = h;\r\n            f.pulled = k.toBoolean(e[this.pulledField], !1);\r\n            (h = e[this.descriptionField]) || (h = \"\");\r\n            f.description = h;\r\n            f.labelRadius = Number(e[this.labelRadiusField]);\r\n            f.switchable = !0;\r\n            f.className = e[this.classNameField];\r\n            f.url = e[this.urlField];\r\n            h = e[this.patternField];\r\n            !h && this.patterns && (h = this.patterns[g]);\r\n            f.pattern = h;\r\n            f.visibleInLegend = k.toBoolean(e[this.visibleInLegendField], !0);\r\n            h = e[this.alphaField];\r\n            f.alpha = void 0 !== h ? Number(h) : this.alpha;\r\n            h = e[this.colorField];\r\n            void 0 !== h && (f.color = h);\r\n            f.labelColor = k.toColor(e[this.labelColorField]);\r\n            d += f.value;\r\n            f.hidden = !1;\r\n            a[g] = f;\r\n        }\r\n        for (g = b = 0; g < c; g++)\r\n            f = a[g], f.percents = f.value / d * 100, f.percents < this.groupPercent && b++;\r\n        1 < b && (this.groupValue = 0, this.removeSmallSlices(), a.push({ title: this.groupedTitle, value: this.groupValue, percents: this.groupValue / d * 100, pulled: this.groupedPulled, color: this.groupedColor, url: this.groupedUrl, description: this.groupedDescription, alpha: this.groupedAlpha, pattern: this.groupedPattern, className: this.groupedClassName, dataContext: {} }));\r\n        c = this.baseColor;\r\n        c || (c = this.pieBaseColor);\r\n        d = this.brightnessStep;\r\n        d || (d = this.pieBrightnessStep);\r\n        for (g = 0; g < a.length; g++)\r\n            c ? h = k.adjustLuminosity(c, g * d / 100) : (h = this.colors[g], void 0 === h && (h = k.randomColor())), void 0 === a[g].color && (a[g].color = h);\r\n        this.recalculatePercents();\r\n    } }, recalculatePercents: function () { var a = this.chartData, b = 0, c, d; for (c = 0; c < a.length; c++)\r\n        d = a[c], !d.hidden && 0 < d.value && (b += d.value); for (c = 0; c < a.length; c++)\r\n        d = this.chartData[c], d.percents = !d.hidden && 0 < d.value ? 100 * d.value / b : 0; }, removeSmallSlices: function () { var a = this.chartData, b; for (b = a.length - 1; 0 <= b; b--)\r\n        a[b].percents < this.groupPercent && (this.groupValue += a[b].value, a.splice(b, 1)); }, animateAgain: function () { var a = this; a.startSlices(); for (var b = 0; b < a.chartData.length; b++) {\r\n        var c = a.chartData[b];\r\n        c.started = !1;\r\n        var d = c.wedge;\r\n        d && (d.setAttr(\"opacity\", a.startAlpha), d.translate(c.startX, c.startY));\r\n        if (d = c.labelSet)\r\n            d.setAttr(\"opacity\", a.startAlpha), d.translate(c.startX, c.startY);\r\n    } b = a.startDuration; 0 < b ? (b = setTimeout(function () { a.pullSlices.call(a); }, 1200 * b), a.timeOuts.push(b)) : a.pullSlices(); }, measureMaxLabel: function () { var a = this.chartData, b = 0, c; for (c = 0; c < a.length; c++) {\r\n        var d = a[c], g = this.formatString(this.labelText, d), f = this.labelFunction;\r\n        f && (g = f(d, g));\r\n        d = k.text(this.container, g, this.color, this.fontFamily, this.fontSize);\r\n        g = d.getBBox().width;\r\n        g > b && (b = g);\r\n        d.remove();\r\n    } return b; } }); })();\r\n(function () {\r\n    var k = window.AmCharts;\r\n    k.AmPieChart = k.Class({ inherits: k.AmSlicedChart, construct: function (a) { this.type = \"pie\"; k.AmPieChart.base.construct.call(this, a); this.cname = \"AmPieChart\"; this.pieBrightnessStep = 30; this.minRadius = 10; this.depth3D = 0; this.startAngle = 90; this.angle = this.innerRadius = 0; this.startRadius = \"500%\"; this.pullOutRadius = \"20%\"; this.labelRadius = 20; this.labelText = \"[[title]]: [[percents]]%\"; this.balloonText = \"[[title]]: [[percents]]% ([[value]])\\n[[description]]\"; this.previousScale = 1; this.adjustPrecision = !1; this.gradientType = \"radial\"; k.applyTheme(this, a, this.cname); }, drawChart: function () {\r\n            k.AmPieChart.base.drawChart.call(this);\r\n            var a = this.chartData;\r\n            if (k.ifArray(a)) {\r\n                if (0 < this.realWidth && 0 < this.realHeight) {\r\n                    k.VML && (this.startAlpha = 1);\r\n                    var b = this.startDuration, c = this.container, d = this.updateWidth();\r\n                    this.realWidth = d;\r\n                    var g = this.updateHeight();\r\n                    this.realHeight = g;\r\n                    var f = k.toCoordinate, h = f(this.marginLeft, d), e = f(this.marginRight, d), z = f(this.marginTop, g) + this.getTitleHeight(), n = f(this.marginBottom, g) + this.depth3D, A, B, m, w = k.toNumber(this.labelRadius), q = this.measureMaxLabel();\r\n                    q > this.maxLabelWidth && (q = this.maxLabelWidth);\r\n                    this.labelText && this.labelsEnabled || (w = q = 0);\r\n                    A = void 0 === this.pieX ? (d - h - e) / 2 + h : f(this.pieX, this.realWidth);\r\n                    B = void 0 === this.pieY ? (g - z - n) / 2 + z : f(this.pieY, g);\r\n                    m = f(this.radius, d, g);\r\n                    m || (d = 0 <= w ? d - h - e - 2 * q : d - h - e, g = g - z - n, m = Math.min(d, g), g < d && (m /= 1 - this.angle / 90, m > d && (m = d)), g = k.toCoordinate(this.pullOutRadius, m), m = (0 <= w ? m - 1.8 * (w + g) : m - 1.8 * g) / 2);\r\n                    m < this.minRadius && (m = this.minRadius);\r\n                    g = f(this.pullOutRadius, m);\r\n                    z = k.toCoordinate(this.startRadius, m);\r\n                    f = f(this.innerRadius, m);\r\n                    f >= m && (f = m - 1);\r\n                    n = k.fitToBounds(this.startAngle, 0, 360);\r\n                    0 < this.depth3D && (n = 270 <= n ? 270 : 90);\r\n                    n -= 90;\r\n                    360 < n && (n -= 360);\r\n                    d = m - m * this.angle / 90;\r\n                    for (h = q = 0; h < a.length; h++)\r\n                        e = a[h], !0 !== e.hidden && (q += k.roundTo(e.percents, this.pf.precision));\r\n                    q = k.roundTo(q, this.pf.precision);\r\n                    this.tempPrec = NaN;\r\n                    this.adjustPrecision && 100 != q && (this.tempPrec = this.pf.precision + 1);\r\n                    for (var E, h = 0; h < a.length; h++)\r\n                        if (e = a[h], !0 !== e.hidden && (this.showZeroSlices || 0 !== e.percents)) {\r\n                            var r = 360 * e.percents / 100, q = Math.sin((n + r / 2) / 180 * Math.PI), C = d / m * -Math.cos((n + r / 2) / 180 * Math.PI), p = this.outlineColor;\r\n                            p || (p = e.color);\r\n                            var u = this.alpha;\r\n                            isNaN(e.alpha) || (u = e.alpha);\r\n                            p = { fill: e.color, stroke: p, \"stroke-width\": this.outlineThickness, \"stroke-opacity\": this.outlineAlpha, \"fill-opacity\": u };\r\n                            e.url && (p.cursor = \"pointer\");\r\n                            p = k.wedge(c, A, B, n, r, m, d, f, this.depth3D, p, this.gradientRatio, e.pattern, this.path, this.gradientType);\r\n                            k.setCN(this, p, \"pie-item\");\r\n                            k.setCN(this, p.wedge, \"pie-slice\");\r\n                            k.setCN(this, p, e.className, !0);\r\n                            this.addEventListeners(p, e);\r\n                            e.startAngle = n;\r\n                            a[h].wedge = p;\r\n                            0 < b && (this.chartCreated || p.setAttr(\"opacity\", this.startAlpha));\r\n                            e.ix = q;\r\n                            e.iy = C;\r\n                            e.wedge = p;\r\n                            e.index = h;\r\n                            e.label = null;\r\n                            u = c.set();\r\n                            if (this.labelsEnabled && this.labelText && e.percents >= this.hideLabelsPercent) {\r\n                                var l = n + r / 2;\r\n                                0 > l && (l += 360);\r\n                                360 < l && (l -= 360);\r\n                                var t = w;\r\n                                isNaN(e.labelRadius) || (t = e.labelRadius, 0 > t && (e.skipTick = !0));\r\n                                var r = A + q * (m + t), D = B + C * (m + t), x, v = 0;\r\n                                isNaN(E) && 350 < l && 1 < a.length - h && (E = h - 1 + Math.floor((a.length - h) / 2));\r\n                                if (0 <= t) {\r\n                                    var y;\r\n                                    90 >= l && 0 <= l ? (y = 0, x = \"start\", v = 8) : 90 <= l && 180 > l ? (y = 1,\r\n                                        x = \"start\", v = 8) : 180 <= l && 270 > l ? (y = 2, x = \"end\", v = -8) : 270 <= l && 354 >= l ? (y = 3, x = \"end\", v = -8) : 354 <= l && (h > E ? (y = 0, x = \"start\", v = 8) : (y = 3, x = \"end\", v = -8));\r\n                                    e.labelQuarter = y;\r\n                                }\r\n                                else\r\n                                    x = \"middle\";\r\n                                l = this.formatString(this.labelText, e);\r\n                                (t = this.labelFunction) && (l = t(e, l));\r\n                                t = e.labelColor;\r\n                                t || (t = this.color);\r\n                                \"\" !== l && (l = k.wrappedText(c, l, t, this.fontFamily, this.fontSize, x, !1, this.maxLabelWidth), k.setCN(this, l, \"pie-label\"), k.setCN(this, l, e.className, !0), l.translate(r + 1.5 * v, D), 0 > w && (l.node.style.pointerEvents = \"none\"), l.node.style.cursor = \"default\", e.ty = D, e.textX = r + 1.5 * v, u.push(l), this.axesSet.push(u), e.labelSet = u, e.label = l, this.addEventListeners(u, e));\r\n                                e.tx = r;\r\n                                e.tx2 = r + v;\r\n                                e.tx0 = A + q * m;\r\n                                e.ty0 = B + C * m;\r\n                            }\r\n                            r = f + (m - f) / 2;\r\n                            e.pulled && (r += g);\r\n                            this.accessible && this.accessibleLabel && (D = this.formatString(this.accessibleLabel, e), this.makeAccessible(p, D));\r\n                            void 0 !== this.tabIndex && p.setAttr(\"tabindex\", this.tabIndex);\r\n                            e.balloonX = q * r + A;\r\n                            e.balloonY = C * r + B;\r\n                            e.startX = Math.round(q * z);\r\n                            e.startY = Math.round(C * z);\r\n                            e.pullX = Math.round(q * g);\r\n                            e.pullY = Math.round(C * g);\r\n                            this.graphsSet.push(p);\r\n                            if (0 === e.alpha || 0 < b && !this.chartCreated)\r\n                                p.hide(), u && u.hide();\r\n                            n += 360 * e.percents / 100;\r\n                            360 < n && (n -= 360);\r\n                        }\r\n                    0 < w && this.arrangeLabels();\r\n                    this.pieXReal = A;\r\n                    this.pieYReal = B;\r\n                    this.radiusReal = m;\r\n                    this.innerRadiusReal = f;\r\n                    0 < w && this.drawTicks();\r\n                    this.initialStart();\r\n                    this.setDepths();\r\n                }\r\n                (a = this.legend) && a.invalidateSize();\r\n            }\r\n            else\r\n                this.cleanChart();\r\n            this.dispDUpd();\r\n        }, setDepths: function () { var a = this.chartData, b; for (b = 0; b < a.length; b++) {\r\n            var c = a[b], d = c.wedge, c = c.startAngle;\r\n            0 <= c && 180 > c ? d.toFront() : 180 <= c && d.toBack();\r\n        } }, arrangeLabels: function () { var a = this.chartData, b = a.length, c, d; for (d = b - 1; 0 <= d; d--)\r\n            c = a[d], 0 !== c.labelQuarter || c.hidden || this.checkOverlapping(d, c, 0, !0, 0); for (d = 0; d < b; d++)\r\n            c = a[d], 1 != c.labelQuarter || c.hidden || this.checkOverlapping(d, c, 1, !1, 0); for (d = b - 1; 0 <= d; d--)\r\n            c = a[d], 2 != c.labelQuarter || c.hidden || this.checkOverlapping(d, c, 2, !0, 0); for (d = 0; d < b; d++)\r\n            c = a[d], 3 != c.labelQuarter || c.hidden || this.checkOverlapping(d, c, 3, !1, 0); }, checkOverlapping: function (a, b, c, d, g) { var f, h, e = this.chartData, k = e.length, n = b.label; if (n) {\r\n            if (!0 === d)\r\n                for (h = a + 1; h < k; h++)\r\n                    e[h].labelQuarter == c && (f = this.checkOverlappingReal(b, e[h], c)) && (h = k);\r\n            else\r\n                for (h = a - 1; 0 <= h; h--)\r\n                    e[h].labelQuarter == c && (f = this.checkOverlappingReal(b, e[h], c)) && (h = 0);\r\n            !0 === f && 200 > g && isNaN(b.labelRadius) && (f = b.ty + 3 * b.iy, b.ty = f, n.translate(b.textX, f), this.checkOverlapping(a, b, c, d, g + 1));\r\n        } }, checkOverlappingReal: function (a, b, c) { var d = !1, g = a.label, f = b.label; a.labelQuarter != c || a.hidden || b.hidden || !f || (g = g.getBBox(), c = {}, c.width = g.width, c.height = g.height, c.y = a.ty, c.x = a.tx, a = f.getBBox(), f = {}, f.width = a.width, f.height = a.height, f.y = b.ty, f.x = b.tx, k.hitTest(c, f) && (d = !0)); return d; } });\r\n})();\r\n",null]}