{"remainingRequest":"C:\\Users\\User\\Desktop\\Master-Sigespro\\sigespro\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--3-1!C:\\Users\\User\\Desktop\\Master-Sigespro\\sigespro\\node_modules\\fullcalendar\\dist\\fullcalendar.js","dependencies":[{"path":"C:\\Users\\User\\Desktop\\Master-Sigespro\\sigespro\\node_modules\\fullcalendar\\dist\\fullcalendar.js","mtime":1535664056725},{"path":"C:\\Users\\User\\Desktop\\Master-Sigespro\\sigespro\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1535664048428},{"path":"C:\\Users\\User\\Desktop\\Master-Sigespro\\sigespro\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1535664036292}],"contextDependencies":[],"result":["/*!\r\n * FullCalendar v3.6.1\r\n * Docs & License: https://fullcalendar.io/\r\n * (c) 2017 Adam Shaw\r\n */\r\n\r\n(function(factory) {\r\n\tif (typeof define === 'function' && define.amd) {\r\n\t\tdefine([ 'jquery', 'moment' ], factory);\r\n\t}\r\n\telse if (typeof exports === 'object') { // Node/CommonJS\r\n\t\tmodule.exports = factory(require('jquery'), require('moment'));\r\n\t}\r\n\telse {\r\n\t\tfactory(jQuery, moment);\r\n\t}\r\n})(function($, moment) {\r\n\r\n;;\r\n\r\nvar FC = $.fullCalendar = {\r\n\tversion: \"3.6.1\",\r\n\t// When introducing internal API incompatibilities (where fullcalendar plugins would break),\r\n\t// the minor version of the calendar should be upped (ex: 2.7.2 -> 2.8.0)\r\n\t// and the below integer should be incremented.\r\n\tinternalApiVersion: 11\r\n};\r\nvar fcViews = FC.views = {};\r\n\r\n\r\n$.fn.fullCalendar = function(options) {\r\n\tvar args = Array.prototype.slice.call(arguments, 1); // for a possible method call\r\n\tvar res = this; // what this function will return (this jQuery object by default)\r\n\r\n\tthis.each(function(i, _element) { // loop each DOM element involved\r\n\t\tvar element = $(_element);\r\n\t\tvar calendar = element.data('fullCalendar'); // get the existing calendar object (if any)\r\n\t\tvar singleRes; // the returned value of this single method call\r\n\r\n\t\t// a method call\r\n\t\tif (typeof options === 'string') {\r\n\r\n\t\t\tif (options === 'getCalendar') {\r\n\t\t\t\tif (!i) { // first element only\r\n\t\t\t\t\tres = calendar;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse if (options === 'destroy') { // don't warn if no calendar object\r\n\t\t\t\tif (calendar) {\r\n\t\t\t\t\tcalendar.destroy();\r\n\t\t\t\t\telement.removeData('fullCalendar');\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse if (!calendar) {\r\n\t\t\t\tFC.warn(\"Attempting to call a FullCalendar method on an element with no calendar.\");\r\n\t\t\t}\r\n\t\t\telse if ($.isFunction(calendar[options])) {\r\n\t\t\t\tsingleRes = calendar[options].apply(calendar, args);\r\n\r\n\t\t\t\tif (!i) {\r\n\t\t\t\t\tres = singleRes; // record the first method call result\r\n\t\t\t\t}\r\n\t\t\t\tif (options === 'destroy') { // for the destroy method, must remove Calendar object data\r\n\t\t\t\t\telement.removeData('fullCalendar');\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tFC.warn(\"'\" + options + \"' is an unknown FullCalendar method.\");\r\n\t\t\t}\r\n\t\t}\r\n\t\t// a new calendar initialization\r\n\t\telse if (!calendar) { // don't initialize twice\r\n\t\t\tcalendar = new Calendar(element, options);\r\n\t\t\telement.data('fullCalendar', calendar);\r\n\t\t\tcalendar.render();\r\n\t\t}\r\n\t});\r\n\r\n\treturn res;\r\n};\r\n\r\n\r\nvar complexOptions = [ // names of options that are objects whose properties should be combined\r\n\t'header',\r\n\t'footer',\r\n\t'buttonText',\r\n\t'buttonIcons',\r\n\t'themeButtonIcons'\r\n];\r\n\r\n\r\n// Merges an array of option objects into a single object\r\nfunction mergeOptions(optionObjs) {\r\n\treturn mergeProps(optionObjs, complexOptions);\r\n}\r\n\r\n;;\r\n\r\n// exports\r\nFC.applyAll = applyAll;\r\nFC.debounce = debounce;\r\nFC.isInt = isInt;\r\nFC.htmlEscape = htmlEscape;\r\nFC.cssToStr = cssToStr;\r\nFC.proxy = proxy;\r\nFC.capitaliseFirstLetter = capitaliseFirstLetter;\r\n\r\n\r\n/* FullCalendar-specific DOM Utilities\r\n----------------------------------------------------------------------------------------------------------------------*/\r\n\r\n\r\n// Given the scrollbar widths of some other container, create borders/margins on rowEls in order to match the left\r\n// and right space that was offset by the scrollbars. A 1-pixel border first, then margin beyond that.\r\nfunction compensateScroll(rowEls, scrollbarWidths) {\r\n\tif (scrollbarWidths.left) {\r\n\t\trowEls.css({\r\n\t\t\t'border-left-width': 1,\r\n\t\t\t'margin-left': scrollbarWidths.left - 1\r\n\t\t});\r\n\t}\r\n\tif (scrollbarWidths.right) {\r\n\t\trowEls.css({\r\n\t\t\t'border-right-width': 1,\r\n\t\t\t'margin-right': scrollbarWidths.right - 1\r\n\t\t});\r\n\t}\r\n}\r\n\r\n\r\n// Undoes compensateScroll and restores all borders/margins\r\nfunction uncompensateScroll(rowEls) {\r\n\trowEls.css({\r\n\t\t'margin-left': '',\r\n\t\t'margin-right': '',\r\n\t\t'border-left-width': '',\r\n\t\t'border-right-width': ''\r\n\t});\r\n}\r\n\r\n\r\n// Make the mouse cursor express that an event is not allowed in the current area\r\nfunction disableCursor() {\r\n\t$('body').addClass('fc-not-allowed');\r\n}\r\n\r\n\r\n// Returns the mouse cursor to its original look\r\nfunction enableCursor() {\r\n\t$('body').removeClass('fc-not-allowed');\r\n}\r\n\r\n\r\n// Given a total available height to fill, have `els` (essentially child rows) expand to accomodate.\r\n// By default, all elements that are shorter than the recommended height are expanded uniformly, not considering\r\n// any other els that are already too tall. if `shouldRedistribute` is on, it considers these tall rows and \r\n// reduces the available height.\r\nfunction distributeHeight(els, availableHeight, shouldRedistribute) {\r\n\r\n\t// *FLOORING NOTE*: we floor in certain places because zoom can give inaccurate floating-point dimensions,\r\n\t// and it is better to be shorter than taller, to avoid creating unnecessary scrollbars.\r\n\r\n\tvar minOffset1 = Math.floor(availableHeight / els.length); // for non-last element\r\n\tvar minOffset2 = Math.floor(availableHeight - minOffset1 * (els.length - 1)); // for last element *FLOORING NOTE*\r\n\tvar flexEls = []; // elements that are allowed to expand. array of DOM nodes\r\n\tvar flexOffsets = []; // amount of vertical space it takes up\r\n\tvar flexHeights = []; // actual css height\r\n\tvar usedHeight = 0;\r\n\r\n\tundistributeHeight(els); // give all elements their natural height\r\n\r\n\t// find elements that are below the recommended height (expandable).\r\n\t// important to query for heights in a single first pass (to avoid reflow oscillation).\r\n\tels.each(function(i, el) {\r\n\t\tvar minOffset = i === els.length - 1 ? minOffset2 : minOffset1;\r\n\t\tvar naturalOffset = $(el).outerHeight(true);\r\n\r\n\t\tif (naturalOffset < minOffset) {\r\n\t\t\tflexEls.push(el);\r\n\t\t\tflexOffsets.push(naturalOffset);\r\n\t\t\tflexHeights.push($(el).height());\r\n\t\t}\r\n\t\telse {\r\n\t\t\t// this element stretches past recommended height (non-expandable). mark the space as occupied.\r\n\t\t\tusedHeight += naturalOffset;\r\n\t\t}\r\n\t});\r\n\r\n\t// readjust the recommended height to only consider the height available to non-maxed-out rows.\r\n\tif (shouldRedistribute) {\r\n\t\tavailableHeight -= usedHeight;\r\n\t\tminOffset1 = Math.floor(availableHeight / flexEls.length);\r\n\t\tminOffset2 = Math.floor(availableHeight - minOffset1 * (flexEls.length - 1)); // *FLOORING NOTE*\r\n\t}\r\n\r\n\t// assign heights to all expandable elements\r\n\t$(flexEls).each(function(i, el) {\r\n\t\tvar minOffset = i === flexEls.length - 1 ? minOffset2 : minOffset1;\r\n\t\tvar naturalOffset = flexOffsets[i];\r\n\t\tvar naturalHeight = flexHeights[i];\r\n\t\tvar newHeight = minOffset - (naturalOffset - naturalHeight); // subtract the margin/padding\r\n\r\n\t\tif (naturalOffset < minOffset) { // we check this again because redistribution might have changed things\r\n\t\t\t$(el).height(newHeight);\r\n\t\t}\r\n\t});\r\n}\r\n\r\n\r\n// Undoes distrubuteHeight, restoring all els to their natural height\r\nfunction undistributeHeight(els) {\r\n\tels.height('');\r\n}\r\n\r\n\r\n// Given `els`, a jQuery set of <td> cells, find the cell with the largest natural width and set the widths of all the\r\n// cells to be that width.\r\n// PREREQUISITE: if you want a cell to take up width, it needs to have a single inner element w/ display:inline\r\nfunction matchCellWidths(els) {\r\n\tvar maxInnerWidth = 0;\r\n\r\n\tels.find('> *').each(function(i, innerEl) {\r\n\t\tvar innerWidth = $(innerEl).outerWidth();\r\n\t\tif (innerWidth > maxInnerWidth) {\r\n\t\t\tmaxInnerWidth = innerWidth;\r\n\t\t}\r\n\t});\r\n\r\n\tmaxInnerWidth++; // sometimes not accurate of width the text needs to stay on one line. insurance\r\n\r\n\tels.width(maxInnerWidth);\r\n\r\n\treturn maxInnerWidth;\r\n}\r\n\r\n\r\n// Given one element that resides inside another,\r\n// Subtracts the height of the inner element from the outer element.\r\nfunction subtractInnerElHeight(outerEl, innerEl) {\r\n\tvar both = outerEl.add(innerEl);\r\n\tvar diff;\r\n\r\n\t// effin' IE8/9/10/11 sometimes returns 0 for dimensions. this weird hack was the only thing that worked\r\n\tboth.css({\r\n\t\tposition: 'relative', // cause a reflow, which will force fresh dimension recalculation\r\n\t\tleft: -1 // ensure reflow in case the el was already relative. negative is less likely to cause new scroll\r\n\t});\r\n\tdiff = outerEl.outerHeight() - innerEl.outerHeight(); // grab the dimensions\r\n\tboth.css({ position: '', left: '' }); // undo hack\r\n\r\n\treturn diff;\r\n}\r\n\r\n\r\n/* Element Geom Utilities\r\n----------------------------------------------------------------------------------------------------------------------*/\r\n\r\nFC.getOuterRect = getOuterRect;\r\nFC.getClientRect = getClientRect;\r\nFC.getContentRect = getContentRect;\r\nFC.getScrollbarWidths = getScrollbarWidths;\r\n\r\n\r\n// borrowed from https://github.com/jquery/jquery-ui/blob/1.11.0/ui/core.js#L51\r\nfunction getScrollParent(el) {\r\n\tvar position = el.css('position'),\r\n\t\tscrollParent = el.parents().filter(function() {\r\n\t\t\tvar parent = $(this);\r\n\t\t\treturn (/(auto|scroll)/).test(\r\n\t\t\t\tparent.css('overflow') + parent.css('overflow-y') + parent.css('overflow-x')\r\n\t\t\t);\r\n\t\t}).eq(0);\r\n\r\n\treturn position === 'fixed' || !scrollParent.length ? $(el[0].ownerDocument || document) : scrollParent;\r\n}\r\n\r\n\r\n// Queries the outer bounding area of a jQuery element.\r\n// Returns a rectangle with absolute coordinates: left, right (exclusive), top, bottom (exclusive).\r\n// Origin is optional.\r\nfunction getOuterRect(el, origin) {\r\n\tvar offset = el.offset();\r\n\tvar left = offset.left - (origin ? origin.left : 0);\r\n\tvar top = offset.top - (origin ? origin.top : 0);\r\n\r\n\treturn {\r\n\t\tleft: left,\r\n\t\tright: left + el.outerWidth(),\r\n\t\ttop: top,\r\n\t\tbottom: top + el.outerHeight()\r\n\t};\r\n}\r\n\r\n\r\n// Queries the area within the margin/border/scrollbars of a jQuery element. Does not go within the padding.\r\n// Returns a rectangle with absolute coordinates: left, right (exclusive), top, bottom (exclusive).\r\n// Origin is optional.\r\n// WARNING: given element can't have borders\r\n// NOTE: should use clientLeft/clientTop, but very unreliable cross-browser.\r\nfunction getClientRect(el, origin) {\r\n\tvar offset = el.offset();\r\n\tvar scrollbarWidths = getScrollbarWidths(el);\r\n\tvar left = offset.left + getCssFloat(el, 'border-left-width') + scrollbarWidths.left - (origin ? origin.left : 0);\r\n\tvar top = offset.top + getCssFloat(el, 'border-top-width') + scrollbarWidths.top - (origin ? origin.top : 0);\r\n\r\n\treturn {\r\n\t\tleft: left,\r\n\t\tright: left + el[0].clientWidth, // clientWidth includes padding but NOT scrollbars\r\n\t\ttop: top,\r\n\t\tbottom: top + el[0].clientHeight // clientHeight includes padding but NOT scrollbars\r\n\t};\r\n}\r\n\r\n\r\n// Queries the area within the margin/border/padding of a jQuery element. Assumed not to have scrollbars.\r\n// Returns a rectangle with absolute coordinates: left, right (exclusive), top, bottom (exclusive).\r\n// Origin is optional.\r\nfunction getContentRect(el, origin) {\r\n\tvar offset = el.offset(); // just outside of border, margin not included\r\n\tvar left = offset.left + getCssFloat(el, 'border-left-width') + getCssFloat(el, 'padding-left') -\r\n\t\t(origin ? origin.left : 0);\r\n\tvar top = offset.top + getCssFloat(el, 'border-top-width') + getCssFloat(el, 'padding-top') -\r\n\t\t(origin ? origin.top : 0);\r\n\r\n\treturn {\r\n\t\tleft: left,\r\n\t\tright: left + el.width(),\r\n\t\ttop: top,\r\n\t\tbottom: top + el.height()\r\n\t};\r\n}\r\n\r\n\r\n// Returns the computed left/right/top/bottom scrollbar widths for the given jQuery element.\r\n// WARNING: given element can't have borders (which will cause offsetWidth/offsetHeight to be larger).\r\n// NOTE: should use clientLeft/clientTop, but very unreliable cross-browser.\r\nfunction getScrollbarWidths(el) {\r\n\tvar leftRightWidth = el[0].offsetWidth - el[0].clientWidth;\r\n\tvar bottomWidth = el[0].offsetHeight - el[0].clientHeight;\r\n\tvar widths;\r\n\r\n\tleftRightWidth = sanitizeScrollbarWidth(leftRightWidth);\r\n\tbottomWidth = sanitizeScrollbarWidth(bottomWidth);\r\n\r\n\twidths = { left: 0, right: 0, top: 0, bottom: bottomWidth };\r\n\r\n\tif (getIsLeftRtlScrollbars() && el.css('direction') == 'rtl') { // is the scrollbar on the left side?\r\n\t\twidths.left = leftRightWidth;\r\n\t}\r\n\telse {\r\n\t\twidths.right = leftRightWidth;\r\n\t}\r\n\r\n\treturn widths;\r\n}\r\n\r\n\r\n// The scrollbar width computations in getScrollbarWidths are sometimes flawed when it comes to\r\n// retina displays, rounding, and IE11. Massage them into a usable value.\r\nfunction sanitizeScrollbarWidth(width) {\r\n\twidth = Math.max(0, width); // no negatives\r\n\twidth = Math.round(width);\r\n\treturn width;\r\n}\r\n\r\n\r\n// Logic for determining if, when the element is right-to-left, the scrollbar appears on the left side\r\n\r\nvar _isLeftRtlScrollbars = null;\r\n\r\nfunction getIsLeftRtlScrollbars() { // responsible for caching the computation\r\n\tif (_isLeftRtlScrollbars === null) {\r\n\t\t_isLeftRtlScrollbars = computeIsLeftRtlScrollbars();\r\n\t}\r\n\treturn _isLeftRtlScrollbars;\r\n}\r\n\r\nfunction computeIsLeftRtlScrollbars() { // creates an offscreen test element, then removes it\r\n\tvar el = $('<div><div/></div>')\r\n\t\t.css({\r\n\t\t\tposition: 'absolute',\r\n\t\t\ttop: -1000,\r\n\t\t\tleft: 0,\r\n\t\t\tborder: 0,\r\n\t\t\tpadding: 0,\r\n\t\t\toverflow: 'scroll',\r\n\t\t\tdirection: 'rtl'\r\n\t\t})\r\n\t\t.appendTo('body');\r\n\tvar innerEl = el.children();\r\n\tvar res = innerEl.offset().left > el.offset().left; // is the inner div shifted to accommodate a left scrollbar?\r\n\tel.remove();\r\n\treturn res;\r\n}\r\n\r\n\r\n// Retrieves a jQuery element's computed CSS value as a floating-point number.\r\n// If the queried value is non-numeric (ex: IE can return \"medium\" for border width), will just return zero.\r\nfunction getCssFloat(el, prop) {\r\n\treturn parseFloat(el.css(prop)) || 0;\r\n}\r\n\r\n\r\n/* Mouse / Touch Utilities\r\n----------------------------------------------------------------------------------------------------------------------*/\r\n\r\nFC.preventDefault = preventDefault;\r\n\r\n\r\n// Returns a boolean whether this was a left mouse click and no ctrl key (which means right click on Mac)\r\nfunction isPrimaryMouseButton(ev) {\r\n\treturn ev.which == 1 && !ev.ctrlKey;\r\n}\r\n\r\n\r\nfunction getEvX(ev) {\r\n\tvar touches = ev.originalEvent.touches;\r\n\r\n\t// on mobile FF, pageX for touch events is present, but incorrect,\r\n\t// so, look at touch coordinates first.\r\n\tif (touches && touches.length) {\r\n\t\treturn touches[0].pageX;\r\n\t}\r\n\r\n\treturn ev.pageX;\r\n}\r\n\r\n\r\nfunction getEvY(ev) {\r\n\tvar touches = ev.originalEvent.touches;\r\n\r\n\t// on mobile FF, pageX for touch events is present, but incorrect,\r\n\t// so, look at touch coordinates first.\r\n\tif (touches && touches.length) {\r\n\t\treturn touches[0].pageY;\r\n\t}\r\n\r\n\treturn ev.pageY;\r\n}\r\n\r\n\r\nfunction getEvIsTouch(ev) {\r\n\treturn /^touch/.test(ev.type);\r\n}\r\n\r\n\r\nfunction preventSelection(el) {\r\n\tel.addClass('fc-unselectable')\r\n\t\t.on('selectstart', preventDefault);\r\n}\r\n\r\n\r\nfunction allowSelection(el) {\r\n\tel.removeClass('fc-unselectable')\r\n\t\t.off('selectstart', preventDefault);\r\n}\r\n\r\n\r\n// Stops a mouse/touch event from doing it's native browser action\r\nfunction preventDefault(ev) {\r\n\tev.preventDefault();\r\n}\r\n\r\n\r\n/* General Geometry Utils\r\n----------------------------------------------------------------------------------------------------------------------*/\r\n\r\nFC.intersectRects = intersectRects;\r\n\r\n// Returns a new rectangle that is the intersection of the two rectangles. If they don't intersect, returns false\r\nfunction intersectRects(rect1, rect2) {\r\n\tvar res = {\r\n\t\tleft: Math.max(rect1.left, rect2.left),\r\n\t\tright: Math.min(rect1.right, rect2.right),\r\n\t\ttop: Math.max(rect1.top, rect2.top),\r\n\t\tbottom: Math.min(rect1.bottom, rect2.bottom)\r\n\t};\r\n\r\n\tif (res.left < res.right && res.top < res.bottom) {\r\n\t\treturn res;\r\n\t}\r\n\treturn false;\r\n}\r\n\r\n\r\n// Returns a new point that will have been moved to reside within the given rectangle\r\nfunction constrainPoint(point, rect) {\r\n\treturn {\r\n\t\tleft: Math.min(Math.max(point.left, rect.left), rect.right),\r\n\t\ttop: Math.min(Math.max(point.top, rect.top), rect.bottom)\r\n\t};\r\n}\r\n\r\n\r\n// Returns a point that is the center of the given rectangle\r\nfunction getRectCenter(rect) {\r\n\treturn {\r\n\t\tleft: (rect.left + rect.right) / 2,\r\n\t\ttop: (rect.top + rect.bottom) / 2\r\n\t};\r\n}\r\n\r\n\r\n// Subtracts point2's coordinates from point1's coordinates, returning a delta\r\nfunction diffPoints(point1, point2) {\r\n\treturn {\r\n\t\tleft: point1.left - point2.left,\r\n\t\ttop: point1.top - point2.top\r\n\t};\r\n}\r\n\r\n\r\n/* Object Ordering by Field\r\n----------------------------------------------------------------------------------------------------------------------*/\r\n\r\nFC.parseFieldSpecs = parseFieldSpecs;\r\nFC.compareByFieldSpecs = compareByFieldSpecs;\r\nFC.compareByFieldSpec = compareByFieldSpec;\r\nFC.flexibleCompare = flexibleCompare;\r\n\r\n\r\nfunction parseFieldSpecs(input) {\r\n\tvar specs = [];\r\n\tvar tokens = [];\r\n\tvar i, token;\r\n\r\n\tif (typeof input === 'string') {\r\n\t\ttokens = input.split(/\\s*,\\s*/);\r\n\t}\r\n\telse if (typeof input === 'function') {\r\n\t\ttokens = [ input ];\r\n\t}\r\n\telse if ($.isArray(input)) {\r\n\t\ttokens = input;\r\n\t}\r\n\r\n\tfor (i = 0; i < tokens.length; i++) {\r\n\t\ttoken = tokens[i];\r\n\r\n\t\tif (typeof token === 'string') {\r\n\t\t\tspecs.push(\r\n\t\t\t\ttoken.charAt(0) == '-' ?\r\n\t\t\t\t\t{ field: token.substring(1), order: -1 } :\r\n\t\t\t\t\t{ field: token, order: 1 }\r\n\t\t\t);\r\n\t\t}\r\n\t\telse if (typeof token === 'function') {\r\n\t\t\tspecs.push({ func: token });\r\n\t\t}\r\n\t}\r\n\r\n\treturn specs;\r\n}\r\n\r\n\r\nfunction compareByFieldSpecs(obj1, obj2, fieldSpecs) {\r\n\tvar i;\r\n\tvar cmp;\r\n\r\n\tfor (i = 0; i < fieldSpecs.length; i++) {\r\n\t\tcmp = compareByFieldSpec(obj1, obj2, fieldSpecs[i]);\r\n\t\tif (cmp) {\r\n\t\t\treturn cmp;\r\n\t\t}\r\n\t}\r\n\r\n\treturn 0;\r\n}\r\n\r\n\r\nfunction compareByFieldSpec(obj1, obj2, fieldSpec) {\r\n\tif (fieldSpec.func) {\r\n\t\treturn fieldSpec.func(obj1, obj2);\r\n\t}\r\n\treturn flexibleCompare(obj1[fieldSpec.field], obj2[fieldSpec.field]) *\r\n\t\t(fieldSpec.order || 1);\r\n}\r\n\r\n\r\nfunction flexibleCompare(a, b) {\r\n\tif (!a && !b) {\r\n\t\treturn 0;\r\n\t}\r\n\tif (b == null) {\r\n\t\treturn -1;\r\n\t}\r\n\tif (a == null) {\r\n\t\treturn 1;\r\n\t}\r\n\tif ($.type(a) === 'string' || $.type(b) === 'string') {\r\n\t\treturn String(a).localeCompare(String(b));\r\n\t}\r\n\treturn a - b;\r\n}\r\n\r\n\r\n/* Date Utilities\r\n----------------------------------------------------------------------------------------------------------------------*/\r\n\r\nFC.computeGreatestUnit = computeGreatestUnit;\r\nFC.divideRangeByDuration = divideRangeByDuration;\r\nFC.divideDurationByDuration = divideDurationByDuration;\r\nFC.multiplyDuration = multiplyDuration;\r\nFC.durationHasTime = durationHasTime;\r\n\r\nvar dayIDs = [ 'sun', 'mon', 'tue', 'wed', 'thu', 'fri', 'sat' ];\r\nvar unitsDesc = [ 'year', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond' ]; // descending\r\n\r\n\r\n// Diffs the two moments into a Duration where full-days are recorded first, then the remaining time.\r\n// Moments will have their timezones normalized.\r\nfunction diffDayTime(a, b) {\r\n\treturn moment.duration({\r\n\t\tdays: a.clone().stripTime().diff(b.clone().stripTime(), 'days'),\r\n\t\tms: a.time() - b.time() // time-of-day from day start. disregards timezone\r\n\t});\r\n}\r\n\r\n\r\n// Diffs the two moments via their start-of-day (regardless of timezone). Produces whole-day durations.\r\nfunction diffDay(a, b) {\r\n\treturn moment.duration({\r\n\t\tdays: a.clone().stripTime().diff(b.clone().stripTime(), 'days')\r\n\t});\r\n}\r\n\r\n\r\n// Diffs two moments, producing a duration, made of a whole-unit-increment of the given unit. Uses rounding.\r\nfunction diffByUnit(a, b, unit) {\r\n\treturn moment.duration(\r\n\t\tMath.round(a.diff(b, unit, true)), // returnFloat=true\r\n\t\tunit\r\n\t);\r\n}\r\n\r\n\r\n// Computes the unit name of the largest whole-unit period of time.\r\n// For example, 48 hours will be \"days\" whereas 49 hours will be \"hours\".\r\n// Accepts start/end, a range object, or an original duration object.\r\nfunction computeGreatestUnit(start, end) {\r\n\tvar i, unit;\r\n\tvar val;\r\n\r\n\tfor (i = 0; i < unitsDesc.length; i++) {\r\n\t\tunit = unitsDesc[i];\r\n\t\tval = computeRangeAs(unit, start, end);\r\n\r\n\t\tif (val >= 1 && isInt(val)) {\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\r\n\treturn unit; // will be \"milliseconds\" if nothing else matches\r\n}\r\n\r\n\r\n// like computeGreatestUnit, but has special abilities to interpret the source input for clues\r\nfunction computeDurationGreatestUnit(duration, durationInput) {\r\n\tvar unit = computeGreatestUnit(duration);\r\n\r\n\t// prevent days:7 from being interpreted as a week\r\n\tif (unit === 'week' && typeof durationInput === 'object' && durationInput.days) {\r\n\t\tunit = 'day';\r\n\t}\r\n\r\n\treturn unit;\r\n}\r\n\r\n\r\n// Computes the number of units (like \"hours\") in the given range.\r\n// Range can be a {start,end} object, separate start/end args, or a Duration.\r\n// Results are based on Moment's .as() and .diff() methods, so results can depend on internal handling\r\n// of month-diffing logic (which tends to vary from version to version).\r\nfunction computeRangeAs(unit, start, end) {\r\n\r\n\tif (end != null) { // given start, end\r\n\t\treturn end.diff(start, unit, true);\r\n\t}\r\n\telse if (moment.isDuration(start)) { // given duration\r\n\t\treturn start.as(unit);\r\n\t}\r\n\telse { // given { start, end } range object\r\n\t\treturn start.end.diff(start.start, unit, true);\r\n\t}\r\n}\r\n\r\n\r\n// Intelligently divides a range (specified by a start/end params) by a duration\r\nfunction divideRangeByDuration(start, end, dur) {\r\n\tvar months;\r\n\r\n\tif (durationHasTime(dur)) {\r\n\t\treturn (end - start) / dur;\r\n\t}\r\n\tmonths = dur.asMonths();\r\n\tif (Math.abs(months) >= 1 && isInt(months)) {\r\n\t\treturn end.diff(start, 'months', true) / months;\r\n\t}\r\n\treturn end.diff(start, 'days', true) / dur.asDays();\r\n}\r\n\r\n\r\n// Intelligently divides one duration by another\r\nfunction divideDurationByDuration(dur1, dur2) {\r\n\tvar months1, months2;\r\n\r\n\tif (durationHasTime(dur1) || durationHasTime(dur2)) {\r\n\t\treturn dur1 / dur2;\r\n\t}\r\n\tmonths1 = dur1.asMonths();\r\n\tmonths2 = dur2.asMonths();\r\n\tif (\r\n\t\tMath.abs(months1) >= 1 && isInt(months1) &&\r\n\t\tMath.abs(months2) >= 1 && isInt(months2)\r\n\t) {\r\n\t\treturn months1 / months2;\r\n\t}\r\n\treturn dur1.asDays() / dur2.asDays();\r\n}\r\n\r\n\r\n// Intelligently multiplies a duration by a number\r\nfunction multiplyDuration(dur, n) {\r\n\tvar months;\r\n\r\n\tif (durationHasTime(dur)) {\r\n\t\treturn moment.duration(dur * n);\r\n\t}\r\n\tmonths = dur.asMonths();\r\n\tif (Math.abs(months) >= 1 && isInt(months)) {\r\n\t\treturn moment.duration({ months: months * n });\r\n\t}\r\n\treturn moment.duration({ days: dur.asDays() * n });\r\n}\r\n\r\n\r\n// Returns a boolean about whether the given duration has any time parts (hours/minutes/seconds/ms)\r\nfunction durationHasTime(dur) {\r\n\treturn Boolean(dur.hours() || dur.minutes() || dur.seconds() || dur.milliseconds());\r\n}\r\n\r\n\r\nfunction isNativeDate(input) {\r\n\treturn  Object.prototype.toString.call(input) === '[object Date]' || input instanceof Date;\r\n}\r\n\r\n\r\n// Returns a boolean about whether the given input is a time string, like \"06:40:00\" or \"06:00\"\r\nfunction isTimeString(str) {\r\n\treturn typeof str === 'string' &&\r\n\t\t/^\\d+\\:\\d+(?:\\:\\d+\\.?(?:\\d{3})?)?$/.test(str);\r\n}\r\n\r\n\r\n/* Logging and Debug\r\n----------------------------------------------------------------------------------------------------------------------*/\r\n\r\nFC.log = function() {\r\n\tvar console = window.console;\r\n\r\n\tif (console && console.log) {\r\n\t\treturn console.log.apply(console, arguments);\r\n\t}\r\n};\r\n\r\nFC.warn = function() {\r\n\tvar console = window.console;\r\n\r\n\tif (console && console.warn) {\r\n\t\treturn console.warn.apply(console, arguments);\r\n\t}\r\n\telse {\r\n\t\treturn FC.log.apply(FC, arguments);\r\n\t}\r\n};\r\n\r\n\r\n/* General Utilities\r\n----------------------------------------------------------------------------------------------------------------------*/\r\n\r\nvar hasOwnPropMethod = {}.hasOwnProperty;\r\n\r\n\r\n// Merges an array of objects into a single object.\r\n// The second argument allows for an array of property names who's object values will be merged together.\r\nfunction mergeProps(propObjs, complexProps) {\r\n\tvar dest = {};\r\n\tvar i, name;\r\n\tvar complexObjs;\r\n\tvar j, val;\r\n\tvar props;\r\n\r\n\tif (complexProps) {\r\n\t\tfor (i = 0; i < complexProps.length; i++) {\r\n\t\t\tname = complexProps[i];\r\n\t\t\tcomplexObjs = [];\r\n\r\n\t\t\t// collect the trailing object values, stopping when a non-object is discovered\r\n\t\t\tfor (j = propObjs.length - 1; j >= 0; j--) {\r\n\t\t\t\tval = propObjs[j][name];\r\n\r\n\t\t\t\tif (typeof val === 'object') {\r\n\t\t\t\t\tcomplexObjs.unshift(val);\r\n\t\t\t\t}\r\n\t\t\t\telse if (val !== undefined) {\r\n\t\t\t\t\tdest[name] = val; // if there were no objects, this value will be used\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// if the trailing values were objects, use the merged value\r\n\t\t\tif (complexObjs.length) {\r\n\t\t\t\tdest[name] = mergeProps(complexObjs);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// copy values into the destination, going from last to first\r\n\tfor (i = propObjs.length - 1; i >= 0; i--) {\r\n\t\tprops = propObjs[i];\r\n\r\n\t\tfor (name in props) {\r\n\t\t\tif (!(name in dest)) { // if already assigned by previous props or complex props, don't reassign\r\n\t\t\t\tdest[name] = props[name];\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn dest;\r\n}\r\n\r\n\r\nfunction copyOwnProps(src, dest) {\r\n\tfor (var name in src) {\r\n\t\tif (hasOwnProp(src, name)) {\r\n\t\t\tdest[name] = src[name];\r\n\t\t}\r\n\t}\r\n}\r\n\r\n\r\nfunction hasOwnProp(obj, name) {\r\n\treturn hasOwnPropMethod.call(obj, name);\r\n}\r\n\r\n\r\nfunction applyAll(functions, thisObj, args) {\r\n\tif ($.isFunction(functions)) {\r\n\t\tfunctions = [ functions ];\r\n\t}\r\n\tif (functions) {\r\n\t\tvar i;\r\n\t\tvar ret;\r\n\t\tfor (i=0; i<functions.length; i++) {\r\n\t\t\tret = functions[i].apply(thisObj, args) || ret;\r\n\t\t}\r\n\t\treturn ret;\r\n\t}\r\n}\r\n\r\n\r\nfunction removeMatching(array, testFunc) {\r\n\tvar removeCnt = 0;\r\n\tvar i = 0;\r\n\r\n\twhile (i < array.length) {\r\n\t\tif (testFunc(array[i])) { // truthy value means *remove*\r\n\t\t\tarray.splice(i, 1);\r\n\t\t\tremoveCnt++;\r\n\t\t}\r\n\t\telse {\r\n\t\t\ti++;\r\n\t\t}\r\n\t}\r\n\r\n\treturn removeCnt;\r\n}\r\n\r\n\r\nfunction removeExact(array, exactVal) {\r\n\tvar removeCnt = 0;\r\n\tvar i = 0;\r\n\r\n\twhile (i < array.length) {\r\n\t\tif (array[i] === exactVal) {\r\n\t\t\tarray.splice(i, 1);\r\n\t\t\tremoveCnt++;\r\n\t\t}\r\n\t\telse {\r\n\t\t\ti++;\r\n\t\t}\r\n\t}\r\n\r\n\treturn removeCnt;\r\n}\r\nFC.removeExact = removeExact;\r\n\r\n\r\nfunction isArraysEqual(a0, a1) {\r\n\tvar len = a0.length;\r\n\tvar i;\r\n\r\n\tif (len == null || len !== a1.length) { // not array? or not same length?\r\n\t\treturn false;\r\n\t}\r\n\r\n\tfor (i = 0; i < len; i++) {\r\n\t\tif (a0[i] !== a1[i]) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\r\n\treturn true;\r\n}\r\n\r\n\r\n\r\nfunction firstDefined() {\r\n\tfor (var i=0; i<arguments.length; i++) {\r\n\t\tif (arguments[i] !== undefined) {\r\n\t\t\treturn arguments[i];\r\n\t\t}\r\n\t}\r\n}\r\n\r\n\r\nfunction htmlEscape(s) {\r\n\treturn (s + '').replace(/&/g, '&amp;')\r\n\t\t.replace(/</g, '&lt;')\r\n\t\t.replace(/>/g, '&gt;')\r\n\t\t.replace(/'/g, '&#039;')\r\n\t\t.replace(/\"/g, '&quot;')\r\n\t\t.replace(/\\n/g, '<br />');\r\n}\r\n\r\n\r\nfunction stripHtmlEntities(text) {\r\n\treturn text.replace(/&.*?;/g, '');\r\n}\r\n\r\n\r\n// Given a hash of CSS properties, returns a string of CSS.\r\n// Uses property names as-is (no camel-case conversion). Will not make statements for null/undefined values.\r\nfunction cssToStr(cssProps) {\r\n\tvar statements = [];\r\n\r\n\t$.each(cssProps, function(name, val) {\r\n\t\tif (val != null) {\r\n\t\t\tstatements.push(name + ':' + val);\r\n\t\t}\r\n\t});\r\n\r\n\treturn statements.join(';');\r\n}\r\n\r\n\r\n// Given an object hash of HTML attribute names to values,\r\n// generates a string that can be injected between < > in HTML\r\nfunction attrsToStr(attrs) {\r\n\tvar parts = [];\r\n\r\n\t$.each(attrs, function(name, val) {\r\n\t\tif (val != null) {\r\n\t\t\tparts.push(name + '=\"' + htmlEscape(val) + '\"');\r\n\t\t}\r\n\t});\r\n\r\n\treturn parts.join(' ');\r\n}\r\n\r\n\r\nfunction capitaliseFirstLetter(str) {\r\n\treturn str.charAt(0).toUpperCase() + str.slice(1);\r\n}\r\n\r\n\r\nfunction compareNumbers(a, b) { // for .sort()\r\n\treturn a - b;\r\n}\r\n\r\n\r\nfunction isInt(n) {\r\n\treturn n % 1 === 0;\r\n}\r\n\r\n\r\n// Returns a method bound to the given object context.\r\n// Just like one of the jQuery.proxy signatures, but without the undesired behavior of treating the same method with\r\n// different contexts as identical when binding/unbinding events.\r\nfunction proxy(obj, methodName) {\r\n\tvar method = obj[methodName];\r\n\r\n\treturn function() {\r\n\t\treturn method.apply(obj, arguments);\r\n\t};\r\n}\r\n\r\n\r\n// Returns a function, that, as long as it continues to be invoked, will not\r\n// be triggered. The function will be called after it stops being called for\r\n// N milliseconds. If `immediate` is passed, trigger the function on the\r\n// leading edge, instead of the trailing.\r\n// https://github.com/jashkenas/underscore/blob/1.6.0/underscore.js#L714\r\nfunction debounce(func, wait, immediate) {\r\n\tvar timeout, args, context, timestamp, result;\r\n\r\n\tvar later = function() {\r\n\t\tvar last = +new Date() - timestamp;\r\n\t\tif (last < wait) {\r\n\t\t\ttimeout = setTimeout(later, wait - last);\r\n\t\t}\r\n\t\telse {\r\n\t\t\ttimeout = null;\r\n\t\t\tif (!immediate) {\r\n\t\t\t\tresult = func.apply(context, args);\r\n\t\t\t\tcontext = args = null;\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\treturn function() {\r\n\t\tcontext = this;\r\n\t\targs = arguments;\r\n\t\ttimestamp = +new Date();\r\n\t\tvar callNow = immediate && !timeout;\r\n\t\tif (!timeout) {\r\n\t\t\ttimeout = setTimeout(later, wait);\r\n\t\t}\r\n\t\tif (callNow) {\r\n\t\t\tresult = func.apply(context, args);\r\n\t\t\tcontext = args = null;\r\n\t\t}\r\n\t\treturn result;\r\n\t};\r\n}\r\n\r\n;;\r\n\r\n/*\r\nGENERAL NOTE on moments throughout the *entire rest* of the codebase:\r\nAll moments are assumed to be ambiguously-zoned unless otherwise noted,\r\nwith the NOTABLE EXCEOPTION of start/end dates that live on *Event Objects*.\r\nAmbiguously-TIMED moments are assumed to be ambiguously-zoned by nature.\r\n*/\r\n\r\nvar ambigDateOfMonthRegex = /^\\s*\\d{4}-\\d\\d$/;\r\nvar ambigTimeOrZoneRegex =\r\n\t/^\\s*\\d{4}-(?:(\\d\\d-\\d\\d)|(W\\d\\d$)|(W\\d\\d-\\d)|(\\d\\d\\d))((T| )(\\d\\d(:\\d\\d(:\\d\\d(\\.\\d+)?)?)?)?)?$/;\r\nvar newMomentProto = moment.fn; // where we will attach our new methods\r\nvar oldMomentProto = $.extend({}, newMomentProto); // copy of original moment methods\r\n\r\n// tell momentjs to transfer these properties upon clone\r\nvar momentProperties = moment.momentProperties;\r\nmomentProperties.push('_fullCalendar');\r\nmomentProperties.push('_ambigTime');\r\nmomentProperties.push('_ambigZone');\r\n\r\n\r\n// Creating\r\n// -------------------------------------------------------------------------------------------------\r\n\r\n// Creates a new moment, similar to the vanilla moment(...) constructor, but with\r\n// extra features (ambiguous time, enhanced formatting). When given an existing moment,\r\n// it will function as a clone (and retain the zone of the moment). Anything else will\r\n// result in a moment in the local zone.\r\nFC.moment = function() {\r\n\treturn makeMoment(arguments);\r\n};\r\n\r\n// Sames as FC.moment, but forces the resulting moment to be in the UTC timezone.\r\nFC.moment.utc = function() {\r\n\tvar mom = makeMoment(arguments, true);\r\n\r\n\t// Force it into UTC because makeMoment doesn't guarantee it\r\n\t// (if given a pre-existing moment for example)\r\n\tif (mom.hasTime()) { // don't give ambiguously-timed moments a UTC zone\r\n\t\tmom.utc();\r\n\t}\r\n\r\n\treturn mom;\r\n};\r\n\r\n// Same as FC.moment, but when given an ISO8601 string, the timezone offset is preserved.\r\n// ISO8601 strings with no timezone offset will become ambiguously zoned.\r\nFC.moment.parseZone = function() {\r\n\treturn makeMoment(arguments, true, true);\r\n};\r\n\r\n// Builds an enhanced moment from args. When given an existing moment, it clones. When given a\r\n// native Date, or called with no arguments (the current time), the resulting moment will be local.\r\n// Anything else needs to be \"parsed\" (a string or an array), and will be affected by:\r\n//    parseAsUTC - if there is no zone information, should we parse the input in UTC?\r\n//    parseZone - if there is zone information, should we force the zone of the moment?\r\nfunction makeMoment(args, parseAsUTC, parseZone) {\r\n\tvar input = args[0];\r\n\tvar isSingleString = args.length == 1 && typeof input === 'string';\r\n\tvar isAmbigTime;\r\n\tvar isAmbigZone;\r\n\tvar ambigMatch;\r\n\tvar mom;\r\n\r\n\tif (moment.isMoment(input) || isNativeDate(input) || input === undefined) {\r\n\t\tmom = moment.apply(null, args);\r\n\t}\r\n\telse { // \"parsing\" is required\r\n\t\tisAmbigTime = false;\r\n\t\tisAmbigZone = false;\r\n\r\n\t\tif (isSingleString) {\r\n\t\t\tif (ambigDateOfMonthRegex.test(input)) {\r\n\t\t\t\t// accept strings like '2014-05', but convert to the first of the month\r\n\t\t\t\tinput += '-01';\r\n\t\t\t\targs = [ input ]; // for when we pass it on to moment's constructor\r\n\t\t\t\tisAmbigTime = true;\r\n\t\t\t\tisAmbigZone = true;\r\n\t\t\t}\r\n\t\t\telse if ((ambigMatch = ambigTimeOrZoneRegex.exec(input))) {\r\n\t\t\t\tisAmbigTime = !ambigMatch[5]; // no time part?\r\n\t\t\t\tisAmbigZone = true;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if ($.isArray(input)) {\r\n\t\t\t// arrays have no timezone information, so assume ambiguous zone\r\n\t\t\tisAmbigZone = true;\r\n\t\t}\r\n\t\t// otherwise, probably a string with a format\r\n\r\n\t\tif (parseAsUTC || isAmbigTime) {\r\n\t\t\tmom = moment.utc.apply(moment, args);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tmom = moment.apply(null, args);\r\n\t\t}\r\n\r\n\t\tif (isAmbigTime) {\r\n\t\t\tmom._ambigTime = true;\r\n\t\t\tmom._ambigZone = true; // ambiguous time always means ambiguous zone\r\n\t\t}\r\n\t\telse if (parseZone) { // let's record the inputted zone somehow\r\n\t\t\tif (isAmbigZone) {\r\n\t\t\t\tmom._ambigZone = true;\r\n\t\t\t}\r\n\t\t\telse if (isSingleString) {\r\n\t\t\t\tmom.utcOffset(input); // if not a valid zone, will assign UTC\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tmom._fullCalendar = true; // flag for extended functionality\r\n\r\n\treturn mom;\r\n}\r\n\r\n\r\n// Week Number\r\n// -------------------------------------------------------------------------------------------------\r\n\r\n\r\n// Returns the week number, considering the locale's custom week number calcuation\r\n// `weeks` is an alias for `week`\r\nnewMomentProto.week = newMomentProto.weeks = function(input) {\r\n\tvar weekCalc = this._locale._fullCalendar_weekCalc;\r\n\r\n\tif (input == null && typeof weekCalc === 'function') { // custom function only works for getter\r\n\t\treturn weekCalc(this);\r\n\t}\r\n\telse if (weekCalc === 'ISO') {\r\n\t\treturn oldMomentProto.isoWeek.apply(this, arguments); // ISO getter/setter\r\n\t}\r\n\r\n\treturn oldMomentProto.week.apply(this, arguments); // local getter/setter\r\n};\r\n\r\n\r\n// Time-of-day\r\n// -------------------------------------------------------------------------------------------------\r\n\r\n// GETTER\r\n// Returns a Duration with the hours/minutes/seconds/ms values of the moment.\r\n// If the moment has an ambiguous time, a duration of 00:00 will be returned.\r\n//\r\n// SETTER\r\n// You can supply a Duration, a Moment, or a Duration-like argument.\r\n// When setting the time, and the moment has an ambiguous time, it then becomes unambiguous.\r\nnewMomentProto.time = function(time) {\r\n\r\n\t// Fallback to the original method (if there is one) if this moment wasn't created via FullCalendar.\r\n\t// `time` is a generic enough method name where this precaution is necessary to avoid collisions w/ other plugins.\r\n\tif (!this._fullCalendar) {\r\n\t\treturn oldMomentProto.time.apply(this, arguments);\r\n\t}\r\n\r\n\tif (time == null) { // getter\r\n\t\treturn moment.duration({\r\n\t\t\thours: this.hours(),\r\n\t\t\tminutes: this.minutes(),\r\n\t\t\tseconds: this.seconds(),\r\n\t\t\tmilliseconds: this.milliseconds()\r\n\t\t});\r\n\t}\r\n\telse { // setter\r\n\r\n\t\tthis._ambigTime = false; // mark that the moment now has a time\r\n\r\n\t\tif (!moment.isDuration(time) && !moment.isMoment(time)) {\r\n\t\t\ttime = moment.duration(time);\r\n\t\t}\r\n\r\n\t\t// The day value should cause overflow (so 24 hours becomes 00:00:00 of next day).\r\n\t\t// Only for Duration times, not Moment times.\r\n\t\tvar dayHours = 0;\r\n\t\tif (moment.isDuration(time)) {\r\n\t\t\tdayHours = Math.floor(time.asDays()) * 24;\r\n\t\t}\r\n\r\n\t\t// We need to set the individual fields.\r\n\t\t// Can't use startOf('day') then add duration. In case of DST at start of day.\r\n\t\treturn this.hours(dayHours + time.hours())\r\n\t\t\t.minutes(time.minutes())\r\n\t\t\t.seconds(time.seconds())\r\n\t\t\t.milliseconds(time.milliseconds());\r\n\t}\r\n};\r\n\r\n// Converts the moment to UTC, stripping out its time-of-day and timezone offset,\r\n// but preserving its YMD. A moment with a stripped time will display no time\r\n// nor timezone offset when .format() is called.\r\nnewMomentProto.stripTime = function() {\r\n\r\n\tif (!this._ambigTime) {\r\n\r\n\t\tthis.utc(true); // keepLocalTime=true (for keeping *date* value)\r\n\r\n\t\t// set time to zero\r\n\t\tthis.set({\r\n\t\t\thours: 0,\r\n\t\t\tminutes: 0,\r\n\t\t\tseconds: 0,\r\n\t\t\tms: 0\r\n\t\t});\r\n\r\n\t\t// Mark the time as ambiguous. This needs to happen after the .utc() call, which might call .utcOffset(),\r\n\t\t// which clears all ambig flags.\r\n\t\tthis._ambigTime = true;\r\n\t\tthis._ambigZone = true; // if ambiguous time, also ambiguous timezone offset\r\n\t}\r\n\r\n\treturn this; // for chaining\r\n};\r\n\r\n// Returns if the moment has a non-ambiguous time (boolean)\r\nnewMomentProto.hasTime = function() {\r\n\treturn !this._ambigTime;\r\n};\r\n\r\n\r\n// Timezone\r\n// -------------------------------------------------------------------------------------------------\r\n\r\n// Converts the moment to UTC, stripping out its timezone offset, but preserving its\r\n// YMD and time-of-day. A moment with a stripped timezone offset will display no\r\n// timezone offset when .format() is called.\r\nnewMomentProto.stripZone = function() {\r\n\tvar wasAmbigTime;\r\n\r\n\tif (!this._ambigZone) {\r\n\r\n\t\twasAmbigTime = this._ambigTime;\r\n\r\n\t\tthis.utc(true); // keepLocalTime=true (for keeping date and time values)\r\n\r\n\t\t// the above call to .utc()/.utcOffset() unfortunately might clear the ambig flags, so restore\r\n\t\tthis._ambigTime = wasAmbigTime || false;\r\n\r\n\t\t// Mark the zone as ambiguous. This needs to happen after the .utc() call, which might call .utcOffset(),\r\n\t\t// which clears the ambig flags.\r\n\t\tthis._ambigZone = true;\r\n\t}\r\n\r\n\treturn this; // for chaining\r\n};\r\n\r\n// Returns of the moment has a non-ambiguous timezone offset (boolean)\r\nnewMomentProto.hasZone = function() {\r\n\treturn !this._ambigZone;\r\n};\r\n\r\n\r\n// implicitly marks a zone\r\nnewMomentProto.local = function(keepLocalTime) {\r\n\r\n\t// for when converting from ambiguously-zoned to local,\r\n\t// keep the time values when converting from UTC -> local\r\n\toldMomentProto.local.call(this, this._ambigZone || keepLocalTime);\r\n\r\n\t// ensure non-ambiguous\r\n\t// this probably already happened via local() -> utcOffset(), but don't rely on Moment's internals\r\n\tthis._ambigTime = false;\r\n\tthis._ambigZone = false;\r\n\r\n\treturn this; // for chaining\r\n};\r\n\r\n\r\n// implicitly marks a zone\r\nnewMomentProto.utc = function(keepLocalTime) {\r\n\r\n\toldMomentProto.utc.call(this, keepLocalTime);\r\n\r\n\t// ensure non-ambiguous\r\n\t// this probably already happened via utc() -> utcOffset(), but don't rely on Moment's internals\r\n\tthis._ambigTime = false;\r\n\tthis._ambigZone = false;\r\n\r\n\treturn this;\r\n};\r\n\r\n\r\n// implicitly marks a zone (will probably get called upon .utc() and .local())\r\nnewMomentProto.utcOffset = function(tzo) {\r\n\r\n\tif (tzo != null) { // setter\r\n\t\t// these assignments needs to happen before the original zone method is called.\r\n\t\t// I forget why, something to do with a browser crash.\r\n\t\tthis._ambigTime = false;\r\n\t\tthis._ambigZone = false;\r\n\t}\r\n\r\n\treturn oldMomentProto.utcOffset.apply(this, arguments);\r\n};\r\n\r\n\r\n// Formatting\r\n// -------------------------------------------------------------------------------------------------\r\n\r\nnewMomentProto.format = function() {\r\n\r\n\tif (this._fullCalendar && arguments[0]) { // an enhanced moment? and a format string provided?\r\n\t\treturn formatDate(this, arguments[0]); // our extended formatting\r\n\t}\r\n\tif (this._ambigTime) {\r\n\t\treturn oldMomentFormat(englishMoment(this), 'YYYY-MM-DD');\r\n\t}\r\n\tif (this._ambigZone) {\r\n\t\treturn oldMomentFormat(englishMoment(this), 'YYYY-MM-DD[T]HH:mm:ss');\r\n\t}\r\n\tif (this._fullCalendar) { // enhanced non-ambig moment?\r\n\t\t// moment.format() doesn't ensure english, but we want to.\r\n\t\treturn oldMomentFormat(englishMoment(this));\r\n\t}\r\n\r\n\treturn oldMomentProto.format.apply(this, arguments);\r\n};\r\n\r\nnewMomentProto.toISOString = function() {\r\n\r\n\tif (this._ambigTime) {\r\n\t\treturn oldMomentFormat(englishMoment(this), 'YYYY-MM-DD');\r\n\t}\r\n\tif (this._ambigZone) {\r\n\t\treturn oldMomentFormat(englishMoment(this), 'YYYY-MM-DD[T]HH:mm:ss');\r\n\t}\r\n\tif (this._fullCalendar) { // enhanced non-ambig moment?\r\n\t\t// depending on browser, moment might not output english. ensure english.\r\n\t\t// https://github.com/moment/moment/blob/2.18.1/src/lib/moment/format.js#L22\r\n\t\treturn oldMomentProto.toISOString.apply(englishMoment(this), arguments);\r\n\t}\r\n\r\n\treturn oldMomentProto.toISOString.apply(this, arguments);\r\n};\r\n\r\nfunction englishMoment(mom) {\r\n\tif (mom.locale() !== 'en') {\r\n\t\treturn mom.clone().locale('en');\r\n\t}\r\n\treturn mom;\r\n}\r\n\r\n;;\r\n(function() {\r\n\r\n// exports\r\nFC.formatDate = formatDate;\r\nFC.formatRange = formatRange;\r\nFC.oldMomentFormat = oldMomentFormat;\r\nFC.queryMostGranularFormatUnit = queryMostGranularFormatUnit;\r\n\r\n\r\n// Config\r\n// ---------------------------------------------------------------------------------------------------------------------\r\n\r\n/*\r\nInserted between chunks in the fake (\"intermediate\") formatting string.\r\nImportant that it passes as whitespace (\\s) because moment often identifies non-standalone months\r\nvia a regexp with an \\s.\r\n*/\r\nvar PART_SEPARATOR = '\\u000b'; // vertical tab\r\n\r\n/*\r\nInserted as the first character of a literal-text chunk to indicate that the literal text is not actually literal text,\r\nbut rather, a \"special\" token that has custom rendering (see specialTokens map).\r\n*/\r\nvar SPECIAL_TOKEN_MARKER = '\\u001f'; // information separator 1\r\n\r\n/*\r\nInserted at the beginning and end of a span of text that must have non-zero numeric characters.\r\nHandling of these markers is done in a post-processing step at the very end of text rendering.\r\n*/\r\nvar MAYBE_MARKER = '\\u001e'; // information separator 2\r\nvar MAYBE_REGEXP = new RegExp(MAYBE_MARKER + '([^' + MAYBE_MARKER + ']*)' + MAYBE_MARKER, 'g'); // must be global\r\n\r\n/*\r\nAddition formatting tokens we want recognized\r\n*/\r\nvar specialTokens = {\r\n\tt: function(date) { // \"a\" or \"p\"\r\n\t\treturn oldMomentFormat(date, 'a').charAt(0);\r\n\t},\r\n\tT: function(date) { // \"A\" or \"P\"\r\n\t\treturn oldMomentFormat(date, 'A').charAt(0);\r\n\t}\r\n};\r\n\r\n/*\r\nThe first characters of formatting tokens for units that are 1 day or larger.\r\n`value` is for ranking relative size (lower means bigger).\r\n`unit` is a normalized unit, used for comparing moments.\r\n*/\r\nvar largeTokenMap = {\r\n\tY: { value: 1, unit: 'year' },\r\n\tM: { value: 2, unit: 'month' },\r\n\tW: { value: 3, unit: 'week' }, // ISO week\r\n\tw: { value: 3, unit: 'week' }, // local week\r\n\tD: { value: 4, unit: 'day' }, // day of month\r\n\td: { value: 4, unit: 'day' } // day of week\r\n};\r\n\r\n\r\n// Single Date Formatting\r\n// ---------------------------------------------------------------------------------------------------------------------\r\n\r\n/*\r\nFormats `date` with a Moment formatting string, but allow our non-zero areas and special token\r\n*/\r\nfunction formatDate(date, formatStr) {\r\n\treturn renderFakeFormatString(\r\n\t\tgetParsedFormatString(formatStr).fakeFormatString,\r\n\t\tdate\r\n\t);\r\n}\r\n\r\n/*\r\nCall this if you want Moment's original format method to be used\r\n*/\r\nfunction oldMomentFormat(mom, formatStr) {\r\n\treturn oldMomentProto.format.call(mom, formatStr); // oldMomentProto defined in moment-ext.js\r\n}\r\n\r\n\r\n// Date Range Formatting\r\n// -------------------------------------------------------------------------------------------------\r\n// TODO: make it work with timezone offset\r\n\r\n/*\r\nUsing a formatting string meant for a single date, generate a range string, like\r\n\"Sep 2 - 9 2013\", that intelligently inserts a separator where the dates differ.\r\nIf the dates are the same as far as the format string is concerned, just return a single\r\nrendering of one date, without any separator.\r\n*/\r\nfunction formatRange(date1, date2, formatStr, separator, isRTL) {\r\n\tvar localeData;\r\n\r\n\tdate1 = FC.moment.parseZone(date1);\r\n\tdate2 = FC.moment.parseZone(date2);\r\n\r\n\tlocaleData = date1.localeData();\r\n\r\n\t// Expand localized format strings, like \"LL\" -> \"MMMM D YYYY\".\r\n\t// BTW, this is not important for `formatDate` because it is impossible to put custom tokens\r\n\t// or non-zero areas in Moment's localized format strings.\r\n\tformatStr = localeData.longDateFormat(formatStr) || formatStr;\r\n\r\n\treturn renderParsedFormat(\r\n\t\tgetParsedFormatString(formatStr),\r\n\t\tdate1,\r\n\t\tdate2,\r\n\t\tseparator || ' - ',\r\n\t\tisRTL\r\n\t);\r\n}\r\n\r\n/*\r\nRenders a range with an already-parsed format string.\r\n*/\r\nfunction renderParsedFormat(parsedFormat, date1, date2, separator, isRTL) {\r\n\tvar sameUnits = parsedFormat.sameUnits;\r\n\tvar unzonedDate1 = date1.clone().stripZone(); // for same-unit comparisons\r\n\tvar unzonedDate2 = date2.clone().stripZone(); // \"\r\n\r\n\tvar renderedParts1 = renderFakeFormatStringParts(parsedFormat.fakeFormatString, date1);\r\n\tvar renderedParts2 = renderFakeFormatStringParts(parsedFormat.fakeFormatString, date2);\r\n\r\n\tvar leftI;\r\n\tvar leftStr = '';\r\n\tvar rightI;\r\n\tvar rightStr = '';\r\n\tvar middleI;\r\n\tvar middleStr1 = '';\r\n\tvar middleStr2 = '';\r\n\tvar middleStr = '';\r\n\r\n\t// Start at the leftmost side of the formatting string and continue until you hit a token\r\n\t// that is not the same between dates.\r\n\tfor (\r\n\t\tleftI = 0;\r\n\t\tleftI < sameUnits.length && (!sameUnits[leftI] || unzonedDate1.isSame(unzonedDate2, sameUnits[leftI]));\r\n\t\tleftI++\r\n\t) {\r\n\t\tleftStr += renderedParts1[leftI];\r\n\t}\r\n\r\n\t// Similarly, start at the rightmost side of the formatting string and move left\r\n\tfor (\r\n\t\trightI = sameUnits.length - 1;\r\n\t\trightI > leftI && (!sameUnits[rightI] || unzonedDate1.isSame(unzonedDate2, sameUnits[rightI]));\r\n\t\trightI--\r\n\t) {\r\n\t\t// If current chunk is on the boundary of unique date-content, and is a special-case\r\n\t\t// date-formatting postfix character, then don't consume it. Consider it unique date-content.\r\n\t\t// TODO: make configurable\r\n\t\tif (rightI - 1 === leftI && renderedParts1[rightI] === '.') {\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\trightStr = renderedParts1[rightI] + rightStr;\r\n\t}\r\n\r\n\t// The area in the middle is different for both of the dates.\r\n\t// Collect them distinctly so we can jam them together later.\r\n\tfor (middleI = leftI; middleI <= rightI; middleI++) {\r\n\t\tmiddleStr1 += renderedParts1[middleI];\r\n\t\tmiddleStr2 += renderedParts2[middleI];\r\n\t}\r\n\r\n\tif (middleStr1 || middleStr2) {\r\n\t\tif (isRTL) {\r\n\t\t\tmiddleStr = middleStr2 + separator + middleStr1;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tmiddleStr = middleStr1 + separator + middleStr2;\r\n\t\t}\r\n\t}\r\n\r\n\treturn processMaybeMarkers(\r\n\t\tleftStr + middleStr + rightStr\r\n\t);\r\n}\r\n\r\n\r\n// Format String Parsing\r\n// ---------------------------------------------------------------------------------------------------------------------\r\n\r\nvar parsedFormatStrCache = {};\r\n\r\n/*\r\nReturns a parsed format string, leveraging a cache.\r\n*/\r\nfunction getParsedFormatString(formatStr) {\r\n\treturn parsedFormatStrCache[formatStr] ||\r\n\t\t(parsedFormatStrCache[formatStr] = parseFormatString(formatStr));\r\n}\r\n\r\n/*\r\nParses a format string into the following:\r\n- fakeFormatString: a momentJS formatting string, littered with special control characters that get post-processed.\r\n- sameUnits: for every part in fakeFormatString, if the part is a token, the value will be a unit string (like \"day\"),\r\n  that indicates how similar a range's start & end must be in order to share the same formatted text.\r\n  If not a token, then the value is null.\r\n  Always a flat array (not nested liked \"chunks\").\r\n*/\r\nfunction parseFormatString(formatStr) {\r\n\tvar chunks = chunkFormatString(formatStr);\r\n\t\r\n\treturn {\r\n\t\tfakeFormatString: buildFakeFormatString(chunks),\r\n\t\tsameUnits: buildSameUnits(chunks)\r\n\t};\r\n}\r\n\r\n/*\r\nBreak the formatting string into an array of chunks.\r\nA 'maybe' chunk will have nested chunks.\r\n*/\r\nfunction chunkFormatString(formatStr) {\r\n\tvar chunks = [];\r\n\tvar match;\r\n\r\n\t// TODO: more descrimination\r\n\t// \\4 is a backreference to the first character of a multi-character set.\r\n\tvar chunker = /\\[([^\\]]*)\\]|\\(([^\\)]*)\\)|(LTS|LT|(\\w)\\4*o?)|([^\\w\\[\\(]+)/g;\r\n\r\n\twhile ((match = chunker.exec(formatStr))) {\r\n\t\tif (match[1]) { // a literal string inside [ ... ]\r\n\t\t\tchunks.push.apply(chunks, // append\r\n\t\t\t\tsplitStringLiteral(match[1])\r\n\t\t\t);\r\n\t\t}\r\n\t\telse if (match[2]) { // non-zero formatting inside ( ... )\r\n\t\t\tchunks.push({ maybe: chunkFormatString(match[2]) });\r\n\t\t}\r\n\t\telse if (match[3]) { // a formatting token\r\n\t\t\tchunks.push({ token: match[3] });\r\n\t\t}\r\n\t\telse if (match[5]) { // an unenclosed literal string\r\n\t\t\tchunks.push.apply(chunks, // append\r\n\t\t\t\tsplitStringLiteral(match[5])\r\n\t\t\t);\r\n\t\t}\r\n\t}\r\n\r\n\treturn chunks;\r\n}\r\n\r\n/*\r\nPotentially splits a literal-text string into multiple parts. For special cases.\r\n*/\r\nfunction splitStringLiteral(s) {\r\n\tif (s === '. ') {\r\n\t\treturn [ '.', ' ' ]; // for locales with periods bound to the end of each year/month/date\r\n\t}\r\n\telse {\r\n\t\treturn [ s ];\r\n\t}\r\n}\r\n\r\n/*\r\nGiven chunks parsed from a real format string, generate a fake (aka \"intermediate\") format string with special control\r\ncharacters that will eventually be given to moment for formatting, and then post-processed.\r\n*/\r\nfunction buildFakeFormatString(chunks) {\r\n\tvar parts = [];\r\n\tvar i, chunk;\r\n\r\n\tfor (i = 0; i < chunks.length; i++) {\r\n\t\tchunk = chunks[i];\r\n\r\n\t\tif (typeof chunk === 'string') {\r\n\t\t\tparts.push('[' + chunk + ']');\r\n\t\t}\r\n\t\telse if (chunk.token) {\r\n\t\t\tif (chunk.token in specialTokens) {\r\n\t\t\t\tparts.push(\r\n\t\t\t\t\tSPECIAL_TOKEN_MARKER + // useful during post-processing\r\n\t\t\t\t\t'[' + chunk.token + ']' // preserve as literal text\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tparts.push(chunk.token); // unprotected text implies a format string\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if (chunk.maybe) {\r\n\t\t\tparts.push(\r\n\t\t\t\tMAYBE_MARKER + // useful during post-processing\r\n\t\t\t\tbuildFakeFormatString(chunk.maybe) +\r\n\t\t\t\tMAYBE_MARKER\r\n\t\t\t);\r\n\t\t}\r\n\t}\r\n\r\n\treturn parts.join(PART_SEPARATOR);\r\n}\r\n\r\n/*\r\nGiven parsed chunks from a real formatting string, generates an array of unit strings (like \"day\") that indicate\r\nin which regard two dates must be similar in order to share range formatting text.\r\nThe `chunks` can be nested (because of \"maybe\" chunks), however, the returned array will be flat.\r\n*/\r\nfunction buildSameUnits(chunks) {\r\n\tvar units = [];\r\n\tvar i, chunk;\r\n\tvar tokenInfo;\r\n\r\n\tfor (i = 0; i < chunks.length; i++) {\r\n\t\tchunk = chunks[i];\r\n\r\n\t\tif (chunk.token) {\r\n\t\t\ttokenInfo = largeTokenMap[chunk.token.charAt(0)];\r\n\t\t\tunits.push(tokenInfo ? tokenInfo.unit : 'second'); // default to a very strict same-second\r\n\t\t}\r\n\t\telse if (chunk.maybe) {\r\n\t\t\tunits.push.apply(units, // append\r\n\t\t\t\tbuildSameUnits(chunk.maybe)\r\n\t\t\t);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tunits.push(null);\r\n\t\t}\r\n\t}\r\n\r\n\treturn units;\r\n}\r\n\r\n\r\n// Rendering to text\r\n// ---------------------------------------------------------------------------------------------------------------------\r\n\r\n/*\r\nFormats a date with a fake format string, post-processes the control characters, then returns.\r\n*/\r\nfunction renderFakeFormatString(fakeFormatString, date) {\r\n\treturn processMaybeMarkers(\r\n\t\trenderFakeFormatStringParts(fakeFormatString, date).join('')\r\n\t);\r\n}\r\n\r\n/*\r\nFormats a date into parts that will have been post-processed, EXCEPT for the \"maybe\" markers.\r\n*/\r\nfunction renderFakeFormatStringParts(fakeFormatString, date) {\r\n\tvar parts = [];\r\n\tvar fakeRender = oldMomentFormat(date, fakeFormatString);\r\n\tvar fakeParts = fakeRender.split(PART_SEPARATOR);\r\n\tvar i, fakePart;\r\n\r\n\tfor (i = 0; i < fakeParts.length; i++) {\r\n\t\tfakePart = fakeParts[i];\r\n\r\n\t\tif (fakePart.charAt(0) === SPECIAL_TOKEN_MARKER) {\r\n\t\t\tparts.push(\r\n\t\t\t\t// the literal string IS the token's name.\r\n\t\t\t\t// call special token's registered function.\r\n\t\t\t\tspecialTokens[fakePart.substring(1)](date)\r\n\t\t\t);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tparts.push(fakePart);\r\n\t\t}\r\n\t}\r\n\r\n\treturn parts;\r\n}\r\n\r\n/*\r\nAccepts an almost-finally-formatted string and processes the \"maybe\" control characters, returning a new string.\r\n*/\r\nfunction processMaybeMarkers(s) {\r\n\treturn s.replace(MAYBE_REGEXP, function(m0, m1) { // regex assumed to have 'g' flag\r\n\t\tif (m1.match(/[1-9]/)) { // any non-zero numeric characters?\r\n\t\t\treturn m1;\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn '';\r\n\t\t}\r\n\t});\r\n}\r\n\r\n\r\n// Misc Utils\r\n// -------------------------------------------------------------------------------------------------\r\n\r\n/*\r\nReturns a unit string, either 'year', 'month', 'day', or null for the most granular formatting token in the string.\r\n*/\r\nfunction queryMostGranularFormatUnit(formatStr) {\r\n\tvar chunks = chunkFormatString(formatStr);\r\n\tvar i, chunk;\r\n\tvar candidate;\r\n\tvar best;\r\n\r\n\tfor (i = 0; i < chunks.length; i++) {\r\n\t\tchunk = chunks[i];\r\n\r\n\t\tif (chunk.token) {\r\n\t\t\tcandidate = largeTokenMap[chunk.token.charAt(0)];\r\n\t\t\tif (candidate) {\r\n\t\t\t\tif (!best || candidate.value > best.value) {\r\n\t\t\t\t\tbest = candidate;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tif (best) {\r\n\t\treturn best.unit;\r\n\t}\r\n\r\n\treturn null;\r\n};\r\n\r\n})();\r\n\r\n// quick local references\r\nvar formatDate = FC.formatDate;\r\nvar formatRange = FC.formatRange;\r\nvar oldMomentFormat = FC.oldMomentFormat;\r\n\r\n;;\r\n\r\nFC.Class = Class; // export\r\n\r\n// Class that all other classes will inherit from\r\nfunction Class() { }\r\n\r\n\r\n// Called on a class to create a subclass.\r\n// Last argument contains instance methods. Any argument before the last are considered mixins.\r\nClass.extend = function() {\r\n\tvar members = {};\r\n\tvar i;\r\n\r\n\tfor (i = 0; i < arguments.length; i++) {\r\n\t\tcopyOwnProps(arguments[i], members);\r\n\t}\r\n\r\n\treturn extendClass(this, members);\r\n};\r\n\r\n\r\n// Adds new member variables/methods to the class's prototype.\r\n// Can be called with another class, or a plain object hash containing new members.\r\nClass.mixin = function(members) {\r\n\tcopyOwnProps(members, this.prototype);\r\n};\r\n\r\n\r\nfunction extendClass(superClass, members) {\r\n\tvar subClass;\r\n\r\n\t// ensure a constructor for the subclass, forwarding all arguments to the super-constructor if it doesn't exist\r\n\tif (hasOwnProp(members, 'constructor')) {\r\n\t\tsubClass = members.constructor;\r\n\t}\r\n\tif (typeof subClass !== 'function') {\r\n\t\tsubClass = members.constructor = function() {\r\n\t\t\tsuperClass.apply(this, arguments);\r\n\t\t};\r\n\t}\r\n\r\n\t// build the base prototype for the subclass, which is an new object chained to the superclass's prototype\r\n\tsubClass.prototype = Object.create(superClass.prototype);\r\n\r\n\t// copy each member variable/method onto the the subclass's prototype\r\n\tcopyOwnProps(members, subClass.prototype);\r\n\r\n\t// copy over all class variables/methods to the subclass, such as `extend` and `mixin`\r\n\tcopyOwnProps(superClass, subClass);\r\n\r\n\treturn subClass;\r\n}\r\n\r\n;;\r\n\r\nvar EmitterMixin = FC.EmitterMixin = {\r\n\r\n\t// jQuery-ification via $(this) allows a non-DOM object to have\r\n\t// the same event handling capabilities (including namespaces).\r\n\r\n\r\n\ton: function(types, handler) {\r\n\t\t$(this).on(types, this._prepareIntercept(handler));\r\n\t\treturn this; // for chaining\r\n\t},\r\n\r\n\r\n\tone: function(types, handler) {\r\n\t\t$(this).one(types, this._prepareIntercept(handler));\r\n\t\treturn this; // for chaining\r\n\t},\r\n\r\n\r\n\t_prepareIntercept: function(handler) {\r\n\t\t// handlers are always called with an \"event\" object as their first param.\r\n\t\t// sneak the `this` context and arguments into the extra parameter object\r\n\t\t// and forward them on to the original handler.\r\n\t\tvar intercept = function(ev, extra) {\r\n\t\t\treturn handler.apply(\r\n\t\t\t\textra.context || this,\r\n\t\t\t\textra.args || []\r\n\t\t\t);\r\n\t\t};\r\n\r\n\t\t// mimick jQuery's internal \"proxy\" system (risky, I know)\r\n\t\t// causing all functions with the same .guid to appear to be the same.\r\n\t\t// https://github.com/jquery/jquery/blob/2.2.4/src/core.js#L448\r\n\t\t// this is needed for calling .off with the original non-intercept handler.\r\n\t\tif (!handler.guid) {\r\n\t\t\thandler.guid = $.guid++;\r\n\t\t}\r\n\t\tintercept.guid = handler.guid;\r\n\r\n\t\treturn intercept;\r\n\t},\r\n\r\n\r\n\toff: function(types, handler) {\r\n\t\t$(this).off(types, handler);\r\n\r\n\t\treturn this; // for chaining\r\n\t},\r\n\r\n\r\n\ttrigger: function(types) {\r\n\t\tvar args = Array.prototype.slice.call(arguments, 1); // arguments after the first\r\n\r\n\t\t// pass in \"extra\" info to the intercept\r\n\t\t$(this).triggerHandler(types, { args: args });\r\n\r\n\t\treturn this; // for chaining\r\n\t},\r\n\r\n\r\n\ttriggerWith: function(types, context, args) {\r\n\r\n\t\t// `triggerHandler` is less reliant on the DOM compared to `trigger`.\r\n\t\t// pass in \"extra\" info to the intercept.\r\n\t\t$(this).triggerHandler(types, { context: context, args: args });\r\n\r\n\t\treturn this; // for chaining\r\n\t},\r\n\r\n\r\n\thasHandlers: function(type) {\r\n\t\tvar hash = $._data(this, 'events'); // http://blog.jquery.com/2012/08/09/jquery-1-8-released/\r\n\r\n\t\treturn hash && hash[type] && hash[type].length > 0;\r\n\t}\r\n\r\n};\r\n\r\n;;\r\n\r\n/*\r\nUtility methods for easily listening to events on another object,\r\nand more importantly, easily unlistening from them.\r\n*/\r\nvar ListenerMixin = FC.ListenerMixin = (function() {\r\n\tvar guid = 0;\r\n\tvar ListenerMixin = {\r\n\r\n\t\tlistenerId: null,\r\n\r\n\t\t/*\r\n\t\tGiven an `other` object that has on/off methods, bind the given `callback` to an event by the given name.\r\n\t\tThe `callback` will be called with the `this` context of the object that .listenTo is being called on.\r\n\t\tCan be called:\r\n\t\t\t.listenTo(other, eventName, callback)\r\n\t\tOR\r\n\t\t\t.listenTo(other, {\r\n\t\t\t\teventName1: callback1,\r\n\t\t\t\teventName2: callback2\r\n\t\t\t})\r\n\t\t*/\r\n\t\tlistenTo: function(other, arg, callback) {\r\n\t\t\tif (typeof arg === 'object') { // given dictionary of callbacks\r\n\t\t\t\tfor (var eventName in arg) {\r\n\t\t\t\t\tif (arg.hasOwnProperty(eventName)) {\r\n\t\t\t\t\t\tthis.listenTo(other, eventName, arg[eventName]);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse if (typeof arg === 'string') {\r\n\t\t\t\tother.on(\r\n\t\t\t\t\targ + '.' + this.getListenerNamespace(), // use event namespacing to identify this object\r\n\t\t\t\t\t$.proxy(callback, this) // always use `this` context\r\n\t\t\t\t\t\t// the usually-undesired jQuery guid behavior doesn't matter,\r\n\t\t\t\t\t\t// because we always unbind via namespace\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t/*\r\n\t\tCauses the current object to stop listening to events on the `other` object.\r\n\t\t`eventName` is optional. If omitted, will stop listening to ALL events on `other`.\r\n\t\t*/\r\n\t\tstopListeningTo: function(other, eventName) {\r\n\t\t\tother.off((eventName || '') + '.' + this.getListenerNamespace());\r\n\t\t},\r\n\r\n\t\t/*\r\n\t\tReturns a string, unique to this object, to be used for event namespacing\r\n\t\t*/\r\n\t\tgetListenerNamespace: function() {\r\n\t\t\tif (this.listenerId == null) {\r\n\t\t\t\tthis.listenerId = guid++;\r\n\t\t\t}\r\n\t\t\treturn '_listener' + this.listenerId;\r\n\t\t}\r\n\r\n\t};\r\n\treturn ListenerMixin;\r\n})();\r\n;;\r\n\r\nvar ParsableModelMixin = {\r\n\r\n\tstandardPropMap: {}, // will be cloned by defineStandardProps\r\n\r\n\r\n\t/*\r\n\tReturns true/false for success.\r\n\tMeant to be only called ONCE, at object creation.\r\n\t*/\r\n\tapplyProps: function(rawProps) {\r\n\t\tvar standardPropMap = this.standardPropMap;\r\n\t\tvar manualProps = {};\r\n\t\tvar miscProps = {};\r\n\t\tvar propName;\r\n\r\n\t\tfor (propName in rawProps) {\r\n\t\t\tif (standardPropMap[propName] === true) { // copy verbatim\r\n\t\t\t\tthis[propName] = rawProps[propName];\r\n\t\t\t}\r\n\t\t\telse if (standardPropMap[propName] === false) {\r\n\t\t\t\tmanualProps[propName] = rawProps[propName];\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tmiscProps[propName] = rawProps[propName];\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis.applyMiscProps(miscProps);\r\n\r\n\t\treturn this.applyManualStandardProps(manualProps);\r\n\t},\r\n\r\n\r\n\t/*\r\n\tIf subclasses override, they must call this supermethod and return the boolean response.\r\n\tMeant to be only called ONCE, at object creation.\r\n\t*/\r\n\tapplyManualStandardProps: function(rawProps) {\r\n\t\treturn true;\r\n\t},\r\n\r\n\r\n\t/*\r\n\tCan be called even after initial object creation.\r\n\t*/\r\n\tapplyMiscProps: function(rawProps) {\r\n\t\t// subclasses can implement\r\n\t},\r\n\r\n\r\n\t/*\r\n\tTODO: why is this a method when defineStandardProps is static\r\n\t*/\r\n\tisStandardProp: function(propName) {\r\n\t\treturn propName in this.standardPropMap;\r\n\t}\r\n\r\n};\r\n\r\n\r\n/*\r\nTODO: devise a better system\r\n*/\r\nvar ParsableModelMixin_defineStandardProps = function(propDefs) {\r\n\tvar proto = this.prototype;\r\n\r\n\tif (!proto.hasOwnProperty('standardPropMap')) {\r\n\t\tproto.standardPropMap = Object.create(proto.standardPropMap);\r\n\t}\r\n\r\n\tcopyOwnProps(propDefs, proto.standardPropMap);\r\n};\r\n\r\n\r\n/*\r\nTODO: devise a better system\r\n*/\r\nvar ParsableModelMixin_copyVerbatimStandardProps = function(src, dest) {\r\n\tvar map = this.prototype.standardPropMap;\r\n\tvar propName;\r\n\r\n\tfor (propName in map) {\r\n\t\tif (\r\n\t\t\tsrc[propName] != null && // in the src object?\r\n\t\t\tmap[propName] === true // false means \"copy verbatim\"\r\n\t\t) {\r\n\t\t\tdest[propName] = src[propName];\r\n\t\t}\r\n\t}\r\n};\r\n\r\n;;\r\n\r\nvar Model = Class.extend(EmitterMixin, ListenerMixin, {\r\n\r\n\t_props: null,\r\n\t_watchers: null,\r\n\t_globalWatchArgs: {}, // mutation protection in Model.watch\r\n\r\n\tconstructor: function() {\r\n\t\tthis._watchers = {};\r\n\t\tthis._props = {};\r\n\t\tthis.applyGlobalWatchers();\r\n\t\tthis.constructed();\r\n\t},\r\n\r\n\t// useful for monkeypatching. TODO: BaseClass?\r\n\tconstructed: function() {\r\n\t},\r\n\r\n\tapplyGlobalWatchers: function() {\r\n\t\tvar map = this._globalWatchArgs;\r\n\t\tvar name;\r\n\r\n\t\tfor (name in map) {\r\n\t\t\tthis.watch.apply(this, map[name]);\r\n\t\t}\r\n\t},\r\n\r\n\thas: function(name) {\r\n\t\treturn name in this._props;\r\n\t},\r\n\r\n\tget: function(name) {\r\n\t\tif (name === undefined) {\r\n\t\t\treturn this._props;\r\n\t\t}\r\n\r\n\t\treturn this._props[name];\r\n\t},\r\n\r\n\tset: function(name, val) {\r\n\t\tvar newProps;\r\n\r\n\t\tif (typeof name === 'string') {\r\n\t\t\tnewProps = {};\r\n\t\t\tnewProps[name] = val === undefined ? null : val;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tnewProps = name;\r\n\t\t}\r\n\r\n\t\tthis.setProps(newProps);\r\n\t},\r\n\r\n\treset: function(newProps) {\r\n\t\tvar oldProps = this._props;\r\n\t\tvar changeset = {}; // will have undefined's to signal unsets\r\n\t\tvar name;\r\n\r\n\t\tfor (name in oldProps) {\r\n\t\t\tchangeset[name] = undefined;\r\n\t\t}\r\n\r\n\t\tfor (name in newProps) {\r\n\t\t\tchangeset[name] = newProps[name];\r\n\t\t}\r\n\r\n\t\tthis.setProps(changeset);\r\n\t},\r\n\r\n\tunset: function(name) { // accepts a string or array of strings\r\n\t\tvar newProps = {};\r\n\t\tvar names;\r\n\t\tvar i;\r\n\r\n\t\tif (typeof name === 'string') {\r\n\t\t\tnames = [ name ];\r\n\t\t}\r\n\t\telse {\r\n\t\t\tnames = name;\r\n\t\t}\r\n\r\n\t\tfor (i = 0; i < names.length; i++) {\r\n\t\t\tnewProps[names[i]] = undefined;\r\n\t\t}\r\n\r\n\t\tthis.setProps(newProps);\r\n\t},\r\n\r\n\tsetProps: function(newProps) {\r\n\t\tvar changedProps = {};\r\n\t\tvar changedCnt = 0;\r\n\t\tvar name, val;\r\n\r\n\t\tfor (name in newProps) {\r\n\t\t\tval = newProps[name];\r\n\r\n\t\t\t// a change in value?\r\n\t\t\t// if an object, don't check equality, because might have been mutated internally.\r\n\t\t\t// TODO: eventually enforce immutability.\r\n\t\t\tif (\r\n\t\t\t\ttypeof val === 'object' ||\r\n\t\t\t\tval !== this._props[name]\r\n\t\t\t) {\r\n\t\t\t\tchangedProps[name] = val;\r\n\t\t\t\tchangedCnt++;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (changedCnt) {\r\n\r\n\t\t\tthis.trigger('before:batchChange', changedProps);\r\n\r\n\t\t\tfor (name in changedProps) {\r\n\t\t\t\tval = changedProps[name];\r\n\r\n\t\t\t\tthis.trigger('before:change', name, val);\r\n\t\t\t\tthis.trigger('before:change:' + name, val);\r\n\t\t\t}\r\n\r\n\t\t\tfor (name in changedProps) {\r\n\t\t\t\tval = changedProps[name];\r\n\r\n\t\t\t\tif (val === undefined) {\r\n\t\t\t\t\tdelete this._props[name];\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tthis._props[name] = val;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.trigger('change:' + name, val);\r\n\t\t\t\tthis.trigger('change', name, val);\r\n\t\t\t}\r\n\r\n\t\t\tthis.trigger('batchChange', changedProps);\r\n\t\t}\r\n\t},\r\n\r\n\twatch: function(name, depList, startFunc, stopFunc) {\r\n\t\tvar _this = this;\r\n\r\n\t\tthis.unwatch(name);\r\n\r\n\t\tthis._watchers[name] = this._watchDeps(depList, function(deps) {\r\n\t\t\tvar res = startFunc.call(_this, deps);\r\n\r\n\t\t\tif (res && res.then) {\r\n\t\t\t\t_this.unset(name); // put in an unset state while resolving\r\n\t\t\t\tres.then(function(val) {\r\n\t\t\t\t\t_this.set(name, val);\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\t_this.set(name, res);\r\n\t\t\t}\r\n\t\t}, function(deps) {\r\n\t\t\t_this.unset(name);\r\n\r\n\t\t\tif (stopFunc) {\r\n\t\t\t\tstopFunc.call(_this, deps);\r\n\t\t\t}\r\n\t\t});\r\n\t},\r\n\r\n\tunwatch: function(name) {\r\n\t\tvar watcher = this._watchers[name];\r\n\r\n\t\tif (watcher) {\r\n\t\t\tdelete this._watchers[name];\r\n\t\t\twatcher.teardown();\r\n\t\t}\r\n\t},\r\n\r\n\t_watchDeps: function(depList, startFunc, stopFunc) {\r\n\t\tvar _this = this;\r\n\t\tvar queuedChangeCnt = 0;\r\n\t\tvar depCnt = depList.length;\r\n\t\tvar satisfyCnt = 0;\r\n\t\tvar values = {}; // what's passed as the `deps` arguments\r\n\t\tvar bindTuples = []; // array of [ eventName, handlerFunc ] arrays\r\n\t\tvar isCallingStop = false;\r\n\r\n\t\tfunction onBeforeDepChange(depName, val, isOptional) {\r\n\t\t\tqueuedChangeCnt++;\r\n\t\t\tif (queuedChangeCnt === 1) { // first change to cause a \"stop\" ?\r\n\t\t\t\tif (satisfyCnt === depCnt) { // all deps previously satisfied?\r\n\t\t\t\t\tisCallingStop = true;\r\n\t\t\t\t\tstopFunc(values);\r\n\t\t\t\t\tisCallingStop = false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfunction onDepChange(depName, val, isOptional) {\r\n\r\n\t\t\tif (val === undefined) { // unsetting a value?\r\n\r\n\t\t\t\t// required dependency that was previously set?\r\n\t\t\t\tif (!isOptional && values[depName] !== undefined) {\r\n\t\t\t\t\tsatisfyCnt--;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tdelete values[depName];\r\n\t\t\t}\r\n\t\t\telse { // setting a value?\r\n\r\n\t\t\t\t// required dependency that was previously unset?\r\n\t\t\t\tif (!isOptional && values[depName] === undefined) {\r\n\t\t\t\t\tsatisfyCnt++;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvalues[depName] = val;\r\n\t\t\t}\r\n\r\n\t\t\tqueuedChangeCnt--;\r\n\t\t\tif (!queuedChangeCnt) { // last change to cause a \"start\"?\r\n\r\n\t\t\t\t// now finally satisfied or satisfied all along?\r\n\t\t\t\tif (satisfyCnt === depCnt) {\r\n\r\n\t\t\t\t\t// if the stopFunc initiated another value change, ignore it.\r\n\t\t\t\t\t// it will be processed by another change event anyway.\r\n\t\t\t\t\tif (!isCallingStop) {\r\n\t\t\t\t\t\tstartFunc(values);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// intercept for .on() that remembers handlers\r\n\t\tfunction bind(eventName, handler) {\r\n\t\t\t_this.on(eventName, handler);\r\n\t\t\tbindTuples.push([ eventName, handler ]);\r\n\t\t}\r\n\r\n\t\t// listen to dependency changes\r\n\t\tdepList.forEach(function(depName) {\r\n\t\t\tvar isOptional = false;\r\n\r\n\t\t\tif (depName.charAt(0) === '?') { // TODO: more DRY\r\n\t\t\t\tdepName = depName.substring(1);\r\n\t\t\t\tisOptional = true;\r\n\t\t\t}\r\n\r\n\t\t\tbind('before:change:' + depName, function(val) {\r\n\t\t\t\tonBeforeDepChange(depName, val, isOptional);\r\n\t\t\t});\r\n\r\n\t\t\tbind('change:' + depName, function(val) {\r\n\t\t\t\tonDepChange(depName, val, isOptional);\r\n\t\t\t});\r\n\t\t});\r\n\r\n\t\t// process current dependency values\r\n\t\tdepList.forEach(function(depName) {\r\n\t\t\tvar isOptional = false;\r\n\r\n\t\t\tif (depName.charAt(0) === '?') { // TODO: more DRY\r\n\t\t\t\tdepName = depName.substring(1);\r\n\t\t\t\tisOptional = true;\r\n\t\t\t}\r\n\r\n\t\t\tif (_this.has(depName)) {\r\n\t\t\t\tvalues[depName] = _this.get(depName);\r\n\t\t\t\tsatisfyCnt++;\r\n\t\t\t}\r\n\t\t\telse if (isOptional) {\r\n\t\t\t\tsatisfyCnt++;\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\t// initially satisfied\r\n\t\tif (satisfyCnt === depCnt) {\r\n\t\t\tstartFunc(values);\r\n\t\t}\r\n\r\n\t\treturn {\r\n\t\t\tteardown: function() {\r\n\t\t\t\t// remove all handlers\r\n\t\t\t\tfor (var i = 0; i < bindTuples.length; i++) {\r\n\t\t\t\t\t_this.off(bindTuples[i][0], bindTuples[i][1]);\r\n\t\t\t\t}\r\n\t\t\t\tbindTuples = null;\r\n\r\n\t\t\t\t// was satisfied, so call stopFunc\r\n\t\t\t\tif (satisfyCnt === depCnt) {\r\n\t\t\t\t\tstopFunc();\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tflash: function() {\r\n\t\t\t\tif (satisfyCnt === depCnt) {\r\n\t\t\t\t\tstopFunc();\r\n\t\t\t\t\tstartFunc(values);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t},\r\n\r\n\tflash: function(name) {\r\n\t\tvar watcher = this._watchers[name];\r\n\r\n\t\tif (watcher) {\r\n\t\t\twatcher.flash();\r\n\t\t}\r\n\t}\r\n\r\n});\r\n\r\n\r\nModel.watch = function(name /* , depList, startFunc, stopFunc */) {\r\n\r\n\t// subclasses should make a masked-copy of the superclass's map\r\n\t// TODO: write test\r\n\tif (!this.prototype.hasOwnProperty('_globalWatchArgs')) {\r\n\t\tthis.prototype._globalWatchArgs = Object.create(this.prototype._globalWatchArgs);\r\n\t}\r\n\r\n\tthis.prototype._globalWatchArgs[name] = arguments;\r\n};\r\n\r\n\r\nFC.Model = Model;\r\n\r\n\r\n;;\r\n\r\nvar Promise = {\r\n\r\n\tconstruct: function(executor) {\r\n\t\tvar deferred = $.Deferred();\r\n\t\tvar promise = deferred.promise();\r\n\r\n\t\tif (typeof executor === 'function') {\r\n\t\t\texecutor(\r\n\t\t\t\tfunction(val) { // resolve\r\n\t\t\t\t\tdeferred.resolve(val);\r\n\t\t\t\t\tattachImmediatelyResolvingThen(promise, val);\r\n\t\t\t\t},\r\n\t\t\t\tfunction() { // reject\r\n\t\t\t\t\tdeferred.reject();\r\n\t\t\t\t\tattachImmediatelyRejectingThen(promise);\r\n\t\t\t\t}\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\treturn promise;\r\n\t},\r\n\r\n\tresolve: function(val) {\r\n\t\tvar deferred = $.Deferred().resolve(val);\r\n\t\tvar promise = deferred.promise();\r\n\r\n\t\tattachImmediatelyResolvingThen(promise, val);\r\n\r\n\t\treturn promise;\r\n\t},\r\n\r\n\treject: function() {\r\n\t\tvar deferred = $.Deferred().reject();\r\n\t\tvar promise = deferred.promise();\r\n\r\n\t\tattachImmediatelyRejectingThen(promise);\r\n\r\n\t\treturn promise;\r\n\t}\r\n\r\n};\r\n\r\n\r\nfunction attachImmediatelyResolvingThen(promise, val) {\r\n\tpromise.then = function(onResolve) {\r\n\t\tif (typeof onResolve === 'function') {\r\n\t\t\treturn Promise.resolve(onResolve(val));\r\n\t\t}\r\n\t\treturn promise;\r\n\t};\r\n}\r\n\r\n\r\nfunction attachImmediatelyRejectingThen(promise) {\r\n\tpromise.then = function(onResolve, onReject) {\r\n\t\tif (typeof onReject === 'function') {\r\n\t\t\tonReject();\r\n\t\t}\r\n\t\treturn promise;\r\n\t};\r\n}\r\n\r\n\r\nFC.Promise = Promise;\r\n\r\n;;\r\n\r\nvar TaskQueue = Class.extend(EmitterMixin, {\r\n\r\n\tq: null,\r\n\tisPaused: false,\r\n\tisRunning: false,\r\n\r\n\r\n\tconstructor: function() {\r\n\t\tthis.q = [];\r\n\t},\r\n\r\n\r\n\tqueue: function(/* taskFunc, taskFunc... */) {\r\n\t\tthis.q.push.apply(this.q, arguments); // append\r\n\t\tthis.tryStart();\r\n\t},\r\n\r\n\r\n\tpause: function() {\r\n\t\tthis.isPaused = true;\r\n\t},\r\n\r\n\r\n\tresume: function() {\r\n\t\tthis.isPaused = false;\r\n\t\tthis.tryStart();\r\n\t},\r\n\r\n\r\n\tgetIsIdle: function() {\r\n\t\treturn !this.isRunning && !this.isPaused;\r\n\t},\r\n\r\n\r\n\ttryStart: function() {\r\n\t\tif (!this.isRunning && this.canRunNext()) {\r\n\t\t\tthis.isRunning = true;\r\n\t\t\tthis.trigger('start');\r\n\t\t\tthis.runRemaining();\r\n\t\t}\r\n\t},\r\n\r\n\r\n\tcanRunNext: function() {\r\n\t\treturn !this.isPaused && this.q.length;\r\n\t},\r\n\r\n\r\n\trunRemaining: function() { // assumes at least one task in queue. does not check canRunNext for first task.\r\n\t\tvar _this = this;\r\n\t\tvar task;\r\n\t\tvar res;\r\n\r\n\t\tdo {\r\n\t\t\ttask = this.q.shift(); // always freshly reference q. might have been reassigned.\r\n\t\t\tres = this.runTask(task);\r\n\r\n\t\t\tif (res && res.then) {\r\n\t\t\t\tres.then(function() { // jshint ignore:line\r\n\t\t\t\t\tif (_this.canRunNext()) {\r\n\t\t\t\t\t\t_this.runRemaining();\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t\treturn; // prevent marking as stopped\r\n\t\t\t}\r\n\t\t} while (this.canRunNext());\r\n\r\n\t\tthis.trigger('stop'); // not really a 'stop' ... more of a 'drained'\r\n\t\tthis.isRunning = false;\r\n\r\n\t\t// if 'stop' handler added more tasks.... TODO: write test for this\r\n\t\tthis.tryStart();\r\n\t},\r\n\r\n\r\n\trunTask: function(task) {\r\n\t\treturn task(); // task *is* the function, but subclasses can change the format of a task\r\n\t}\r\n\r\n});\r\n\r\nFC.TaskQueue = TaskQueue;\r\n\r\n;;\r\n\r\nvar RenderQueue = TaskQueue.extend({\r\n\r\n\twaitsByNamespace: null,\r\n\twaitNamespace: null,\r\n\twaitId: null,\r\n\r\n\r\n\tconstructor: function(waitsByNamespace) {\r\n\t\tTaskQueue.call(this); // super-constructor\r\n\r\n\t\tthis.waitsByNamespace = waitsByNamespace || {};\r\n\t},\r\n\r\n\r\n\tqueue: function(taskFunc, namespace, type) {\r\n\t\tvar task = {\r\n\t\t\tfunc: taskFunc,\r\n\t\t\tnamespace: namespace,\r\n\t\t\ttype: type\r\n\t\t};\r\n\t\tvar waitMs;\r\n\r\n\t\tif (namespace) {\r\n\t\t\twaitMs = this.waitsByNamespace[namespace];\r\n\t\t}\r\n\r\n\t\tif (this.waitNamespace) {\r\n\t\t\tif (namespace === this.waitNamespace && waitMs != null) {\r\n\t\t\t\tthis.delayWait(waitMs);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tthis.clearWait();\r\n\t\t\t\tthis.tryStart();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (this.compoundTask(task)) { // appended to queue?\r\n\r\n\t\t\tif (!this.waitNamespace && waitMs != null) {\r\n\t\t\t\tthis.startWait(namespace, waitMs);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tthis.tryStart();\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\r\n\tstartWait: function(namespace, waitMs) {\r\n\t\tthis.waitNamespace = namespace;\r\n\t\tthis.spawnWait(waitMs);\r\n\t},\r\n\r\n\r\n\tdelayWait: function(waitMs) {\r\n\t\tclearTimeout(this.waitId);\r\n\t\tthis.spawnWait(waitMs);\r\n\t},\r\n\r\n\r\n\tspawnWait: function(waitMs) {\r\n\t\tvar _this = this;\r\n\r\n\t\tthis.waitId = setTimeout(function() {\r\n\t\t\t_this.waitNamespace = null;\r\n\t\t\t_this.tryStart();\r\n\t\t}, waitMs);\r\n\t},\r\n\r\n\r\n\tclearWait: function() {\r\n\t\tif (this.waitNamespace) {\r\n\t\t\tclearTimeout(this.waitId);\r\n\t\t\tthis.waitId = null;\r\n\t\t\tthis.waitNamespace = null;\r\n\t\t}\r\n\t},\r\n\r\n\r\n\tcanRunNext: function() {\r\n\t\tif (!TaskQueue.prototype.canRunNext.apply(this, arguments)) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\t// waiting for a certain namespace to stop receiving tasks?\r\n\t\tif (this.waitNamespace) {\r\n\r\n\t\t\t// if there was a different namespace task in the meantime,\r\n\t\t\t// that forces all previously-waiting tasks to suddenly execute.\r\n\t\t\t// TODO: find a way to do this in constant time.\r\n\t\t\tfor (var q = this.q, i = 0; i < q.length; i++) {\r\n\t\t\t\tif (q[i].namespace !== this.waitNamespace) {\r\n\t\t\t\t\treturn true; // allow execution\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\t},\r\n\r\n\r\n\trunTask: function(task) {\r\n\t\ttask.func();\r\n\t},\r\n\r\n\r\n\tcompoundTask: function(newTask) {\r\n\t\tvar q = this.q;\r\n\t\tvar shouldAppend = true;\r\n\t\tvar i, task;\r\n\r\n\t\tif (newTask.namespace && newTask.type === 'destroy') {\r\n\r\n\t\t\t// remove all init/add/remove ops with same namespace, regardless of order\r\n\t\t\tfor (i = q.length - 1; i >= 0; i--) {\r\n\t\t\t\ttask = q[i];\r\n\r\n\t\t\t\tswitch (task.type) {\r\n\t\t\t\t\tcase 'init':\r\n\t\t\t\t\t\tshouldAppend = false; // jshint ignore:line\r\n\t\t\t\t\t\t// the latest destroy is cancelled out by not doing the init\r\n\t\t\t\t\t\t// and fallthrough....\r\n\t\t\t\t\tcase 'add':\r\n\t\t\t\t\tcase 'remove':\r\n\t\t\t\t\t\tq.splice(i, 1); // remove task\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (shouldAppend) {\r\n\t\t\tq.push(newTask);\r\n\t\t}\r\n\r\n\t\treturn shouldAppend;\r\n\t}\r\n\r\n});\r\n\r\nFC.RenderQueue = RenderQueue;\r\n\r\n;;\r\n\r\n/* A rectangular panel that is absolutely positioned over other content\r\n------------------------------------------------------------------------------------------------------------------------\r\nOptions:\r\n\t- className (string)\r\n\t- content (HTML string or jQuery element set)\r\n\t- parentEl\r\n\t- top\r\n\t- left\r\n\t- right (the x coord of where the right edge should be. not a \"CSS\" right)\r\n\t- autoHide (boolean)\r\n\t- show (callback)\r\n\t- hide (callback)\r\n*/\r\n\r\nvar Popover = Class.extend(ListenerMixin, {\r\n\r\n\tisHidden: true,\r\n\toptions: null,\r\n\tel: null, // the container element for the popover. generated by this object\r\n\tmargin: 10, // the space required between the popover and the edges of the scroll container\r\n\r\n\r\n\tconstructor: function(options) {\r\n\t\tthis.options = options || {};\r\n\t},\r\n\r\n\r\n\t// Shows the popover on the specified position. Renders it if not already\r\n\tshow: function() {\r\n\t\tif (this.isHidden) {\r\n\t\t\tif (!this.el) {\r\n\t\t\t\tthis.render();\r\n\t\t\t}\r\n\t\t\tthis.el.show();\r\n\t\t\tthis.position();\r\n\t\t\tthis.isHidden = false;\r\n\t\t\tthis.trigger('show');\r\n\t\t}\r\n\t},\r\n\r\n\r\n\t// Hides the popover, through CSS, but does not remove it from the DOM\r\n\thide: function() {\r\n\t\tif (!this.isHidden) {\r\n\t\t\tthis.el.hide();\r\n\t\t\tthis.isHidden = true;\r\n\t\t\tthis.trigger('hide');\r\n\t\t}\r\n\t},\r\n\r\n\r\n\t// Creates `this.el` and renders content inside of it\r\n\trender: function() {\r\n\t\tvar _this = this;\r\n\t\tvar options = this.options;\r\n\r\n\t\tthis.el = $('<div class=\"fc-popover\"/>')\r\n\t\t\t.addClass(options.className || '')\r\n\t\t\t.css({\r\n\t\t\t\t// position initially to the top left to avoid creating scrollbars\r\n\t\t\t\ttop: 0,\r\n\t\t\t\tleft: 0\r\n\t\t\t})\r\n\t\t\t.append(options.content)\r\n\t\t\t.appendTo(options.parentEl);\r\n\r\n\t\t// when a click happens on anything inside with a 'fc-close' className, hide the popover\r\n\t\tthis.el.on('click', '.fc-close', function() {\r\n\t\t\t_this.hide();\r\n\t\t});\r\n\r\n\t\tif (options.autoHide) {\r\n\t\t\tthis.listenTo($(document), 'mousedown', this.documentMousedown);\r\n\t\t}\r\n\t},\r\n\r\n\r\n\t// Triggered when the user clicks *anywhere* in the document, for the autoHide feature\r\n\tdocumentMousedown: function(ev) {\r\n\t\t// only hide the popover if the click happened outside the popover\r\n\t\tif (this.el && !$(ev.target).closest(this.el).length) {\r\n\t\t\tthis.hide();\r\n\t\t}\r\n\t},\r\n\r\n\r\n\t// Hides and unregisters any handlers\r\n\tremoveElement: function() {\r\n\t\tthis.hide();\r\n\r\n\t\tif (this.el) {\r\n\t\t\tthis.el.remove();\r\n\t\t\tthis.el = null;\r\n\t\t}\r\n\r\n\t\tthis.stopListeningTo($(document), 'mousedown');\r\n\t},\r\n\r\n\r\n\t// Positions the popover optimally, using the top/left/right options\r\n\tposition: function() {\r\n\t\tvar options = this.options;\r\n\t\tvar origin = this.el.offsetParent().offset();\r\n\t\tvar width = this.el.outerWidth();\r\n\t\tvar height = this.el.outerHeight();\r\n\t\tvar windowEl = $(window);\r\n\t\tvar viewportEl = getScrollParent(this.el);\r\n\t\tvar viewportTop;\r\n\t\tvar viewportLeft;\r\n\t\tvar viewportOffset;\r\n\t\tvar top; // the \"position\" (not \"offset\") values for the popover\r\n\t\tvar left; //\r\n\r\n\t\t// compute top and left\r\n\t\ttop = options.top || 0;\r\n\t\tif (options.left !== undefined) {\r\n\t\t\tleft = options.left;\r\n\t\t}\r\n\t\telse if (options.right !== undefined) {\r\n\t\t\tleft = options.right - width; // derive the left value from the right value\r\n\t\t}\r\n\t\telse {\r\n\t\t\tleft = 0;\r\n\t\t}\r\n\r\n\t\tif (viewportEl.is(window) || viewportEl.is(document)) { // normalize getScrollParent's result\r\n\t\t\tviewportEl = windowEl;\r\n\t\t\tviewportTop = 0; // the window is always at the top left\r\n\t\t\tviewportLeft = 0; // (and .offset() won't work if called here)\r\n\t\t}\r\n\t\telse {\r\n\t\t\tviewportOffset = viewportEl.offset();\r\n\t\t\tviewportTop = viewportOffset.top;\r\n\t\t\tviewportLeft = viewportOffset.left;\r\n\t\t}\r\n\r\n\t\t// if the window is scrolled, it causes the visible area to be further down\r\n\t\tviewportTop += windowEl.scrollTop();\r\n\t\tviewportLeft += windowEl.scrollLeft();\r\n\r\n\t\t// constrain to the view port. if constrained by two edges, give precedence to top/left\r\n\t\tif (options.viewportConstrain !== false) {\r\n\t\t\ttop = Math.min(top, viewportTop + viewportEl.outerHeight() - height - this.margin);\r\n\t\t\ttop = Math.max(top, viewportTop + this.margin);\r\n\t\t\tleft = Math.min(left, viewportLeft + viewportEl.outerWidth() - width - this.margin);\r\n\t\t\tleft = Math.max(left, viewportLeft + this.margin);\r\n\t\t}\r\n\r\n\t\tthis.el.css({\r\n\t\t\ttop: top - origin.top,\r\n\t\t\tleft: left - origin.left\r\n\t\t});\r\n\t},\r\n\r\n\r\n\t// Triggers a callback. Calls a function in the option hash of the same name.\r\n\t// Arguments beyond the first `name` are forwarded on.\r\n\t// TODO: better code reuse for this. Repeat code\r\n\ttrigger: function(name) {\r\n\t\tif (this.options[name]) {\r\n\t\t\tthis.options[name].apply(this, Array.prototype.slice.call(arguments, 1));\r\n\t\t}\r\n\t}\r\n\r\n});\r\n\r\n;;\r\n\r\n/*\r\nA cache for the left/right/top/bottom/width/height values for one or more elements.\r\nWorks with both offset (from topleft document) and position (from offsetParent).\r\n\r\noptions:\r\n- els\r\n- isHorizontal\r\n- isVertical\r\n*/\r\nvar CoordCache = FC.CoordCache = Class.extend({\r\n\r\n\tels: null, // jQuery set (assumed to be siblings)\r\n\tforcedOffsetParentEl: null, // options can override the natural offsetParent\r\n\torigin: null, // {left,top} position of offsetParent of els\r\n\tboundingRect: null, // constrain cordinates to this rectangle. {left,right,top,bottom} or null\r\n\tisHorizontal: false, // whether to query for left/right/width\r\n\tisVertical: false, // whether to query for top/bottom/height\r\n\r\n\t// arrays of coordinates (offsets from topleft of document)\r\n\tlefts: null,\r\n\trights: null,\r\n\ttops: null,\r\n\tbottoms: null,\r\n\r\n\r\n\tconstructor: function(options) {\r\n\t\tthis.els = $(options.els);\r\n\t\tthis.isHorizontal = options.isHorizontal;\r\n\t\tthis.isVertical = options.isVertical;\r\n\t\tthis.forcedOffsetParentEl = options.offsetParent ? $(options.offsetParent) : null;\r\n\t},\r\n\r\n\r\n\t// Queries the els for coordinates and stores them.\r\n\t// Call this method before using and of the get* methods below.\r\n\tbuild: function() {\r\n\t\tvar offsetParentEl = this.forcedOffsetParentEl;\r\n\t\tif (!offsetParentEl && this.els.length > 0) {\r\n\t\t\toffsetParentEl = this.els.eq(0).offsetParent();\r\n\t\t}\r\n\r\n\t\tthis.origin = offsetParentEl ?\r\n\t\t\toffsetParentEl.offset() :\r\n\t\t\tnull;\r\n\r\n\t\tthis.boundingRect = this.queryBoundingRect();\r\n\r\n\t\tif (this.isHorizontal) {\r\n\t\t\tthis.buildElHorizontals();\r\n\t\t}\r\n\t\tif (this.isVertical) {\r\n\t\t\tthis.buildElVerticals();\r\n\t\t}\r\n\t},\r\n\r\n\r\n\t// Destroys all internal data about coordinates, freeing memory\r\n\tclear: function() {\r\n\t\tthis.origin = null;\r\n\t\tthis.boundingRect = null;\r\n\t\tthis.lefts = null;\r\n\t\tthis.rights = null;\r\n\t\tthis.tops = null;\r\n\t\tthis.bottoms = null;\r\n\t},\r\n\r\n\r\n\t// When called, if coord caches aren't built, builds them\r\n\tensureBuilt: function() {\r\n\t\tif (!this.origin) {\r\n\t\t\tthis.build();\r\n\t\t}\r\n\t},\r\n\r\n\r\n\t// Populates the left/right internal coordinate arrays\r\n\tbuildElHorizontals: function() {\r\n\t\tvar lefts = [];\r\n\t\tvar rights = [];\r\n\r\n\t\tthis.els.each(function(i, node) {\r\n\t\t\tvar el = $(node);\r\n\t\t\tvar left = el.offset().left;\r\n\t\t\tvar width = el.outerWidth();\r\n\r\n\t\t\tlefts.push(left);\r\n\t\t\trights.push(left + width);\r\n\t\t});\r\n\r\n\t\tthis.lefts = lefts;\r\n\t\tthis.rights = rights;\r\n\t},\r\n\r\n\r\n\t// Populates the top/bottom internal coordinate arrays\r\n\tbuildElVerticals: function() {\r\n\t\tvar tops = [];\r\n\t\tvar bottoms = [];\r\n\r\n\t\tthis.els.each(function(i, node) {\r\n\t\t\tvar el = $(node);\r\n\t\t\tvar top = el.offset().top;\r\n\t\t\tvar height = el.outerHeight();\r\n\r\n\t\t\ttops.push(top);\r\n\t\t\tbottoms.push(top + height);\r\n\t\t});\r\n\r\n\t\tthis.tops = tops;\r\n\t\tthis.bottoms = bottoms;\r\n\t},\r\n\r\n\r\n\t// Given a left offset (from document left), returns the index of the el that it horizontally intersects.\r\n\t// If no intersection is made, returns undefined.\r\n\tgetHorizontalIndex: function(leftOffset) {\r\n\t\tthis.ensureBuilt();\r\n\r\n\t\tvar lefts = this.lefts;\r\n\t\tvar rights = this.rights;\r\n\t\tvar len = lefts.length;\r\n\t\tvar i;\r\n\r\n\t\tfor (i = 0; i < len; i++) {\r\n\t\t\tif (leftOffset >= lefts[i] && leftOffset < rights[i]) {\r\n\t\t\t\treturn i;\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\r\n\t// Given a top offset (from document top), returns the index of the el that it vertically intersects.\r\n\t// If no intersection is made, returns undefined.\r\n\tgetVerticalIndex: function(topOffset) {\r\n\t\tthis.ensureBuilt();\r\n\r\n\t\tvar tops = this.tops;\r\n\t\tvar bottoms = this.bottoms;\r\n\t\tvar len = tops.length;\r\n\t\tvar i;\r\n\r\n\t\tfor (i = 0; i < len; i++) {\r\n\t\t\tif (topOffset >= tops[i] && topOffset < bottoms[i]) {\r\n\t\t\t\treturn i;\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\r\n\t// Gets the left offset (from document left) of the element at the given index\r\n\tgetLeftOffset: function(leftIndex) {\r\n\t\tthis.ensureBuilt();\r\n\t\treturn this.lefts[leftIndex];\r\n\t},\r\n\r\n\r\n\t// Gets the left position (from offsetParent left) of the element at the given index\r\n\tgetLeftPosition: function(leftIndex) {\r\n\t\tthis.ensureBuilt();\r\n\t\treturn this.lefts[leftIndex] - this.origin.left;\r\n\t},\r\n\r\n\r\n\t// Gets the right offset (from document left) of the element at the given index.\r\n\t// This value is NOT relative to the document's right edge, like the CSS concept of \"right\" would be.\r\n\tgetRightOffset: function(leftIndex) {\r\n\t\tthis.ensureBuilt();\r\n\t\treturn this.rights[leftIndex];\r\n\t},\r\n\r\n\r\n\t// Gets the right position (from offsetParent left) of the element at the given index.\r\n\t// This value is NOT relative to the offsetParent's right edge, like the CSS concept of \"right\" would be.\r\n\tgetRightPosition: function(leftIndex) {\r\n\t\tthis.ensureBuilt();\r\n\t\treturn this.rights[leftIndex] - this.origin.left;\r\n\t},\r\n\r\n\r\n\t// Gets the width of the element at the given index\r\n\tgetWidth: function(leftIndex) {\r\n\t\tthis.ensureBuilt();\r\n\t\treturn this.rights[leftIndex] - this.lefts[leftIndex];\r\n\t},\r\n\r\n\r\n\t// Gets the top offset (from document top) of the element at the given index\r\n\tgetTopOffset: function(topIndex) {\r\n\t\tthis.ensureBuilt();\r\n\t\treturn this.tops[topIndex];\r\n\t},\r\n\r\n\r\n\t// Gets the top position (from offsetParent top) of the element at the given position\r\n\tgetTopPosition: function(topIndex) {\r\n\t\tthis.ensureBuilt();\r\n\t\treturn this.tops[topIndex] - this.origin.top;\r\n\t},\r\n\r\n\t// Gets the bottom offset (from the document top) of the element at the given index.\r\n\t// This value is NOT relative to the offsetParent's bottom edge, like the CSS concept of \"bottom\" would be.\r\n\tgetBottomOffset: function(topIndex) {\r\n\t\tthis.ensureBuilt();\r\n\t\treturn this.bottoms[topIndex];\r\n\t},\r\n\r\n\r\n\t// Gets the bottom position (from the offsetParent top) of the element at the given index.\r\n\t// This value is NOT relative to the offsetParent's bottom edge, like the CSS concept of \"bottom\" would be.\r\n\tgetBottomPosition: function(topIndex) {\r\n\t\tthis.ensureBuilt();\r\n\t\treturn this.bottoms[topIndex] - this.origin.top;\r\n\t},\r\n\r\n\r\n\t// Gets the height of the element at the given index\r\n\tgetHeight: function(topIndex) {\r\n\t\tthis.ensureBuilt();\r\n\t\treturn this.bottoms[topIndex] - this.tops[topIndex];\r\n\t},\r\n\r\n\r\n\t// Bounding Rect\r\n\t// TODO: decouple this from CoordCache\r\n\r\n\t// Compute and return what the elements' bounding rectangle is, from the user's perspective.\r\n\t// Right now, only returns a rectangle if constrained by an overflow:scroll element.\r\n\t// Returns null if there are no elements\r\n\tqueryBoundingRect: function() {\r\n\t\tvar scrollParentEl;\r\n\r\n\t\tif (this.els.length > 0) {\r\n\t\t\tscrollParentEl = getScrollParent(this.els.eq(0));\r\n\r\n\t\t\tif (!scrollParentEl.is(document)) {\r\n\t\t\t\treturn getClientRect(scrollParentEl);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn null;\r\n\t},\r\n\r\n\tisPointInBounds: function(leftOffset, topOffset) {\r\n\t\treturn this.isLeftInBounds(leftOffset) && this.isTopInBounds(topOffset);\r\n\t},\r\n\r\n\tisLeftInBounds: function(leftOffset) {\r\n\t\treturn !this.boundingRect || (leftOffset >= this.boundingRect.left && leftOffset < this.boundingRect.right);\r\n\t},\r\n\r\n\tisTopInBounds: function(topOffset) {\r\n\t\treturn !this.boundingRect || (topOffset >= this.boundingRect.top && topOffset < this.boundingRect.bottom);\r\n\t}\r\n\r\n});\r\n\r\n;;\r\n\r\n/* Tracks a drag's mouse movement, firing various handlers\r\n----------------------------------------------------------------------------------------------------------------------*/\r\n// TODO: use Emitter\r\n\r\nvar DragListener = FC.DragListener = Class.extend(ListenerMixin, {\r\n\r\n\toptions: null,\r\n\tsubjectEl: null,\r\n\r\n\t// coordinates of the initial mousedown\r\n\toriginX: null,\r\n\toriginY: null,\r\n\r\n\t// the wrapping element that scrolls, or MIGHT scroll if there's overflow.\r\n\t// TODO: do this for wrappers that have overflow:hidden as well.\r\n\tscrollEl: null,\r\n\r\n\tisInteracting: false,\r\n\tisDistanceSurpassed: false,\r\n\tisDelayEnded: false,\r\n\tisDragging: false,\r\n\tisTouch: false,\r\n\tisGeneric: false, // initiated by 'dragstart' (jqui)\r\n\r\n\tdelay: null,\r\n\tdelayTimeoutId: null,\r\n\tminDistance: null,\r\n\r\n\tshouldCancelTouchScroll: true,\r\n\tscrollAlwaysKills: false,\r\n\r\n\r\n\tconstructor: function(options) {\r\n\t\tthis.options = options || {};\r\n\t},\r\n\r\n\r\n\t// Interaction (high-level)\r\n\t// -----------------------------------------------------------------------------------------------------------------\r\n\r\n\r\n\tstartInteraction: function(ev, extraOptions) {\r\n\r\n\t\tif (ev.type === 'mousedown') {\r\n\t\t\tif (GlobalEmitter.get().shouldIgnoreMouse()) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\telse if (!isPrimaryMouseButton(ev)) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tev.preventDefault(); // prevents native selection in most browsers\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (!this.isInteracting) {\r\n\r\n\t\t\t// process options\r\n\t\t\textraOptions = extraOptions || {};\r\n\t\t\tthis.delay = firstDefined(extraOptions.delay, this.options.delay, 0);\r\n\t\t\tthis.minDistance = firstDefined(extraOptions.distance, this.options.distance, 0);\r\n\t\t\tthis.subjectEl = this.options.subjectEl;\r\n\r\n\t\t\tpreventSelection($('body'));\r\n\r\n\t\t\tthis.isInteracting = true;\r\n\t\t\tthis.isTouch = getEvIsTouch(ev);\r\n\t\t\tthis.isGeneric = ev.type === 'dragstart';\r\n\t\t\tthis.isDelayEnded = false;\r\n\t\t\tthis.isDistanceSurpassed = false;\r\n\r\n\t\t\tthis.originX = getEvX(ev);\r\n\t\t\tthis.originY = getEvY(ev);\r\n\t\t\tthis.scrollEl = getScrollParent($(ev.target));\r\n\r\n\t\t\tthis.bindHandlers();\r\n\t\t\tthis.initAutoScroll();\r\n\t\t\tthis.handleInteractionStart(ev);\r\n\t\t\tthis.startDelay(ev);\r\n\r\n\t\t\tif (!this.minDistance) {\r\n\t\t\t\tthis.handleDistanceSurpassed(ev);\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\r\n\thandleInteractionStart: function(ev) {\r\n\t\tthis.trigger('interactionStart', ev);\r\n\t},\r\n\r\n\r\n\tendInteraction: function(ev, isCancelled) {\r\n\t\tif (this.isInteracting) {\r\n\t\t\tthis.endDrag(ev);\r\n\r\n\t\t\tif (this.delayTimeoutId) {\r\n\t\t\t\tclearTimeout(this.delayTimeoutId);\r\n\t\t\t\tthis.delayTimeoutId = null;\r\n\t\t\t}\r\n\r\n\t\t\tthis.destroyAutoScroll();\r\n\t\t\tthis.unbindHandlers();\r\n\r\n\t\t\tthis.isInteracting = false;\r\n\t\t\tthis.handleInteractionEnd(ev, isCancelled);\r\n\r\n\t\t\tallowSelection($('body'));\r\n\t\t}\r\n\t},\r\n\r\n\r\n\thandleInteractionEnd: function(ev, isCancelled) {\r\n\t\tthis.trigger('interactionEnd', ev, isCancelled || false);\r\n\t},\r\n\r\n\r\n\t// Binding To DOM\r\n\t// -----------------------------------------------------------------------------------------------------------------\r\n\r\n\r\n\tbindHandlers: function() {\r\n\t\t// some browsers (Safari in iOS 10) don't allow preventDefault on touch events that are bound after touchstart,\r\n\t\t// so listen to the GlobalEmitter singleton, which is always bound, instead of the document directly.\r\n\t\tvar globalEmitter = GlobalEmitter.get();\r\n\r\n\t\tif (this.isGeneric) {\r\n\t\t\tthis.listenTo($(document), { // might only work on iOS because of GlobalEmitter's bind :(\r\n\t\t\t\tdrag: this.handleMove,\r\n\t\t\t\tdragstop: this.endInteraction\r\n\t\t\t});\r\n\t\t}\r\n\t\telse if (this.isTouch) {\r\n\t\t\tthis.listenTo(globalEmitter, {\r\n\t\t\t\ttouchmove: this.handleTouchMove,\r\n\t\t\t\ttouchend: this.endInteraction,\r\n\t\t\t\tscroll: this.handleTouchScroll\r\n\t\t\t});\r\n\t\t}\r\n\t\telse {\r\n\t\t\tthis.listenTo(globalEmitter, {\r\n\t\t\t\tmousemove: this.handleMouseMove,\r\n\t\t\t\tmouseup: this.endInteraction\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tthis.listenTo(globalEmitter, {\r\n\t\t\tselectstart: preventDefault, // don't allow selection while dragging\r\n\t\t\tcontextmenu: preventDefault // long taps would open menu on Chrome dev tools\r\n\t\t});\r\n\t},\r\n\r\n\r\n\tunbindHandlers: function() {\r\n\t\tthis.stopListeningTo(GlobalEmitter.get());\r\n\t\tthis.stopListeningTo($(document)); // for isGeneric\r\n\t},\r\n\r\n\r\n\t// Drag (high-level)\r\n\t// -----------------------------------------------------------------------------------------------------------------\r\n\r\n\r\n\t// extraOptions ignored if drag already started\r\n\tstartDrag: function(ev, extraOptions) {\r\n\t\tthis.startInteraction(ev, extraOptions); // ensure interaction began\r\n\r\n\t\tif (!this.isDragging) {\r\n\t\t\tthis.isDragging = true;\r\n\t\t\tthis.handleDragStart(ev);\r\n\t\t}\r\n\t},\r\n\r\n\r\n\thandleDragStart: function(ev) {\r\n\t\tthis.trigger('dragStart', ev);\r\n\t},\r\n\r\n\r\n\thandleMove: function(ev) {\r\n\t\tvar dx = getEvX(ev) - this.originX;\r\n\t\tvar dy = getEvY(ev) - this.originY;\r\n\t\tvar minDistance = this.minDistance;\r\n\t\tvar distanceSq; // current distance from the origin, squared\r\n\r\n\t\tif (!this.isDistanceSurpassed) {\r\n\t\t\tdistanceSq = dx * dx + dy * dy;\r\n\t\t\tif (distanceSq >= minDistance * minDistance) { // use pythagorean theorem\r\n\t\t\t\tthis.handleDistanceSurpassed(ev);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (this.isDragging) {\r\n\t\t\tthis.handleDrag(dx, dy, ev);\r\n\t\t}\r\n\t},\r\n\r\n\r\n\t// Called while the mouse is being moved and when we know a legitimate drag is taking place\r\n\thandleDrag: function(dx, dy, ev) {\r\n\t\tthis.trigger('drag', dx, dy, ev);\r\n\t\tthis.updateAutoScroll(ev); // will possibly cause scrolling\r\n\t},\r\n\r\n\r\n\tendDrag: function(ev) {\r\n\t\tif (this.isDragging) {\r\n\t\t\tthis.isDragging = false;\r\n\t\t\tthis.handleDragEnd(ev);\r\n\t\t}\r\n\t},\r\n\r\n\r\n\thandleDragEnd: function(ev) {\r\n\t\tthis.trigger('dragEnd', ev);\r\n\t},\r\n\r\n\r\n\t// Delay\r\n\t// -----------------------------------------------------------------------------------------------------------------\r\n\r\n\r\n\tstartDelay: function(initialEv) {\r\n\t\tvar _this = this;\r\n\r\n\t\tif (this.delay) {\r\n\t\t\tthis.delayTimeoutId = setTimeout(function() {\r\n\t\t\t\t_this.handleDelayEnd(initialEv);\r\n\t\t\t}, this.delay);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tthis.handleDelayEnd(initialEv);\r\n\t\t}\r\n\t},\r\n\r\n\r\n\thandleDelayEnd: function(initialEv) {\r\n\t\tthis.isDelayEnded = true;\r\n\r\n\t\tif (this.isDistanceSurpassed) {\r\n\t\t\tthis.startDrag(initialEv);\r\n\t\t}\r\n\t},\r\n\r\n\r\n\t// Distance\r\n\t// -----------------------------------------------------------------------------------------------------------------\r\n\r\n\r\n\thandleDistanceSurpassed: function(ev) {\r\n\t\tthis.isDistanceSurpassed = true;\r\n\r\n\t\tif (this.isDelayEnded) {\r\n\t\t\tthis.startDrag(ev);\r\n\t\t}\r\n\t},\r\n\r\n\r\n\t// Mouse / Touch\r\n\t// -----------------------------------------------------------------------------------------------------------------\r\n\r\n\r\n\thandleTouchMove: function(ev) {\r\n\r\n\t\t// prevent inertia and touchmove-scrolling while dragging\r\n\t\tif (this.isDragging && this.shouldCancelTouchScroll) {\r\n\t\t\tev.preventDefault();\r\n\t\t}\r\n\r\n\t\tthis.handleMove(ev);\r\n\t},\r\n\r\n\r\n\thandleMouseMove: function(ev) {\r\n\t\tthis.handleMove(ev);\r\n\t},\r\n\r\n\r\n\t// Scrolling (unrelated to auto-scroll)\r\n\t// -----------------------------------------------------------------------------------------------------------------\r\n\r\n\r\n\thandleTouchScroll: function(ev) {\r\n\t\t// if the drag is being initiated by touch, but a scroll happens before\r\n\t\t// the drag-initiating delay is over, cancel the drag\r\n\t\tif (!this.isDragging || this.scrollAlwaysKills) {\r\n\t\t\tthis.endInteraction(ev, true); // isCancelled=true\r\n\t\t}\r\n\t},\r\n\r\n\r\n\t// Utils\r\n\t// -----------------------------------------------------------------------------------------------------------------\r\n\r\n\r\n\t// Triggers a callback. Calls a function in the option hash of the same name.\r\n\t// Arguments beyond the first `name` are forwarded on.\r\n\ttrigger: function(name) {\r\n\t\tif (this.options[name]) {\r\n\t\t\tthis.options[name].apply(this, Array.prototype.slice.call(arguments, 1));\r\n\t\t}\r\n\t\t// makes _methods callable by event name. TODO: kill this\r\n\t\tif (this['_' + name]) {\r\n\t\t\tthis['_' + name].apply(this, Array.prototype.slice.call(arguments, 1));\r\n\t\t}\r\n\t}\r\n\r\n\r\n});\r\n\r\n;;\r\n/*\r\nthis.scrollEl is set in DragListener\r\n*/\r\nDragListener.mixin({\r\n\r\n\tisAutoScroll: false,\r\n\r\n\tscrollBounds: null, // { top, bottom, left, right }\r\n\tscrollTopVel: null, // pixels per second\r\n\tscrollLeftVel: null, // pixels per second\r\n\tscrollIntervalId: null, // ID of setTimeout for scrolling animation loop\r\n\r\n\t// defaults\r\n\tscrollSensitivity: 30, // pixels from edge for scrolling to start\r\n\tscrollSpeed: 200, // pixels per second, at maximum speed\r\n\tscrollIntervalMs: 50, // millisecond wait between scroll increment\r\n\r\n\r\n\tinitAutoScroll: function() {\r\n\t\tvar scrollEl = this.scrollEl;\r\n\r\n\t\tthis.isAutoScroll =\r\n\t\t\tthis.options.scroll &&\r\n\t\t\tscrollEl &&\r\n\t\t\t!scrollEl.is(window) &&\r\n\t\t\t!scrollEl.is(document);\r\n\r\n\t\tif (this.isAutoScroll) {\r\n\t\t\t// debounce makes sure rapid calls don't happen\r\n\t\t\tthis.listenTo(scrollEl, 'scroll', debounce(this.handleDebouncedScroll, 100));\r\n\t\t}\r\n\t},\r\n\r\n\r\n\tdestroyAutoScroll: function() {\r\n\t\tthis.endAutoScroll(); // kill any animation loop\r\n\r\n\t\t// remove the scroll handler if there is a scrollEl\r\n\t\tif (this.isAutoScroll) {\r\n\t\t\tthis.stopListeningTo(this.scrollEl, 'scroll'); // will probably get removed by unbindHandlers too :(\r\n\t\t}\r\n\t},\r\n\r\n\r\n\t// Computes and stores the bounding rectangle of scrollEl\r\n\tcomputeScrollBounds: function() {\r\n\t\tif (this.isAutoScroll) {\r\n\t\t\tthis.scrollBounds = getOuterRect(this.scrollEl);\r\n\t\t\t// TODO: use getClientRect in future. but prevents auto scrolling when on top of scrollbars\r\n\t\t}\r\n\t},\r\n\r\n\r\n\t// Called when the dragging is in progress and scrolling should be updated\r\n\tupdateAutoScroll: function(ev) {\r\n\t\tvar sensitivity = this.scrollSensitivity;\r\n\t\tvar bounds = this.scrollBounds;\r\n\t\tvar topCloseness, bottomCloseness;\r\n\t\tvar leftCloseness, rightCloseness;\r\n\t\tvar topVel = 0;\r\n\t\tvar leftVel = 0;\r\n\r\n\t\tif (bounds) { // only scroll if scrollEl exists\r\n\r\n\t\t\t// compute closeness to edges. valid range is from 0.0 - 1.0\r\n\t\t\ttopCloseness = (sensitivity - (getEvY(ev) - bounds.top)) / sensitivity;\r\n\t\t\tbottomCloseness = (sensitivity - (bounds.bottom - getEvY(ev))) / sensitivity;\r\n\t\t\tleftCloseness = (sensitivity - (getEvX(ev) - bounds.left)) / sensitivity;\r\n\t\t\trightCloseness = (sensitivity - (bounds.right - getEvX(ev))) / sensitivity;\r\n\r\n\t\t\t// translate vertical closeness into velocity.\r\n\t\t\t// mouse must be completely in bounds for velocity to happen.\r\n\t\t\tif (topCloseness >= 0 && topCloseness <= 1) {\r\n\t\t\t\ttopVel = topCloseness * this.scrollSpeed * -1; // negative. for scrolling up\r\n\t\t\t}\r\n\t\t\telse if (bottomCloseness >= 0 && bottomCloseness <= 1) {\r\n\t\t\t\ttopVel = bottomCloseness * this.scrollSpeed;\r\n\t\t\t}\r\n\r\n\t\t\t// translate horizontal closeness into velocity\r\n\t\t\tif (leftCloseness >= 0 && leftCloseness <= 1) {\r\n\t\t\t\tleftVel = leftCloseness * this.scrollSpeed * -1; // negative. for scrolling left\r\n\t\t\t}\r\n\t\t\telse if (rightCloseness >= 0 && rightCloseness <= 1) {\r\n\t\t\t\tleftVel = rightCloseness * this.scrollSpeed;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis.setScrollVel(topVel, leftVel);\r\n\t},\r\n\r\n\r\n\t// Sets the speed-of-scrolling for the scrollEl\r\n\tsetScrollVel: function(topVel, leftVel) {\r\n\r\n\t\tthis.scrollTopVel = topVel;\r\n\t\tthis.scrollLeftVel = leftVel;\r\n\r\n\t\tthis.constrainScrollVel(); // massages into realistic values\r\n\r\n\t\t// if there is non-zero velocity, and an animation loop hasn't already started, then START\r\n\t\tif ((this.scrollTopVel || this.scrollLeftVel) && !this.scrollIntervalId) {\r\n\t\t\tthis.scrollIntervalId = setInterval(\r\n\t\t\t\tproxy(this, 'scrollIntervalFunc'), // scope to `this`\r\n\t\t\t\tthis.scrollIntervalMs\r\n\t\t\t);\r\n\t\t}\r\n\t},\r\n\r\n\r\n\t// Forces scrollTopVel and scrollLeftVel to be zero if scrolling has already gone all the way\r\n\tconstrainScrollVel: function() {\r\n\t\tvar el = this.scrollEl;\r\n\r\n\t\tif (this.scrollTopVel < 0) { // scrolling up?\r\n\t\t\tif (el.scrollTop() <= 0) { // already scrolled all the way up?\r\n\t\t\t\tthis.scrollTopVel = 0;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if (this.scrollTopVel > 0) { // scrolling down?\r\n\t\t\tif (el.scrollTop() + el[0].clientHeight >= el[0].scrollHeight) { // already scrolled all the way down?\r\n\t\t\t\tthis.scrollTopVel = 0;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (this.scrollLeftVel < 0) { // scrolling left?\r\n\t\t\tif (el.scrollLeft() <= 0) { // already scrolled all the left?\r\n\t\t\t\tthis.scrollLeftVel = 0;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if (this.scrollLeftVel > 0) { // scrolling right?\r\n\t\t\tif (el.scrollLeft() + el[0].clientWidth >= el[0].scrollWidth) { // already scrolled all the way right?\r\n\t\t\t\tthis.scrollLeftVel = 0;\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\r\n\t// This function gets called during every iteration of the scrolling animation loop\r\n\tscrollIntervalFunc: function() {\r\n\t\tvar el = this.scrollEl;\r\n\t\tvar frac = this.scrollIntervalMs / 1000; // considering animation frequency, what the vel should be mult'd by\r\n\r\n\t\t// change the value of scrollEl's scroll\r\n\t\tif (this.scrollTopVel) {\r\n\t\t\tel.scrollTop(el.scrollTop() + this.scrollTopVel * frac);\r\n\t\t}\r\n\t\tif (this.scrollLeftVel) {\r\n\t\t\tel.scrollLeft(el.scrollLeft() + this.scrollLeftVel * frac);\r\n\t\t}\r\n\r\n\t\tthis.constrainScrollVel(); // since the scroll values changed, recompute the velocities\r\n\r\n\t\t// if scrolled all the way, which causes the vels to be zero, stop the animation loop\r\n\t\tif (!this.scrollTopVel && !this.scrollLeftVel) {\r\n\t\t\tthis.endAutoScroll();\r\n\t\t}\r\n\t},\r\n\r\n\r\n\t// Kills any existing scrolling animation loop\r\n\tendAutoScroll: function() {\r\n\t\tif (this.scrollIntervalId) {\r\n\t\t\tclearInterval(this.scrollIntervalId);\r\n\t\t\tthis.scrollIntervalId = null;\r\n\r\n\t\t\tthis.handleScrollEnd();\r\n\t\t}\r\n\t},\r\n\r\n\r\n\t// Get called when the scrollEl is scrolled (NOTE: this is delayed via debounce)\r\n\thandleDebouncedScroll: function() {\r\n\t\t// recompute all coordinates, but *only* if this is *not* part of our scrolling animation\r\n\t\tif (!this.scrollIntervalId) {\r\n\t\t\tthis.handleScrollEnd();\r\n\t\t}\r\n\t},\r\n\r\n\r\n\t// Called when scrolling has stopped, whether through auto scroll, or the user scrolling\r\n\thandleScrollEnd: function() {\r\n\t}\r\n\r\n});\r\n;;\r\n\r\n/* Tracks mouse movements over a component and raises events about which hit the mouse is over.\r\n------------------------------------------------------------------------------------------------------------------------\r\noptions:\r\n- subjectEl\r\n- subjectCenter\r\n*/\r\n\r\nvar HitDragListener = DragListener.extend({\r\n\r\n\tcomponent: null, // converts coordinates to hits\r\n\t\t// methods: hitsNeeded, hitsNotNeeded, queryHit\r\n\r\n\torigHit: null, // the hit the mouse was over when listening started\r\n\thit: null, // the hit the mouse is over\r\n\tcoordAdjust: null, // delta that will be added to the mouse coordinates when computing collisions\r\n\r\n\r\n\tconstructor: function(component, options) {\r\n\t\tDragListener.call(this, options); // call the super-constructor\r\n\r\n\t\tthis.component = component;\r\n\t},\r\n\r\n\r\n\t// Called when drag listening starts (but a real drag has not necessarily began).\r\n\t// ev might be undefined if dragging was started manually.\r\n\thandleInteractionStart: function(ev) {\r\n\t\tvar subjectEl = this.subjectEl;\r\n\t\tvar subjectRect;\r\n\t\tvar origPoint;\r\n\t\tvar point;\r\n\r\n\t\tthis.component.hitsNeeded();\r\n\t\tthis.computeScrollBounds(); // for autoscroll\r\n\r\n\t\tif (ev) {\r\n\t\t\torigPoint = { left: getEvX(ev), top: getEvY(ev) };\r\n\t\t\tpoint = origPoint;\r\n\r\n\t\t\t// constrain the point to bounds of the element being dragged\r\n\t\t\tif (subjectEl) {\r\n\t\t\t\tsubjectRect = getOuterRect(subjectEl); // used for centering as well\r\n\t\t\t\tpoint = constrainPoint(point, subjectRect);\r\n\t\t\t}\r\n\r\n\t\t\tthis.origHit = this.queryHit(point.left, point.top);\r\n\r\n\t\t\t// treat the center of the subject as the collision point?\r\n\t\t\tif (subjectEl && this.options.subjectCenter) {\r\n\r\n\t\t\t\t// only consider the area the subject overlaps the hit. best for large subjects.\r\n\t\t\t\t// TODO: skip this if hit didn't supply left/right/top/bottom\r\n\t\t\t\tif (this.origHit) {\r\n\t\t\t\t\tsubjectRect = intersectRects(this.origHit, subjectRect) ||\r\n\t\t\t\t\t\tsubjectRect; // in case there is no intersection\r\n\t\t\t\t}\r\n\r\n\t\t\t\tpoint = getRectCenter(subjectRect);\r\n\t\t\t}\r\n\r\n\t\t\tthis.coordAdjust = diffPoints(point, origPoint); // point - origPoint\r\n\t\t}\r\n\t\telse {\r\n\t\t\tthis.origHit = null;\r\n\t\t\tthis.coordAdjust = null;\r\n\t\t}\r\n\r\n\t\t// call the super-method. do it after origHit has been computed\r\n\t\tDragListener.prototype.handleInteractionStart.apply(this, arguments);\r\n\t},\r\n\r\n\r\n\t// Called when the actual drag has started\r\n\thandleDragStart: function(ev) {\r\n\t\tvar hit;\r\n\r\n\t\tDragListener.prototype.handleDragStart.apply(this, arguments); // call the super-method\r\n\r\n\t\t// might be different from this.origHit if the min-distance is large\r\n\t\thit = this.queryHit(getEvX(ev), getEvY(ev));\r\n\r\n\t\t// report the initial hit the mouse is over\r\n\t\t// especially important if no min-distance and drag starts immediately\r\n\t\tif (hit) {\r\n\t\t\tthis.handleHitOver(hit);\r\n\t\t}\r\n\t},\r\n\r\n\r\n\t// Called when the drag moves\r\n\thandleDrag: function(dx, dy, ev) {\r\n\t\tvar hit;\r\n\r\n\t\tDragListener.prototype.handleDrag.apply(this, arguments); // call the super-method\r\n\r\n\t\thit = this.queryHit(getEvX(ev), getEvY(ev));\r\n\r\n\t\tif (!isHitsEqual(hit, this.hit)) { // a different hit than before?\r\n\t\t\tif (this.hit) {\r\n\t\t\t\tthis.handleHitOut();\r\n\t\t\t}\r\n\t\t\tif (hit) {\r\n\t\t\t\tthis.handleHitOver(hit);\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\r\n\t// Called when dragging has been stopped\r\n\thandleDragEnd: function() {\r\n\t\tthis.handleHitDone();\r\n\t\tDragListener.prototype.handleDragEnd.apply(this, arguments); // call the super-method\r\n\t},\r\n\r\n\r\n\t// Called when a the mouse has just moved over a new hit\r\n\thandleHitOver: function(hit) {\r\n\t\tvar isOrig = isHitsEqual(hit, this.origHit);\r\n\r\n\t\tthis.hit = hit;\r\n\r\n\t\tthis.trigger('hitOver', this.hit, isOrig, this.origHit);\r\n\t},\r\n\r\n\r\n\t// Called when the mouse has just moved out of a hit\r\n\thandleHitOut: function() {\r\n\t\tif (this.hit) {\r\n\t\t\tthis.trigger('hitOut', this.hit);\r\n\t\t\tthis.handleHitDone();\r\n\t\t\tthis.hit = null;\r\n\t\t}\r\n\t},\r\n\r\n\r\n\t// Called after a hitOut. Also called before a dragStop\r\n\thandleHitDone: function() {\r\n\t\tif (this.hit) {\r\n\t\t\tthis.trigger('hitDone', this.hit);\r\n\t\t}\r\n\t},\r\n\r\n\r\n\t// Called when the interaction ends, whether there was a real drag or not\r\n\thandleInteractionEnd: function() {\r\n\t\tDragListener.prototype.handleInteractionEnd.apply(this, arguments); // call the super-method\r\n\r\n\t\tthis.origHit = null;\r\n\t\tthis.hit = null;\r\n\r\n\t\tthis.component.hitsNotNeeded();\r\n\t},\r\n\r\n\r\n\t// Called when scrolling has stopped, whether through auto scroll, or the user scrolling\r\n\thandleScrollEnd: function() {\r\n\t\tDragListener.prototype.handleScrollEnd.apply(this, arguments); // call the super-method\r\n\r\n\t\t// hits' absolute positions will be in new places after a user's scroll.\r\n\t\t// HACK for recomputing.\r\n\t\tif (this.isDragging) {\r\n\t\t\tthis.component.releaseHits();\r\n\t\t\tthis.component.prepareHits();\r\n\t\t}\r\n\t},\r\n\r\n\r\n\t// Gets the hit underneath the coordinates for the given mouse event\r\n\tqueryHit: function(left, top) {\r\n\r\n\t\tif (this.coordAdjust) {\r\n\t\t\tleft += this.coordAdjust.left;\r\n\t\t\ttop += this.coordAdjust.top;\r\n\t\t}\r\n\r\n\t\treturn this.component.queryHit(left, top);\r\n\t}\r\n\r\n});\r\n\r\n\r\n// Returns `true` if the hits are identically equal. `false` otherwise. Must be from the same component.\r\n// Two null values will be considered equal, as two \"out of the component\" states are the same.\r\nfunction isHitsEqual(hit0, hit1) {\r\n\r\n\tif (!hit0 && !hit1) {\r\n\t\treturn true;\r\n\t}\r\n\r\n\tif (hit0 && hit1) {\r\n\t\treturn hit0.component === hit1.component &&\r\n\t\t\tisHitPropsWithin(hit0, hit1) &&\r\n\t\t\tisHitPropsWithin(hit1, hit0); // ensures all props are identical\r\n\t}\r\n\r\n\treturn false;\r\n}\r\n\r\n\r\n// Returns true if all of subHit's non-standard properties are within superHit\r\nfunction isHitPropsWithin(subHit, superHit) {\r\n\tfor (var propName in subHit) {\r\n\t\tif (!/^(component|left|right|top|bottom)$/.test(propName)) {\r\n\t\t\tif (subHit[propName] !== superHit[propName]) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn true;\r\n}\r\n\r\n;;\r\n\r\n/*\r\nListens to document and window-level user-interaction events, like touch events and mouse events,\r\nand fires these events as-is to whoever is observing a GlobalEmitter.\r\nBest when used as a singleton via GlobalEmitter.get()\r\n\r\nNormalizes mouse/touch events. For examples:\r\n- ignores the the simulated mouse events that happen after a quick tap: mousemove+mousedown+mouseup+click\r\n- compensates for various buggy scenarios where a touchend does not fire\r\n*/\r\n\r\nFC.touchMouseIgnoreWait = 500;\r\n\r\nvar GlobalEmitter = Class.extend(ListenerMixin, EmitterMixin, {\r\n\r\n\tisTouching: false,\r\n\tmouseIgnoreDepth: 0,\r\n\thandleScrollProxy: null,\r\n\r\n\r\n\tbind: function() {\r\n\t\tvar _this = this;\r\n\r\n\t\tthis.listenTo($(document), {\r\n\t\t\ttouchstart: this.handleTouchStart,\r\n\t\t\ttouchcancel: this.handleTouchCancel,\r\n\t\t\ttouchend: this.handleTouchEnd,\r\n\t\t\tmousedown: this.handleMouseDown,\r\n\t\t\tmousemove: this.handleMouseMove,\r\n\t\t\tmouseup: this.handleMouseUp,\r\n\t\t\tclick: this.handleClick,\r\n\t\t\tselectstart: this.handleSelectStart,\r\n\t\t\tcontextmenu: this.handleContextMenu\r\n\t\t});\r\n\r\n\t\t// because we need to call preventDefault\r\n\t\t// because https://www.chromestatus.com/features/5093566007214080\r\n\t\t// TODO: investigate performance because this is a global handler\r\n\t\twindow.addEventListener(\r\n\t\t\t'touchmove',\r\n\t\t\tthis.handleTouchMoveProxy = function(ev) {\r\n\t\t\t\t_this.handleTouchMove($.Event(ev));\r\n\t\t\t},\r\n\t\t\t{ passive: false } // allows preventDefault()\r\n\t\t);\r\n\r\n\t\t// attach a handler to get called when ANY scroll action happens on the page.\r\n\t\t// this was impossible to do with normal on/off because 'scroll' doesn't bubble.\r\n\t\t// http://stackoverflow.com/a/32954565/96342\r\n\t\twindow.addEventListener(\r\n\t\t\t'scroll',\r\n\t\t\tthis.handleScrollProxy = function(ev) {\r\n\t\t\t\t_this.handleScroll($.Event(ev));\r\n\t\t\t},\r\n\t\t\ttrue // useCapture\r\n\t\t);\r\n\t},\r\n\r\n\tunbind: function() {\r\n\t\tthis.stopListeningTo($(document));\r\n\r\n\t\twindow.removeEventListener(\r\n\t\t\t'touchmove',\r\n\t\t\tthis.handleTouchMoveProxy\r\n\t\t);\r\n\r\n\t\twindow.removeEventListener(\r\n\t\t\t'scroll',\r\n\t\t\tthis.handleScrollProxy,\r\n\t\t\ttrue // useCapture\r\n\t\t);\r\n\t},\r\n\r\n\r\n\t// Touch Handlers\r\n\t// -----------------------------------------------------------------------------------------------------------------\r\n\r\n\thandleTouchStart: function(ev) {\r\n\r\n\t\t// if a previous touch interaction never ended with a touchend, then implicitly end it,\r\n\t\t// but since a new touch interaction is about to begin, don't start the mouse ignore period.\r\n\t\tthis.stopTouch(ev, true); // skipMouseIgnore=true\r\n\r\n\t\tthis.isTouching = true;\r\n\t\tthis.trigger('touchstart', ev);\r\n\t},\r\n\r\n\thandleTouchMove: function(ev) {\r\n\t\tif (this.isTouching) {\r\n\t\t\tthis.trigger('touchmove', ev);\r\n\t\t}\r\n\t},\r\n\r\n\thandleTouchCancel: function(ev) {\r\n\t\tif (this.isTouching) {\r\n\t\t\tthis.trigger('touchcancel', ev);\r\n\r\n\t\t\t// Have touchcancel fire an artificial touchend. That way, handlers won't need to listen to both.\r\n\t\t\t// If touchend fires later, it won't have any effect b/c isTouching will be false.\r\n\t\t\tthis.stopTouch(ev);\r\n\t\t}\r\n\t},\r\n\r\n\thandleTouchEnd: function(ev) {\r\n\t\tthis.stopTouch(ev);\r\n\t},\r\n\r\n\r\n\t// Mouse Handlers\r\n\t// -----------------------------------------------------------------------------------------------------------------\r\n\r\n\thandleMouseDown: function(ev) {\r\n\t\tif (!this.shouldIgnoreMouse()) {\r\n\t\t\tthis.trigger('mousedown', ev);\r\n\t\t}\r\n\t},\r\n\r\n\thandleMouseMove: function(ev) {\r\n\t\tif (!this.shouldIgnoreMouse()) {\r\n\t\t\tthis.trigger('mousemove', ev);\r\n\t\t}\r\n\t},\r\n\r\n\thandleMouseUp: function(ev) {\r\n\t\tif (!this.shouldIgnoreMouse()) {\r\n\t\t\tthis.trigger('mouseup', ev);\r\n\t\t}\r\n\t},\r\n\r\n\thandleClick: function(ev) {\r\n\t\tif (!this.shouldIgnoreMouse()) {\r\n\t\t\tthis.trigger('click', ev);\r\n\t\t}\r\n\t},\r\n\r\n\r\n\t// Misc Handlers\r\n\t// -----------------------------------------------------------------------------------------------------------------\r\n\r\n\thandleSelectStart: function(ev) {\r\n\t\tthis.trigger('selectstart', ev);\r\n\t},\r\n\r\n\thandleContextMenu: function(ev) {\r\n\t\tthis.trigger('contextmenu', ev);\r\n\t},\r\n\r\n\thandleScroll: function(ev) {\r\n\t\tthis.trigger('scroll', ev);\r\n\t},\r\n\r\n\r\n\t// Utils\r\n\t// -----------------------------------------------------------------------------------------------------------------\r\n\r\n\tstopTouch: function(ev, skipMouseIgnore) {\r\n\t\tif (this.isTouching) {\r\n\t\t\tthis.isTouching = false;\r\n\t\t\tthis.trigger('touchend', ev);\r\n\r\n\t\t\tif (!skipMouseIgnore) {\r\n\t\t\t\tthis.startTouchMouseIgnore();\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\tstartTouchMouseIgnore: function() {\r\n\t\tvar _this = this;\r\n\t\tvar wait = FC.touchMouseIgnoreWait;\r\n\r\n\t\tif (wait) {\r\n\t\t\tthis.mouseIgnoreDepth++;\r\n\t\t\tsetTimeout(function() {\r\n\t\t\t\t_this.mouseIgnoreDepth--;\r\n\t\t\t}, wait);\r\n\t\t}\r\n\t},\r\n\r\n\tshouldIgnoreMouse: function() {\r\n\t\treturn this.isTouching || Boolean(this.mouseIgnoreDepth);\r\n\t}\r\n\r\n});\r\n\r\n\r\n// Singleton\r\n// ---------------------------------------------------------------------------------------------------------------------\r\n\r\n(function() {\r\n\tvar globalEmitter = null;\r\n\tvar neededCount = 0;\r\n\r\n\r\n\t// gets the singleton\r\n\tGlobalEmitter.get = function() {\r\n\r\n\t\tif (!globalEmitter) {\r\n\t\t\tglobalEmitter = new GlobalEmitter();\r\n\t\t\tglobalEmitter.bind();\r\n\t\t}\r\n\r\n\t\treturn globalEmitter;\r\n\t};\r\n\r\n\r\n\t// called when an object knows it will need a GlobalEmitter in the near future.\r\n\tGlobalEmitter.needed = function() {\r\n\t\tGlobalEmitter.get(); // ensures globalEmitter\r\n\t\tneededCount++;\r\n\t};\r\n\r\n\r\n\t// called when the object that originally called needed() doesn't need a GlobalEmitter anymore.\r\n\tGlobalEmitter.unneeded = function() {\r\n\t\tneededCount--;\r\n\r\n\t\tif (!neededCount) { // nobody else needs it\r\n\t\t\tglobalEmitter.unbind();\r\n\t\t\tglobalEmitter = null;\r\n\t\t}\r\n\t};\r\n\r\n})();\r\n\r\n;;\r\n\r\n/* Creates a clone of an element and lets it track the mouse as it moves\r\n----------------------------------------------------------------------------------------------------------------------*/\r\n\r\nvar MouseFollower = Class.extend(ListenerMixin, {\r\n\r\n\toptions: null,\r\n\r\n\tsourceEl: null, // the element that will be cloned and made to look like it is dragging\r\n\tel: null, // the clone of `sourceEl` that will track the mouse\r\n\tparentEl: null, // the element that `el` (the clone) will be attached to\r\n\r\n\t// the initial position of el, relative to the offset parent. made to match the initial offset of sourceEl\r\n\ttop0: null,\r\n\tleft0: null,\r\n\r\n\t// the absolute coordinates of the initiating touch/mouse action\r\n\ty0: null,\r\n\tx0: null,\r\n\r\n\t// the number of pixels the mouse has moved from its initial position\r\n\ttopDelta: null,\r\n\tleftDelta: null,\r\n\r\n\tisFollowing: false,\r\n\tisHidden: false,\r\n\tisAnimating: false, // doing the revert animation?\r\n\r\n\tconstructor: function(sourceEl, options) {\r\n\t\tthis.options = options = options || {};\r\n\t\tthis.sourceEl = sourceEl;\r\n\t\tthis.parentEl = options.parentEl ? $(options.parentEl) : sourceEl.parent(); // default to sourceEl's parent\r\n\t},\r\n\r\n\r\n\t// Causes the element to start following the mouse\r\n\tstart: function(ev) {\r\n\t\tif (!this.isFollowing) {\r\n\t\t\tthis.isFollowing = true;\r\n\r\n\t\t\tthis.y0 = getEvY(ev);\r\n\t\t\tthis.x0 = getEvX(ev);\r\n\t\t\tthis.topDelta = 0;\r\n\t\t\tthis.leftDelta = 0;\r\n\r\n\t\t\tif (!this.isHidden) {\r\n\t\t\t\tthis.updatePosition();\r\n\t\t\t}\r\n\r\n\t\t\tif (getEvIsTouch(ev)) {\r\n\t\t\t\tthis.listenTo($(document), 'touchmove', this.handleMove);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tthis.listenTo($(document), 'mousemove', this.handleMove);\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\r\n\t// Causes the element to stop following the mouse. If shouldRevert is true, will animate back to original position.\r\n\t// `callback` gets invoked when the animation is complete. If no animation, it is invoked immediately.\r\n\tstop: function(shouldRevert, callback) {\r\n\t\tvar _this = this;\r\n\t\tvar revertDuration = this.options.revertDuration;\r\n\r\n\t\tfunction complete() { // might be called by .animate(), which might change `this` context\r\n\t\t\t_this.isAnimating = false;\r\n\t\t\t_this.removeElement();\r\n\r\n\t\t\t_this.top0 = _this.left0 = null; // reset state for future updatePosition calls\r\n\r\n\t\t\tif (callback) {\r\n\t\t\t\tcallback();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (this.isFollowing && !this.isAnimating) { // disallow more than one stop animation at a time\r\n\t\t\tthis.isFollowing = false;\r\n\r\n\t\t\tthis.stopListeningTo($(document));\r\n\r\n\t\t\tif (shouldRevert && revertDuration && !this.isHidden) { // do a revert animation?\r\n\t\t\t\tthis.isAnimating = true;\r\n\t\t\t\tthis.el.animate({\r\n\t\t\t\t\ttop: this.top0,\r\n\t\t\t\t\tleft: this.left0\r\n\t\t\t\t}, {\r\n\t\t\t\t\tduration: revertDuration,\r\n\t\t\t\t\tcomplete: complete\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tcomplete();\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\r\n\t// Gets the tracking element. Create it if necessary\r\n\tgetEl: function() {\r\n\t\tvar el = this.el;\r\n\r\n\t\tif (!el) {\r\n\t\t\tel = this.el = this.sourceEl.clone()\r\n\t\t\t\t.addClass(this.options.additionalClass || '')\r\n\t\t\t\t.css({\r\n\t\t\t\t\tposition: 'absolute',\r\n\t\t\t\t\tvisibility: '', // in case original element was hidden (commonly through hideEvents())\r\n\t\t\t\t\tdisplay: this.isHidden ? 'none' : '', // for when initially hidden\r\n\t\t\t\t\tmargin: 0,\r\n\t\t\t\t\tright: 'auto', // erase and set width instead\r\n\t\t\t\t\tbottom: 'auto', // erase and set height instead\r\n\t\t\t\t\twidth: this.sourceEl.width(), // explicit height in case there was a 'right' value\r\n\t\t\t\t\theight: this.sourceEl.height(), // explicit width in case there was a 'bottom' value\r\n\t\t\t\t\topacity: this.options.opacity || '',\r\n\t\t\t\t\tzIndex: this.options.zIndex\r\n\t\t\t\t});\r\n\r\n\t\t\t// we don't want long taps or any mouse interaction causing selection/menus.\r\n\t\t\t// would use preventSelection(), but that prevents selectstart, causing problems.\r\n\t\t\tel.addClass('fc-unselectable');\r\n\r\n\t\t\tel.appendTo(this.parentEl);\r\n\t\t}\r\n\r\n\t\treturn el;\r\n\t},\r\n\r\n\r\n\t// Removes the tracking element if it has already been created\r\n\tremoveElement: function() {\r\n\t\tif (this.el) {\r\n\t\t\tthis.el.remove();\r\n\t\t\tthis.el = null;\r\n\t\t}\r\n\t},\r\n\r\n\r\n\t// Update the CSS position of the tracking element\r\n\tupdatePosition: function() {\r\n\t\tvar sourceOffset;\r\n\t\tvar origin;\r\n\r\n\t\tthis.getEl(); // ensure this.el\r\n\r\n\t\t// make sure origin info was computed\r\n\t\tif (this.top0 === null) {\r\n\t\t\tsourceOffset = this.sourceEl.offset();\r\n\t\t\torigin = this.el.offsetParent().offset();\r\n\t\t\tthis.top0 = sourceOffset.top - origin.top;\r\n\t\t\tthis.left0 = sourceOffset.left - origin.left;\r\n\t\t}\r\n\r\n\t\tthis.el.css({\r\n\t\t\ttop: this.top0 + this.topDelta,\r\n\t\t\tleft: this.left0 + this.leftDelta\r\n\t\t});\r\n\t},\r\n\r\n\r\n\t// Gets called when the user moves the mouse\r\n\thandleMove: function(ev) {\r\n\t\tthis.topDelta = getEvY(ev) - this.y0;\r\n\t\tthis.leftDelta = getEvX(ev) - this.x0;\r\n\r\n\t\tif (!this.isHidden) {\r\n\t\t\tthis.updatePosition();\r\n\t\t}\r\n\t},\r\n\r\n\r\n\t// Temporarily makes the tracking element invisible. Can be called before following starts\r\n\thide: function() {\r\n\t\tif (!this.isHidden) {\r\n\t\t\tthis.isHidden = true;\r\n\t\t\tif (this.el) {\r\n\t\t\t\tthis.el.hide();\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\r\n\t// Show the tracking element after it has been temporarily hidden\r\n\tshow: function() {\r\n\t\tif (this.isHidden) {\r\n\t\t\tthis.isHidden = false;\r\n\t\t\tthis.updatePosition();\r\n\t\t\tthis.getEl().show();\r\n\t\t}\r\n\t}\r\n\r\n});\r\n\r\n;;\r\n\r\n/*\r\nEmbodies a div that has potential scrollbars\r\n*/\r\nvar Scroller = FC.Scroller = Class.extend({\r\n\r\n\tel: null, // the guaranteed outer element\r\n\tscrollEl: null, // the element with the scrollbars\r\n\toverflowX: null,\r\n\toverflowY: null,\r\n\r\n\r\n\tconstructor: function(options) {\r\n\t\toptions = options || {};\r\n\t\tthis.overflowX = options.overflowX || options.overflow || 'auto';\r\n\t\tthis.overflowY = options.overflowY || options.overflow || 'auto';\r\n\t},\r\n\r\n\r\n\trender: function() {\r\n\t\tthis.el = this.renderEl();\r\n\t\tthis.applyOverflow();\r\n\t},\r\n\r\n\r\n\trenderEl: function() {\r\n\t\treturn (this.scrollEl = $('<div class=\"fc-scroller\"></div>'));\r\n\t},\r\n\r\n\r\n\t// sets to natural height, unlocks overflow\r\n\tclear: function() {\r\n\t\tthis.setHeight('auto');\r\n\t\tthis.applyOverflow();\r\n\t},\r\n\r\n\r\n\tdestroy: function() {\r\n\t\tthis.el.remove();\r\n\t},\r\n\r\n\r\n\t// Overflow\r\n\t// -----------------------------------------------------------------------------------------------------------------\r\n\r\n\r\n\tapplyOverflow: function() {\r\n\t\tthis.scrollEl.css({\r\n\t\t\t'overflow-x': this.overflowX,\r\n\t\t\t'overflow-y': this.overflowY\r\n\t\t});\r\n\t},\r\n\r\n\r\n\t// Causes any 'auto' overflow values to resolves to 'scroll' or 'hidden'.\r\n\t// Useful for preserving scrollbar widths regardless of future resizes.\r\n\t// Can pass in scrollbarWidths for optimization.\r\n\tlockOverflow: function(scrollbarWidths) {\r\n\t\tvar overflowX = this.overflowX;\r\n\t\tvar overflowY = this.overflowY;\r\n\r\n\t\tscrollbarWidths = scrollbarWidths || this.getScrollbarWidths();\r\n\r\n\t\tif (overflowX === 'auto') {\r\n\t\t\toverflowX = (\r\n\t\t\t\t\tscrollbarWidths.top || scrollbarWidths.bottom || // horizontal scrollbars?\r\n\t\t\t\t\t// OR scrolling pane with massless scrollbars?\r\n\t\t\t\t\tthis.scrollEl[0].scrollWidth - 1 > this.scrollEl[0].clientWidth\r\n\t\t\t\t\t\t// subtract 1 because of IE off-by-one issue\r\n\t\t\t\t) ? 'scroll' : 'hidden';\r\n\t\t}\r\n\r\n\t\tif (overflowY === 'auto') {\r\n\t\t\toverflowY = (\r\n\t\t\t\t\tscrollbarWidths.left || scrollbarWidths.right || // vertical scrollbars?\r\n\t\t\t\t\t// OR scrolling pane with massless scrollbars?\r\n\t\t\t\t\tthis.scrollEl[0].scrollHeight - 1 > this.scrollEl[0].clientHeight\r\n\t\t\t\t\t\t// subtract 1 because of IE off-by-one issue\r\n\t\t\t\t) ? 'scroll' : 'hidden';\r\n\t\t}\r\n\r\n\t\tthis.scrollEl.css({ 'overflow-x': overflowX, 'overflow-y': overflowY });\r\n\t},\r\n\r\n\r\n\t// Getters / Setters\r\n\t// -----------------------------------------------------------------------------------------------------------------\r\n\r\n\r\n\tsetHeight: function(height) {\r\n\t\tthis.scrollEl.height(height);\r\n\t},\r\n\r\n\r\n\tgetScrollTop: function() {\r\n\t\treturn this.scrollEl.scrollTop();\r\n\t},\r\n\r\n\r\n\tsetScrollTop: function(top) {\r\n\t\tthis.scrollEl.scrollTop(top);\r\n\t},\r\n\r\n\r\n\tgetClientWidth: function() {\r\n\t\treturn this.scrollEl[0].clientWidth;\r\n\t},\r\n\r\n\r\n\tgetClientHeight: function() {\r\n\t\treturn this.scrollEl[0].clientHeight;\r\n\t},\r\n\r\n\r\n\tgetScrollbarWidths: function() {\r\n\t\treturn getScrollbarWidths(this.scrollEl);\r\n\t}\r\n\r\n});\r\n\r\n;;\r\nfunction Iterator(items) {\r\n    this.items = items || [];\r\n}\r\n\r\n\r\n/* Calls a method on every item passing the arguments through */\r\nIterator.prototype.proxyCall = function(methodName) {\r\n    var args = Array.prototype.slice.call(arguments, 1);\r\n    var results = [];\r\n\r\n    this.items.forEach(function(item) {\r\n        results.push(item[methodName].apply(item, args));\r\n    });\r\n\r\n    return results;\r\n};\r\n\r\n;;\r\n\r\nvar Interaction = Class.extend({\r\n\r\n\tview: null,\r\n\tcomponent: null,\r\n\r\n\r\n\tconstructor: function(component) {\r\n\t\tthis.view = component._getView();\r\n\t\tthis.component = component;\r\n\t},\r\n\r\n\r\n\topt: function(name) {\r\n\t\treturn this.view.opt(name);\r\n\t},\r\n\r\n\r\n\tend: function() {\r\n\t\t// subclasses can implement\r\n\t}\r\n\r\n});\r\n\r\n;;\r\n\r\nvar DateClicking = Interaction.extend({\r\n\r\n\tdragListener: null,\r\n\r\n\r\n\t/*\r\n\tcomponent must implement:\r\n\t\t- bindDateHandlerToEl\r\n\t\t- getSafeHitFootprint\r\n\t\t- getHitEl\r\n\t*/\r\n\tconstructor: function(component) {\r\n\t\tInteraction.call(this, component);\r\n\r\n\t\tthis.dragListener = this.buildDragListener();\r\n\t},\r\n\r\n\r\n\tend: function() {\r\n\t\tthis.dragListener.endInteraction();\r\n\t},\r\n\r\n\r\n\tbindToEl: function(el) {\r\n\t\tvar component = this.component;\r\n\t\tvar dragListener = this.dragListener;\r\n\r\n\t\tcomponent.bindDateHandlerToEl(el, 'mousedown', function(ev) {\r\n\t\t\tif (!component.shouldIgnoreMouse()) {\r\n\t\t\t\tdragListener.startInteraction(ev);\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tcomponent.bindDateHandlerToEl(el, 'touchstart', function(ev) {\r\n\t\t\tif (!component.shouldIgnoreTouch()) {\r\n\t\t\t\tdragListener.startInteraction(ev);\r\n\t\t\t}\r\n\t\t});\r\n\t},\r\n\r\n\r\n\t// Creates a listener that tracks the user's drag across day elements, for day clicking.\r\n\tbuildDragListener: function() {\r\n\t\tvar _this = this;\r\n\t\tvar component = this.component;\r\n\t\tvar dayClickHit; // null if invalid dayClick\r\n\r\n\t\tvar dragListener = new HitDragListener(component, {\r\n\t\t\tscroll: this.opt('dragScroll'),\r\n\t\t\tinteractionStart: function() {\r\n\t\t\t\tdayClickHit = dragListener.origHit;\r\n\t\t\t},\r\n\t\t\thitOver: function(hit, isOrig, origHit) {\r\n\t\t\t\t// if user dragged to another cell at any point, it can no longer be a dayClick\r\n\t\t\t\tif (!isOrig) {\r\n\t\t\t\t\tdayClickHit = null;\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\thitOut: function() { // called before mouse moves to a different hit OR moved out of all hits\r\n\t\t\t\tdayClickHit = null;\r\n\t\t\t},\r\n\t\t\tinteractionEnd: function(ev, isCancelled) {\r\n\t\t\t\tvar componentFootprint;\r\n\r\n\t\t\t\tif (!isCancelled && dayClickHit) {\r\n\t\t\t\t\tcomponentFootprint = component.getSafeHitFootprint(dayClickHit);\r\n\r\n\t\t\t\t\tif (componentFootprint) {\r\n\t\t\t\t\t\t_this.view.triggerDayClick(componentFootprint, component.getHitEl(dayClickHit), ev);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\t// because dragListener won't be called with any time delay, \"dragging\" will begin immediately,\r\n\t\t// which will kill any touchmoving/scrolling. Prevent this.\r\n\t\tdragListener.shouldCancelTouchScroll = false;\r\n\r\n\t\tdragListener.scrollAlwaysKills = true;\r\n\r\n\t\treturn dragListener;\r\n\t}\r\n\r\n});\r\n\r\n;;\r\n\r\nvar DateSelecting = FC.DateSelecting = Interaction.extend({\r\n\r\n\tdragListener: null,\r\n\r\n\r\n\t/*\r\n\tcomponent must implement:\r\n\t\t- bindDateHandlerToEl\r\n\t\t- getSafeHitFootprint\r\n\t\t- renderHighlight\r\n\t\t- unrenderHighlight\r\n\t*/\r\n\tconstructor: function(component) {\r\n\t\tInteraction.call(this, component);\r\n\r\n\t\tthis.dragListener = this.buildDragListener();\r\n\t},\r\n\r\n\r\n\tend: function() {\r\n\t\tthis.dragListener.endInteraction();\r\n\t},\r\n\r\n\r\n\tgetDelay: function() {\r\n\t\tvar delay = this.opt('selectLongPressDelay');\r\n\r\n\t\tif (delay == null) {\r\n\t\t\tdelay = this.opt('longPressDelay'); // fallback\r\n\t\t}\r\n\r\n\t\treturn delay;\r\n\t},\r\n\r\n\r\n\tbindToEl: function(el) {\r\n\t\tvar _this = this;\r\n\t\tvar component = this.component;\r\n\t\tvar dragListener = this.dragListener;\r\n\r\n\t\tcomponent.bindDateHandlerToEl(el, 'mousedown', function(ev) {\r\n\t\t\tif (_this.opt('selectable') && !component.shouldIgnoreMouse()) {\r\n\t\t\t\tdragListener.startInteraction(ev, {\r\n\t\t\t\t\tdistance: _this.opt('selectMinDistance')\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tcomponent.bindDateHandlerToEl(el, 'touchstart', function(ev) {\r\n\t\t\tif (_this.opt('selectable') && !component.shouldIgnoreTouch()) {\r\n\t\t\t\tdragListener.startInteraction(ev, {\r\n\t\t\t\t\tdelay: _this.getDelay()\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tpreventSelection(el);\r\n\t},\r\n\r\n\r\n\t// Creates a listener that tracks the user's drag across day elements, for day selecting.\r\n\tbuildDragListener: function() {\r\n\t\tvar _this = this;\r\n\t\tvar component = this.component;\r\n\t\tvar selectionFootprint; // null if invalid selection\r\n\r\n\t\tvar dragListener = new HitDragListener(component, {\r\n\t\t\tscroll: this.opt('dragScroll'),\r\n\t\t\tinteractionStart: function() {\r\n\t\t\t\tselectionFootprint = null;\r\n\t\t\t},\r\n\t\t\tdragStart: function(ev) {\r\n\t\t\t\t_this.view.unselect(ev); // since we could be rendering a new selection, we want to clear any old one\r\n\t\t\t},\r\n\t\t\thitOver: function(hit, isOrig, origHit) {\r\n\t\t\t\tvar origHitFootprint;\r\n\t\t\t\tvar hitFootprint;\r\n\r\n\t\t\t\tif (origHit) { // click needs to have started on a hit\r\n\r\n\t\t\t\t\torigHitFootprint = component.getSafeHitFootprint(origHit);\r\n\t\t\t\t\thitFootprint = component.getSafeHitFootprint(hit);\r\n\r\n\t\t\t\t\tif (origHitFootprint && hitFootprint) {\r\n\t\t\t\t\t\tselectionFootprint = _this.computeSelection(origHitFootprint, hitFootprint);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tselectionFootprint = null;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (selectionFootprint) {\r\n\t\t\t\t\t\tcomponent.renderSelectionFootprint(selectionFootprint);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if (selectionFootprint === false) {\r\n\t\t\t\t\t\tdisableCursor();\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\thitOut: function() { // called before mouse moves to a different hit OR moved out of all hits\r\n\t\t\t\tselectionFootprint = null;\r\n\t\t\t\tcomponent.unrenderSelection();\r\n\t\t\t},\r\n\t\t\thitDone: function() { // called after a hitOut OR before a dragEnd\r\n\t\t\t\tenableCursor();\r\n\t\t\t},\r\n\t\t\tinteractionEnd: function(ev, isCancelled) {\r\n\t\t\t\tif (!isCancelled && selectionFootprint) {\r\n\t\t\t\t\t// the selection will already have been rendered. just report it\r\n\t\t\t\t\t_this.view.reportSelection(selectionFootprint, ev);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\treturn dragListener;\r\n\t},\r\n\r\n\r\n\t// Given the first and last date-spans of a selection, returns another date-span object.\r\n\t// Subclasses can override and provide additional data in the span object. Will be passed to renderSelectionFootprint().\r\n\t// Will return false if the selection is invalid and this should be indicated to the user.\r\n\t// Will return null/undefined if a selection invalid but no error should be reported.\r\n\tcomputeSelection: function(footprint0, footprint1) {\r\n\t\tvar wholeFootprint = this.computeSelectionFootprint(footprint0, footprint1);\r\n\r\n\t\tif (wholeFootprint && !this.isSelectionFootprintAllowed(wholeFootprint)) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\treturn wholeFootprint;\r\n\t},\r\n\r\n\r\n\t// Given two spans, must return the combination of the two.\r\n\t// TODO: do this separation of concerns (combining VS validation) for event dnd/resize too.\r\n\t// Assumes both footprints are non-open-ended.\r\n\tcomputeSelectionFootprint: function(footprint0, footprint1) {\r\n\t\tvar ms = [\r\n\t\t\tfootprint0.unzonedRange.startMs,\r\n\t\t\tfootprint0.unzonedRange.endMs,\r\n\t\t\tfootprint1.unzonedRange.startMs,\r\n\t\t\tfootprint1.unzonedRange.endMs\r\n\t\t];\r\n\r\n\t\tms.sort(compareNumbers);\r\n\r\n\t\treturn new ComponentFootprint(\r\n\t\t\tnew UnzonedRange(ms[0], ms[3]),\r\n\t\t\tfootprint0.isAllDay\r\n\t\t);\r\n\t},\r\n\r\n\r\n\tisSelectionFootprintAllowed: function(componentFootprint) {\r\n\t\treturn this.component.dateProfile.validUnzonedRange.containsRange(componentFootprint.unzonedRange) &&\r\n\t\t\tthis.view.calendar.isSelectionFootprintAllowed(componentFootprint);\r\n\t}\r\n\r\n});\r\n\r\n;;\r\n\r\nvar EventDragging = FC.EventDragging = Interaction.extend({\r\n\r\n\teventPointing: null,\r\n\tdragListener: null,\r\n\tisDragging: false,\r\n\r\n\r\n\t/*\r\n\tcomponent implements:\r\n\t\t- bindSegHandlerToEl\r\n\t\t- publiclyTrigger\r\n\t\t- diffDates\r\n\t\t- eventRangesToEventFootprints\r\n\t\t- isEventInstanceGroupAllowed\r\n\t*/\r\n\tconstructor: function(component, eventPointing) {\r\n\t\tInteraction.call(this, component);\r\n\r\n\t\tthis.eventPointing = eventPointing;\r\n\t},\r\n\r\n\r\n\tend: function() {\r\n\t\tif (this.dragListener) {\r\n\t\t\tthis.dragListener.endInteraction();\r\n\t\t}\r\n\t},\r\n\r\n\r\n\tgetSelectionDelay: function() {\r\n\t\tvar delay = this.opt('eventLongPressDelay');\r\n\r\n\t\tif (delay == null) {\r\n\t\t\tdelay = this.opt('longPressDelay'); // fallback\r\n\t\t}\r\n\r\n\t\treturn delay;\r\n\t},\r\n\r\n\r\n\tbindToEl: function(el) {\r\n\t\tvar component = this.component;\r\n\r\n\t\tcomponent.bindSegHandlerToEl(el, 'mousedown', this.handleMousedown.bind(this));\r\n\t\tcomponent.bindSegHandlerToEl(el, 'touchstart', this.handleTouchStart.bind(this));\r\n\t},\r\n\r\n\r\n\thandleMousedown: function(seg, ev) {\r\n\t\tif (this.component.canStartDrag(seg, ev)) {\r\n\t\t\tthis.buildDragListener(seg).startInteraction(ev, { distance: 5 });\r\n\t\t}\r\n\t},\r\n\r\n\r\n\thandleTouchStart: function(seg, ev) {\r\n\t\tvar component = this.component;\r\n\t\tvar settings = {\r\n\t\t\tdelay: this.view.isEventDefSelected(seg.footprint.eventDef) ? // already selected?\r\n\t\t\t\t0 : this.getSelectionDelay()\r\n\t\t};\r\n\r\n\t\tif (component.canStartDrag(seg, ev)) {\r\n\t\t\tthis.buildDragListener(seg).startInteraction(ev, settings);\r\n\t\t}\r\n\t\telse if (component.canStartSelection(seg, ev)) {\r\n\t\t\tthis.buildSelectListener(seg).startInteraction(ev, settings);\r\n\t\t}\r\n\t},\r\n\r\n\r\n\t// seg isn't draggable, but let's use a generic DragListener\r\n\t// simply for the delay, so it can be selected.\r\n\t// Has side effect of setting/unsetting `dragListener`\r\n\tbuildSelectListener: function(seg) {\r\n\t\tvar _this = this;\r\n\t\tvar view = this.view;\r\n\t\tvar eventDef = seg.footprint.eventDef;\r\n\t\tvar eventInstance = seg.footprint.eventInstance; // null for inverse-background events\r\n\r\n\t\tif (this.dragListener) {\r\n\t\t\treturn this.dragListener;\r\n\t\t}\r\n\r\n\t\tvar dragListener = this.dragListener = new DragListener({\r\n\t\t\tdragStart: function(ev) {\r\n\t\t\t\tif (\r\n\t\t\t\t\tdragListener.isTouch &&\r\n\t\t\t\t\t!view.isEventDefSelected(eventDef) &&\r\n\t\t\t\t\teventInstance\r\n\t\t\t\t) {\r\n\t\t\t\t\t// if not previously selected, will fire after a delay. then, select the event\r\n\t\t\t\t\tview.selectEventInstance(eventInstance);\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tinteractionEnd: function(ev) {\r\n\t\t\t\t_this.dragListener = null;\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\treturn dragListener;\r\n\t},\r\n\r\n\r\n\t// Builds a listener that will track user-dragging on an event segment.\r\n\t// Generic enough to work with any type of Grid.\r\n\t// Has side effect of setting/unsetting `dragListener`\r\n\tbuildDragListener: function(seg) {\r\n\t\tvar _this = this;\r\n\t\tvar component = this.component;\r\n\t\tvar view = this.view;\r\n\t\tvar calendar = view.calendar;\r\n\t\tvar eventManager = calendar.eventManager;\r\n\t\tvar el = seg.el;\r\n\t\tvar eventDef = seg.footprint.eventDef;\r\n\t\tvar eventInstance = seg.footprint.eventInstance; // null for inverse-background events\r\n\t\tvar isDragging;\r\n\t\tvar mouseFollower; // A clone of the original element that will move with the mouse\r\n\t\tvar eventDefMutation;\r\n\r\n\t\tif (this.dragListener) {\r\n\t\t\treturn this.dragListener;\r\n\t\t}\r\n\r\n\t\t// Tracks mouse movement over the *view's* coordinate map. Allows dragging and dropping between subcomponents\r\n\t\t// of the view.\r\n\t\tvar dragListener = this.dragListener = new HitDragListener(view, {\r\n\t\t\tscroll: this.opt('dragScroll'),\r\n\t\t\tsubjectEl: el,\r\n\t\t\tsubjectCenter: true,\r\n\t\t\tinteractionStart: function(ev) {\r\n\t\t\t\tseg.component = component; // for renderDrag\r\n\t\t\t\tisDragging = false;\r\n\t\t\t\tmouseFollower = new MouseFollower(seg.el, {\r\n\t\t\t\t\tadditionalClass: 'fc-dragging',\r\n\t\t\t\t\tparentEl: view.el,\r\n\t\t\t\t\topacity: dragListener.isTouch ? null : _this.opt('dragOpacity'),\r\n\t\t\t\t\trevertDuration: _this.opt('dragRevertDuration'),\r\n\t\t\t\t\tzIndex: 2 // one above the .fc-view\r\n\t\t\t\t});\r\n\t\t\t\tmouseFollower.hide(); // don't show until we know this is a real drag\r\n\t\t\t\tmouseFollower.start(ev);\r\n\t\t\t},\r\n\t\t\tdragStart: function(ev) {\r\n\t\t\t\tif (\r\n\t\t\t\t\tdragListener.isTouch &&\r\n\t\t\t\t\t!view.isEventDefSelected(eventDef) &&\r\n\t\t\t\t\teventInstance\r\n\t\t\t\t) {\r\n\t\t\t\t\t// if not previously selected, will fire after a delay. then, select the event\r\n\t\t\t\t\tview.selectEventInstance(eventInstance);\r\n\t\t\t\t}\r\n\t\t\t\tisDragging = true;\r\n\r\n\t\t\t\t// ensure a mouseout on the manipulated event has been reported\r\n\t\t\t\t_this.eventPointing.handleMouseout(seg, ev);\r\n\r\n\t\t\t\t_this.segDragStart(seg, ev);\r\n\t\t\t\tview.hideEventsWithId(seg.footprint.eventDef.id);\r\n\t\t\t},\r\n\t\t\thitOver: function(hit, isOrig, origHit) {\r\n\t\t\t\tvar isAllowed = true;\r\n\t\t\t\tvar origFootprint;\r\n\t\t\t\tvar footprint;\r\n\t\t\t\tvar mutatedEventInstanceGroup;\r\n\r\n\t\t\t\t// starting hit could be forced (DayGrid.limit)\r\n\t\t\t\tif (seg.hit) {\r\n\t\t\t\t\torigHit = seg.hit;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// hit might not belong to this grid, so query origin grid\r\n\t\t\t\torigFootprint = origHit.component.getSafeHitFootprint(origHit);\r\n\t\t\t\tfootprint = hit.component.getSafeHitFootprint(hit);\r\n\r\n\t\t\t\tif (origFootprint && footprint) {\r\n\t\t\t\t\teventDefMutation = _this.computeEventDropMutation(origFootprint, footprint, eventDef);\r\n\r\n\t\t\t\t\tif (eventDefMutation) {\r\n\t\t\t\t\t\tmutatedEventInstanceGroup = eventManager.buildMutatedEventInstanceGroup(\r\n\t\t\t\t\t\t\teventDef.id,\r\n\t\t\t\t\t\t\teventDefMutation\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\t\tisAllowed = component.isEventInstanceGroupAllowed(mutatedEventInstanceGroup);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tisAllowed = false;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tisAllowed = false;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (!isAllowed) {\r\n\t\t\t\t\teventDefMutation = null;\r\n\t\t\t\t\tdisableCursor();\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// if a valid drop location, have the subclass render a visual indication\r\n\t\t\t\tif (\r\n\t\t\t\t\teventDefMutation &&\r\n\t\t\t\t\tview.renderDrag( // truthy if rendered something\r\n\t\t\t\t\t\tcomponent.eventRangesToEventFootprints(\r\n\t\t\t\t\t\t\tmutatedEventInstanceGroup.sliceRenderRanges(component.dateProfile.renderUnzonedRange, calendar)\r\n\t\t\t\t\t\t),\r\n\t\t\t\t\t\tseg,\r\n\t\t\t\t\t\tdragListener.isTouch\r\n\t\t\t\t\t)\r\n\t\t\t\t) {\r\n\t\t\t\t\tmouseFollower.hide(); // if the subclass is already using a mock event \"helper\", hide our own\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tmouseFollower.show(); // otherwise, have the helper follow the mouse (no snapping)\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (isOrig) {\r\n\t\t\t\t\t// needs to have moved hits to be a valid drop\r\n\t\t\t\t\teventDefMutation = null;\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\thitOut: function() { // called before mouse moves to a different hit OR moved out of all hits\r\n\t\t\t\tview.unrenderDrag(seg); // unrender whatever was done in renderDrag\r\n\t\t\t\tmouseFollower.show(); // show in case we are moving out of all hits\r\n\t\t\t\teventDefMutation = null;\r\n\t\t\t},\r\n\t\t\thitDone: function() { // Called after a hitOut OR before a dragEnd\r\n\t\t\t\tenableCursor();\r\n\t\t\t},\r\n\t\t\tinteractionEnd: function(ev) {\r\n\t\t\t\tdelete seg.component; // prevent side effects\r\n\r\n\t\t\t\t// do revert animation if hasn't changed. calls a callback when finished (whether animation or not)\r\n\t\t\t\tmouseFollower.stop(!eventDefMutation, function() {\r\n\t\t\t\t\tif (isDragging) {\r\n\t\t\t\t\t\tview.unrenderDrag(seg);\r\n\t\t\t\t\t\t_this.segDragStop(seg, ev);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tview.showEventsWithId(seg.footprint.eventDef.id);\r\n\r\n\t\t\t\t\tif (eventDefMutation) {\r\n\t\t\t\t\t\t// no need to re-show original, will rerender all anyways. esp important if eventRenderWait\r\n\t\t\t\t\t\tview.reportEventDrop(eventInstance, eventDefMutation, el, ev);\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\r\n\t\t\t\t_this.dragListener = null;\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\treturn dragListener;\r\n\t},\r\n\r\n\r\n\t// Called before event segment dragging starts\r\n\tsegDragStart: function(seg, ev) {\r\n\t\tthis.isDragging = true;\r\n\t\tthis.component.publiclyTrigger('eventDragStart', {\r\n\t\t\tcontext: seg.el[0],\r\n\t\t\targs: [\r\n\t\t\t\tseg.footprint.getEventLegacy(),\r\n\t\t\t\tev,\r\n\t\t\t\t{}, // jqui dummy\r\n\t\t\t\tthis.view\r\n\t\t\t]\r\n\t\t});\r\n\t},\r\n\r\n\r\n\t// Called after event segment dragging stops\r\n\tsegDragStop: function(seg, ev) {\r\n\t\tthis.isDragging = false;\r\n\t\tthis.component.publiclyTrigger('eventDragStop', {\r\n\t\t\tcontext: seg.el[0],\r\n\t\t\targs: [\r\n\t\t\t\tseg.footprint.getEventLegacy(),\r\n\t\t\t\tev,\r\n\t\t\t\t{}, // jqui dummy\r\n\t\t\t\tthis.view\r\n\t\t\t]\r\n\t\t});\r\n\t},\r\n\r\n\r\n\t// DOES NOT consider overlap/constraint\r\n\tcomputeEventDropMutation: function(startFootprint, endFootprint, eventDef) {\r\n\t\tvar eventDefMutation = new EventDefMutation();\r\n\r\n\t\teventDefMutation.setDateMutation(\r\n\t\t\tthis.computeEventDateMutation(startFootprint, endFootprint)\r\n\t\t);\r\n\r\n\t\treturn eventDefMutation;\r\n\t},\r\n\r\n\r\n\tcomputeEventDateMutation: function(startFootprint, endFootprint) {\r\n\t\tvar date0 = startFootprint.unzonedRange.getStart();\r\n\t\tvar date1 = endFootprint.unzonedRange.getStart();\r\n\t\tvar clearEnd = false;\r\n\t\tvar forceTimed = false;\r\n\t\tvar forceAllDay = false;\r\n\t\tvar dateDelta;\r\n\t\tvar dateMutation;\r\n\r\n\t\tif (startFootprint.isAllDay !== endFootprint.isAllDay) {\r\n\t\t\tclearEnd = true;\r\n\r\n\t\t\tif (endFootprint.isAllDay) {\r\n\t\t\t\tforceAllDay = true;\r\n\t\t\t\tdate0.stripTime();\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tforceTimed = true;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tdateDelta = this.component.diffDates(date1, date0);\r\n\r\n\t\tdateMutation = new EventDefDateMutation();\r\n\t\tdateMutation.clearEnd = clearEnd;\r\n\t\tdateMutation.forceTimed = forceTimed;\r\n\t\tdateMutation.forceAllDay = forceAllDay;\r\n\t\tdateMutation.setDateDelta(dateDelta);\r\n\r\n\t\treturn dateMutation;\r\n\t}\r\n\r\n});\r\n\r\n;;\r\n\r\nvar EventResizing = FC.EventResizing = Interaction.extend({\r\n\r\n\teventPointing: null,\r\n\tdragListener: null,\r\n\tisResizing: false,\r\n\r\n\r\n\t/*\r\n\tcomponent impements:\r\n\t\t- bindSegHandlerToEl\r\n\t\t- publiclyTrigger\r\n\t\t- diffDates\r\n\t\t- eventRangesToEventFootprints\r\n\t\t- isEventInstanceGroupAllowed\r\n\t\t- getSafeHitFootprint\r\n\t*/\r\n\r\n\r\n\tconstructor: function(component, eventPointing) {\r\n\t\tInteraction.call(this, component);\r\n\r\n\t\tthis.eventPointing = eventPointing;\r\n\t},\r\n\r\n\r\n\tend: function() {\r\n\t\tif (this.dragListener) {\r\n\t\t\tthis.dragListener.endInteraction();\r\n\t\t}\r\n\t},\r\n\r\n\r\n\tbindToEl: function(el) {\r\n\t\tvar component = this.component;\r\n\r\n\t\tcomponent.bindSegHandlerToEl(el, 'mousedown', this.handleMouseDown.bind(this));\r\n\t\tcomponent.bindSegHandlerToEl(el, 'touchstart', this.handleTouchStart.bind(this));\r\n\t},\r\n\r\n\r\n\thandleMouseDown: function(seg, ev) {\r\n\t\tif (this.component.canStartResize(seg, ev)) {\r\n\t\t\tthis.buildDragListener(seg, $(ev.target).is('.fc-start-resizer'))\r\n\t\t\t\t.startInteraction(ev, { distance: 5 });\r\n\t\t}\r\n\t},\r\n\r\n\r\n\thandleTouchStart: function(seg, ev) {\r\n\t\tif (this.component.canStartResize(seg, ev)) {\r\n\t\t\tthis.buildDragListener(seg, $(ev.target).is('.fc-start-resizer'))\r\n\t\t\t\t.startInteraction(ev);\r\n\t\t}\r\n\t},\r\n\r\n\r\n\t// Creates a listener that tracks the user as they resize an event segment.\r\n\t// Generic enough to work with any type of Grid.\r\n\tbuildDragListener: function(seg, isStart) {\r\n\t\tvar _this = this;\r\n\t\tvar component = this.component;\r\n\t\tvar view = this.view;\r\n\t\tvar calendar = view.calendar;\r\n\t\tvar eventManager = calendar.eventManager;\r\n\t\tvar el = seg.el;\r\n\t\tvar eventDef = seg.footprint.eventDef;\r\n\t\tvar eventInstance = seg.footprint.eventInstance;\r\n\t\tvar isDragging;\r\n\t\tvar resizeMutation; // zoned event date properties. falsy if invalid resize\r\n\r\n\t\t// Tracks mouse movement over the *grid's* coordinate map\r\n\t\tvar dragListener = this.dragListener = new HitDragListener(component, {\r\n\t\t\tscroll: this.opt('dragScroll'),\r\n\t\t\tsubjectEl: el,\r\n\t\t\tinteractionStart: function() {\r\n\t\t\t\tisDragging = false;\r\n\t\t\t},\r\n\t\t\tdragStart: function(ev) {\r\n\t\t\t\tisDragging = true;\r\n\r\n\t\t\t\t// ensure a mouseout on the manipulated event has been reported\r\n\t\t\t\t_this.eventPointing.handleMouseout(seg, ev);\r\n\r\n\t\t\t\t_this.segResizeStart(seg, ev);\r\n\t\t\t},\r\n\t\t\thitOver: function(hit, isOrig, origHit) {\r\n\t\t\t\tvar isAllowed = true;\r\n\t\t\t\tvar origHitFootprint = component.getSafeHitFootprint(origHit);\r\n\t\t\t\tvar hitFootprint = component.getSafeHitFootprint(hit);\r\n\t\t\t\tvar mutatedEventInstanceGroup;\r\n\r\n\t\t\t\tif (origHitFootprint && hitFootprint) {\r\n\t\t\t\t\tresizeMutation = isStart ?\r\n\t\t\t\t\t\t_this.computeEventStartResizeMutation(origHitFootprint, hitFootprint, seg.footprint) :\r\n\t\t\t\t\t\t_this.computeEventEndResizeMutation(origHitFootprint, hitFootprint, seg.footprint);\r\n\r\n\t\t\t\t\tif (resizeMutation) {\r\n\t\t\t\t\t\tmutatedEventInstanceGroup = eventManager.buildMutatedEventInstanceGroup(\r\n\t\t\t\t\t\t\teventDef.id,\r\n\t\t\t\t\t\t\tresizeMutation\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\t\tisAllowed = component.isEventInstanceGroupAllowed(mutatedEventInstanceGroup);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tisAllowed = false;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tisAllowed = false;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (!isAllowed) {\r\n\t\t\t\t\tresizeMutation = null;\r\n\t\t\t\t\tdisableCursor();\r\n\t\t\t\t}\r\n\t\t\t\telse if (resizeMutation.isEmpty()) {\r\n\t\t\t\t\t// no change. (FYI, event dates might have zones)\r\n\t\t\t\t\tresizeMutation = null;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (resizeMutation) {\r\n\t\t\t\t\tview.hideEventsWithId(seg.footprint.eventDef.id);\r\n\t\t\t\t\tview.renderEventResize(\r\n\t\t\t\t\t\tcomponent.eventRangesToEventFootprints(\r\n\t\t\t\t\t\t\tmutatedEventInstanceGroup.sliceRenderRanges(component.dateProfile.renderUnzonedRange, calendar)\r\n\t\t\t\t\t\t),\r\n\t\t\t\t\t\tseg\r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\thitOut: function() { // called before mouse moves to a different hit OR moved out of all hits\r\n\t\t\t\tresizeMutation = null;\r\n\t\t\t},\r\n\t\t\thitDone: function() { // resets the rendering to show the original event\r\n\t\t\t\tview.unrenderEventResize(seg);\r\n\t\t\t\tview.showEventsWithId(seg.footprint.eventDef.id);\r\n\t\t\t\tenableCursor();\r\n\t\t\t},\r\n\t\t\tinteractionEnd: function(ev) {\r\n\t\t\t\tif (isDragging) {\r\n\t\t\t\t\t_this.segResizeStop(seg, ev);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (resizeMutation) { // valid date to resize to?\r\n\t\t\t\t\t// no need to re-show original, will rerender all anyways. esp important if eventRenderWait\r\n\t\t\t\t\tview.reportEventResize(eventInstance, resizeMutation, el, ev);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t_this.dragListener = null;\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\treturn dragListener;\r\n\t},\r\n\r\n\r\n\t// Called before event segment resizing starts\r\n\tsegResizeStart: function(seg, ev) {\r\n\t\tthis.isResizing = true;\r\n\t\tthis.component.publiclyTrigger('eventResizeStart', {\r\n\t\t\tcontext: seg.el[0],\r\n\t\t\targs: [\r\n\t\t\t\tseg.footprint.getEventLegacy(),\r\n\t\t\t\tev,\r\n\t\t\t\t{}, // jqui dummy\r\n\t\t\t\tthis.view\r\n\t\t\t]\r\n\t\t});\r\n\t},\r\n\r\n\r\n\t// Called after event segment resizing stops\r\n\tsegResizeStop: function(seg, ev) {\r\n\t\tthis.isResizing = false;\r\n\t\tthis.component.publiclyTrigger('eventResizeStop', {\r\n\t\t\tcontext: seg.el[0],\r\n\t\t\targs: [\r\n\t\t\t\tseg.footprint.getEventLegacy(),\r\n\t\t\t\tev,\r\n\t\t\t\t{}, // jqui dummy\r\n\t\t\t\tthis.view\r\n\t\t\t]\r\n\t\t});\r\n\t},\r\n\r\n\r\n\t// Returns new date-information for an event segment being resized from its start\r\n\tcomputeEventStartResizeMutation: function(startFootprint, endFootprint, origEventFootprint) {\r\n\t\tvar origRange = origEventFootprint.componentFootprint.unzonedRange;\r\n\t\tvar startDelta = this.component.diffDates(\r\n\t\t\tendFootprint.unzonedRange.getStart(),\r\n\t\t\tstartFootprint.unzonedRange.getStart()\r\n\t\t);\r\n\t\tvar dateMutation;\r\n\t\tvar eventDefMutation;\r\n\r\n\t\tif (origRange.getStart().add(startDelta) < origRange.getEnd()) {\r\n\r\n\t\t\tdateMutation = new EventDefDateMutation();\r\n\t\t\tdateMutation.setStartDelta(startDelta);\r\n\r\n\t\t\teventDefMutation = new EventDefMutation();\r\n\t\t\teventDefMutation.setDateMutation(dateMutation);\r\n\r\n\t\t\treturn eventDefMutation;\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\t},\r\n\r\n\r\n\t// Returns new date-information for an event segment being resized from its end\r\n\tcomputeEventEndResizeMutation: function(startFootprint, endFootprint, origEventFootprint) {\r\n\t\tvar origRange = origEventFootprint.componentFootprint.unzonedRange;\r\n\t\tvar endDelta = this.component.diffDates(\r\n\t\t\tendFootprint.unzonedRange.getEnd(),\r\n\t\t\tstartFootprint.unzonedRange.getEnd()\r\n\t\t);\r\n\t\tvar dateMutation;\r\n\t\tvar eventDefMutation;\r\n\r\n\t\tif (origRange.getEnd().add(endDelta) > origRange.getStart()) {\r\n\r\n\t\t\tdateMutation = new EventDefDateMutation();\r\n\t\t\tdateMutation.setEndDelta(endDelta);\r\n\r\n\t\t\teventDefMutation = new EventDefMutation();\r\n\t\t\teventDefMutation.setDateMutation(dateMutation);\r\n\r\n\t\t\treturn eventDefMutation;\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n});\r\n\r\n;;\r\n\r\nvar ExternalDropping = FC.ExternalDropping = Interaction.extend(ListenerMixin, {\r\n\r\n\tdragListener: null,\r\n\tisDragging: false, // jqui-dragging an external element? boolean\r\n\r\n\r\n\t/*\r\n\tcomponent impements:\r\n\t\t- eventRangesToEventFootprints\r\n\t\t- isEventInstanceGroupAllowed\r\n\t\t- isExternalInstanceGroupAllowed\r\n\t\t- renderDrag\r\n\t\t- unrenderDrag\r\n\t*/\r\n\r\n\r\n\tend: function() {\r\n\t\tif (this.dragListener) {\r\n\t\t\tthis.dragListener.endInteraction();\r\n\t\t}\r\n\t},\r\n\r\n\r\n\tbindToDocument: function() {\r\n\t\tthis.listenTo($(document), {\r\n\t\t\tdragstart: this.handleDragStart, // jqui\r\n\t\t\tsortstart: this.handleDragStart // jqui\r\n\t\t});\r\n\t},\r\n\r\n\r\n\tunbindFromDocument: function() {\r\n\t\tthis.stopListeningTo($(document));\r\n\t},\r\n\r\n\r\n\t// Called when a jQuery UI drag is initiated anywhere in the DOM\r\n\thandleDragStart: function(ev, ui) {\r\n\t\tvar el;\r\n\t\tvar accept;\r\n\r\n\t\tif (this.opt('droppable')) { // only listen if this setting is on\r\n\t\t\tel = $((ui ? ui.item : null) || ev.target);\r\n\r\n\t\t\t// Test that the dragged element passes the dropAccept selector or filter function.\r\n\t\t\t// FYI, the default is \"*\" (matches all)\r\n\t\t\taccept = this.opt('dropAccept');\r\n\t\t\tif ($.isFunction(accept) ? accept.call(el[0], el) : el.is(accept)) {\r\n\t\t\t\tif (!this.isDragging) { // prevent double-listening if fired twice\r\n\t\t\t\t\tthis.listenToExternalDrag(el, ev, ui);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\r\n\t// Called when a jQuery UI drag starts and it needs to be monitored for dropping\r\n\tlistenToExternalDrag: function(el, ev, ui) {\r\n\t\tvar _this = this;\r\n\t\tvar component = this.component;\r\n\t\tvar view = this.view;\r\n\t\tvar meta = getDraggedElMeta(el); // extra data about event drop, including possible event to create\r\n\t\tvar singleEventDef; // a null value signals an unsuccessful drag\r\n\r\n\t\t// listener that tracks mouse movement over date-associated pixel regions\r\n\t\tvar dragListener = _this.dragListener = new HitDragListener(component, {\r\n\t\t\tinteractionStart: function() {\r\n\t\t\t\t_this.isDragging = true;\r\n\t\t\t},\r\n\t\t\thitOver: function(hit) {\r\n\t\t\t\tvar isAllowed = true;\r\n\t\t\t\tvar hitFootprint = hit.component.getSafeHitFootprint(hit); // hit might not belong to this grid\r\n\t\t\t\tvar mutatedEventInstanceGroup;\r\n\r\n\t\t\t\tif (hitFootprint) {\r\n\t\t\t\t\tsingleEventDef = _this.computeExternalDrop(hitFootprint, meta);\r\n\r\n\t\t\t\t\tif (singleEventDef) {\r\n\t\t\t\t\t\tmutatedEventInstanceGroup = new EventInstanceGroup(\r\n\t\t\t\t\t\t\tsingleEventDef.buildInstances()\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\t\tisAllowed = meta.eventProps ? // isEvent?\r\n\t\t\t\t\t\t\tcomponent.isEventInstanceGroupAllowed(mutatedEventInstanceGroup) :\r\n\t\t\t\t\t\t\tcomponent.isExternalInstanceGroupAllowed(mutatedEventInstanceGroup);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tisAllowed = false;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tisAllowed = false;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (!isAllowed) {\r\n\t\t\t\t\tsingleEventDef = null;\r\n\t\t\t\t\tdisableCursor();\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (singleEventDef) {\r\n\t\t\t\t\tcomponent.renderDrag( // called without a seg parameter\r\n\t\t\t\t\t\tcomponent.eventRangesToEventFootprints(\r\n\t\t\t\t\t\t\tmutatedEventInstanceGroup.sliceRenderRanges(component.dateProfile.renderUnzonedRange, view.calendar)\r\n\t\t\t\t\t\t)\r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\thitOut: function() {\r\n\t\t\t\tsingleEventDef = null; // signal unsuccessful\r\n\t\t\t},\r\n\t\t\thitDone: function() { // Called after a hitOut OR before a dragEnd\r\n\t\t\t\tenableCursor();\r\n\t\t\t\tcomponent.unrenderDrag();\r\n\t\t\t},\r\n\t\t\tinteractionEnd: function(ev) {\r\n\r\n\t\t\t\tif (singleEventDef) { // element was dropped on a valid hit\r\n\t\t\t\t\tview.reportExternalDrop(\r\n\t\t\t\t\t\tsingleEventDef,\r\n\t\t\t\t\t\tBoolean(meta.eventProps), // isEvent\r\n\t\t\t\t\t\tBoolean(meta.stick), // isSticky\r\n\t\t\t\t\t\tel, ev, ui\r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t_this.isDragging = false;\r\n\t\t\t\t_this.dragListener = null;\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tdragListener.startDrag(ev); // start listening immediately\r\n\t},\r\n\r\n\r\n\t// Given a hit to be dropped upon, and misc data associated with the jqui drag (guaranteed to be a plain object),\r\n\t// returns the zoned start/end dates for the event that would result from the hypothetical drop. end might be null.\r\n\t// Returning a null value signals an invalid drop hit.\r\n\t// DOES NOT consider overlap/constraint.\r\n\t// Assumes both footprints are non-open-ended.\r\n\tcomputeExternalDrop: function(componentFootprint, meta) {\r\n\t\tvar calendar = this.view.calendar;\r\n\t\tvar start = FC.moment.utc(componentFootprint.unzonedRange.startMs).stripZone();\r\n\t\tvar end;\r\n\t\tvar eventDef;\r\n\r\n\t\tif (componentFootprint.isAllDay) {\r\n\t\t\t// if dropped on an all-day span, and element's metadata specified a time, set it\r\n\t\t\tif (meta.startTime) {\r\n\t\t\t\tstart.time(meta.startTime);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tstart.stripTime();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (meta.duration) {\r\n\t\t\tend = start.clone().add(meta.duration);\r\n\t\t}\r\n\r\n\t\tstart = calendar.applyTimezone(start);\r\n\r\n\t\tif (end) {\r\n\t\t\tend = calendar.applyTimezone(end);\r\n\t\t}\r\n\r\n\t\teventDef = SingleEventDef.parse(\r\n\t\t\t$.extend({}, meta.eventProps, {\r\n\t\t\t\tstart: start,\r\n\t\t\t\tend: end\r\n\t\t\t}),\r\n\t\t\tnew EventSource(calendar)\r\n\t\t);\r\n\r\n\t\treturn eventDef;\r\n\t}\r\n\r\n});\r\n\r\n\r\n/* External-Dragging-Element Data\r\n----------------------------------------------------------------------------------------------------------------------*/\r\n\r\n// Require all HTML5 data-* attributes used by FullCalendar to have this prefix.\r\n// A value of '' will query attributes like data-event. A value of 'fc' will query attributes like data-fc-event.\r\nFC.dataAttrPrefix = '';\r\n\r\n// Given a jQuery element that might represent a dragged FullCalendar event, returns an intermediate data structure\r\n// to be used for Event Object creation.\r\n// A defined `.eventProps`, even when empty, indicates that an event should be created.\r\nfunction getDraggedElMeta(el) {\r\n\tvar prefix = FC.dataAttrPrefix;\r\n\tvar eventProps; // properties for creating the event, not related to date/time\r\n\tvar startTime; // a Duration\r\n\tvar duration;\r\n\tvar stick;\r\n\r\n\tif (prefix) { prefix += '-'; }\r\n\teventProps = el.data(prefix + 'event') || null;\r\n\r\n\tif (eventProps) {\r\n\t\tif (typeof eventProps === 'object') {\r\n\t\t\teventProps = $.extend({}, eventProps); // make a copy\r\n\t\t}\r\n\t\telse { // something like 1 or true. still signal event creation\r\n\t\t\teventProps = {};\r\n\t\t}\r\n\r\n\t\t// pluck special-cased date/time properties\r\n\t\tstartTime = eventProps.start;\r\n\t\tif (startTime == null) { startTime = eventProps.time; } // accept 'time' as well\r\n\t\tduration = eventProps.duration;\r\n\t\tstick = eventProps.stick;\r\n\t\tdelete eventProps.start;\r\n\t\tdelete eventProps.time;\r\n\t\tdelete eventProps.duration;\r\n\t\tdelete eventProps.stick;\r\n\t}\r\n\r\n\t// fallback to standalone attribute values for each of the date/time properties\r\n\tif (startTime == null) { startTime = el.data(prefix + 'start'); }\r\n\tif (startTime == null) { startTime = el.data(prefix + 'time'); } // accept 'time' as well\r\n\tif (duration == null) { duration = el.data(prefix + 'duration'); }\r\n\tif (stick == null) { stick = el.data(prefix + 'stick'); }\r\n\r\n\t// massage into correct data types\r\n\tstartTime = startTime != null ? moment.duration(startTime) : null;\r\n\tduration = duration != null ? moment.duration(duration) : null;\r\n\tstick = Boolean(stick);\r\n\r\n\treturn { eventProps: eventProps, startTime: startTime, duration: duration, stick: stick };\r\n}\r\n\r\n;;\r\n\r\nvar EventPointing = FC.EventPointing = Interaction.extend({\r\n\r\n\tmousedOverSeg: null, // the segment object the user's mouse is over. null if over nothing\r\n\r\n\r\n\t/*\r\n\tcomponent must implement:\r\n\t\t- publiclyTrigger\r\n\t*/\r\n\r\n\r\n\tbindToEl: function(el) {\r\n\t\tvar component = this.component;\r\n\r\n\t\tcomponent.bindSegHandlerToEl(el, 'click', this.handleClick.bind(this));\r\n\t\tcomponent.bindSegHandlerToEl(el, 'mouseenter', this.handleMouseover.bind(this));\r\n\t\tcomponent.bindSegHandlerToEl(el, 'mouseleave', this.handleMouseout.bind(this));\r\n\t},\r\n\r\n\r\n\thandleClick: function(seg, ev) {\r\n\t\tvar res = this.component.publiclyTrigger('eventClick', { // can return `false` to cancel\r\n\t\t\tcontext: seg.el[0],\r\n\t\t\targs: [ seg.footprint.getEventLegacy(), ev, this.view ]\r\n\t\t});\r\n\r\n\t\tif (res === false) {\r\n\t\t\tev.preventDefault();\r\n\t\t}\r\n\t},\r\n\r\n\r\n\t// Updates internal state and triggers handlers for when an event element is moused over\r\n\thandleMouseover: function(seg, ev) {\r\n\t\tif (\r\n\t\t\t!GlobalEmitter.get().shouldIgnoreMouse() &&\r\n\t\t\t!this.mousedOverSeg\r\n\t\t) {\r\n\t\t\tthis.mousedOverSeg = seg;\r\n\r\n\t\t\t// TODO: move to EventSelecting's responsibility\r\n\t\t\tif (this.view.isEventDefResizable(seg.footprint.eventDef)) {\r\n\t\t\t\tseg.el.addClass('fc-allow-mouse-resize');\r\n\t\t\t}\r\n\r\n\t\t\tthis.component.publiclyTrigger('eventMouseover', {\r\n\t\t\t\tcontext: seg.el[0],\r\n\t\t\t\targs: [ seg.footprint.getEventLegacy(), ev, this.view ]\r\n\t\t\t});\r\n\t\t}\r\n\t},\r\n\r\n\r\n\t// Updates internal state and triggers handlers for when an event element is moused out.\r\n\t// Can be given no arguments, in which case it will mouseout the segment that was previously moused over.\r\n\thandleMouseout: function(seg, ev) {\r\n\t\tif (this.mousedOverSeg) {\r\n\t\t\tthis.mousedOverSeg = null;\r\n\r\n\t\t\t// TODO: move to EventSelecting's responsibility\r\n\t\t\tif (this.view.isEventDefResizable(seg.footprint.eventDef)) {\r\n\t\t\t\tseg.el.removeClass('fc-allow-mouse-resize');\r\n\t\t\t}\r\n\r\n\t\t\tthis.component.publiclyTrigger('eventMouseout', {\r\n\t\t\t\tcontext: seg.el[0],\r\n\t\t\t\targs: [\r\n\t\t\t\t\tseg.footprint.getEventLegacy(),\r\n\t\t\t\t\tev || {}, // if given no arg, make a mock mouse event\r\n\t\t\t\t\tthis.view\r\n\t\t\t\t]\r\n\t\t\t});\r\n\t\t}\r\n\t},\r\n\r\n\r\n\tend: function() {\r\n\t\tif (this.mousedOverSeg) {\r\n\t\t\tthis.handleMouseout(this.mousedOverSeg);\r\n\t\t}\r\n\t}\r\n\r\n});\r\n\r\n;;\r\n\r\nvar StandardInteractionsMixin = FC.StandardInteractionsMixin = {\r\n\tdateClickingClass: DateClicking,\r\n\tdateSelectingClass: DateSelecting,\r\n\teventPointingClass: EventPointing,\r\n\teventDraggingClass: EventDragging,\r\n\teventResizingClass: EventResizing,\r\n\texternalDroppingClass: ExternalDropping\r\n};\r\n\r\n;;\r\n\r\nvar EventRenderer = FC.EventRenderer = Class.extend({\r\n\r\n\tview: null,\r\n\tcomponent: null,\r\n\tfillRenderer: null, // might remain null\r\n\r\n\tfgSegs: null,\r\n\tbgSegs: null,\r\n\r\n\t// derived from options\r\n\teventTimeFormat: null,\r\n\tdisplayEventTime: null,\r\n\tdisplayEventEnd: null,\r\n\r\n\r\n\tconstructor: function(component, fillRenderer) { // fillRenderer is optional\r\n\t\tthis.view = component._getView();\r\n\t\tthis.component = component;\r\n\t\tthis.fillRenderer = fillRenderer;\r\n\t},\r\n\r\n\r\n\topt: function(name) {\r\n\t\treturn this.view.opt(name);\r\n\t},\r\n\r\n\r\n\t// Updates values that rely on options and also relate to range\r\n\trangeUpdated: function() {\r\n\t\tvar displayEventTime;\r\n\t\tvar displayEventEnd;\r\n\r\n\t\tthis.eventTimeFormat =\r\n\t\t\tthis.opt('eventTimeFormat') ||\r\n\t\t\tthis.opt('timeFormat') || // deprecated\r\n\t\t\tthis.computeEventTimeFormat();\r\n\r\n\t\tdisplayEventTime = this.opt('displayEventTime');\r\n\t\tif (displayEventTime == null) {\r\n\t\t\tdisplayEventTime = this.computeDisplayEventTime(); // might be based off of range\r\n\t\t}\r\n\r\n\t\tdisplayEventEnd = this.opt('displayEventEnd');\r\n\t\tif (displayEventEnd == null) {\r\n\t\t\tdisplayEventEnd = this.computeDisplayEventEnd(); // might be based off of range\r\n\t\t}\r\n\r\n\t\tthis.displayEventTime = displayEventTime;\r\n\t\tthis.displayEventEnd = displayEventEnd;\r\n\t},\r\n\r\n\r\n\trender: function(eventsPayload) {\r\n\t\tvar dateProfile = this.component._getDateProfile();\r\n\t\tvar eventDefId;\r\n\t\tvar instanceGroup;\r\n\t\tvar eventRanges;\r\n\t\tvar bgRanges = [];\r\n\t\tvar fgRanges = [];\r\n\r\n\t\tfor (eventDefId in eventsPayload) {\r\n\t\t\tinstanceGroup = eventsPayload[eventDefId];\r\n\r\n\t\t\teventRanges = instanceGroup.sliceRenderRanges(\r\n\t\t\t\tdateProfile.activeUnzonedRange\r\n\t\t\t);\r\n\r\n\t\t\tif (instanceGroup.getEventDef().hasBgRendering()) {\r\n\t\t\t\tbgRanges.push.apply(bgRanges, eventRanges);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tfgRanges.push.apply(fgRanges, eventRanges);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis.renderBgRanges(bgRanges);\r\n\t\tthis.renderFgRanges(fgRanges);\r\n\t},\r\n\r\n\r\n\tunrender: function() {\r\n\t\tthis.unrenderBgRanges();\r\n\t\tthis.unrenderFgRanges();\r\n\t},\r\n\r\n\r\n\trenderFgRanges: function(eventRanges) {\r\n\t\tvar eventFootprints = this.component.eventRangesToEventFootprints(eventRanges);\r\n\t\tvar segs = this.component.eventFootprintsToSegs(eventFootprints);\r\n\r\n\t\t// render an `.el` on each seg\r\n\t\t// returns a subset of the segs. segs that were actually rendered\r\n\t\tsegs = this.renderFgSegEls(segs);\r\n\r\n\t\tif (this.renderFgSegs(segs) !== false) { // no failure?\r\n\t\t\tthis.fgSegs = segs;\r\n\t\t}\r\n\t},\r\n\r\n\r\n\tunrenderFgRanges: function() {\r\n\t\tthis.unrenderFgSegs(this.fgSegs || []);\r\n\t\tthis.fgSegs = null;\r\n\t},\r\n\r\n\r\n\trenderBgRanges: function(eventRanges) {\r\n\t\tvar eventFootprints = this.component.eventRangesToEventFootprints(eventRanges);\r\n\t\tvar segs = this.component.eventFootprintsToSegs(eventFootprints);\r\n\r\n\t\tif (this.renderBgSegs(segs) !== false) { // no failure?\r\n\t\t\tthis.bgSegs = segs;\r\n\t\t}\r\n\t},\r\n\r\n\r\n\tunrenderBgRanges: function() {\r\n\t\tthis.unrenderBgSegs();\r\n\t\tthis.bgSegs = null;\r\n\t},\r\n\r\n\r\n\tgetSegs: function() {\r\n\t\treturn (this.bgSegs || []).concat(this.fgSegs || []);\r\n\t},\r\n\r\n\r\n\t// Renders foreground event segments onto the grid\r\n\trenderFgSegs: function(segs) {\r\n\t\t// subclasses must implement\r\n\t\t// segs already has rendered els, and has been filtered.\r\n\r\n\t\treturn false; // signal failure if not implemented\r\n\t},\r\n\r\n\r\n\t// Unrenders all currently rendered foreground segments\r\n\tunrenderFgSegs: function(segs) {\r\n\t\t// subclasses must implement\r\n\t},\r\n\r\n\r\n\trenderBgSegs: function(segs) {\r\n\t\tvar _this = this;\r\n\r\n\t\tif (this.fillRenderer) {\r\n\t\t\tthis.fillRenderer.renderSegs('bgEvent', segs, {\r\n\t\t\t\tgetClasses: function(seg) {\r\n\t\t\t\t\treturn _this.getBgClasses(seg.footprint.eventDef);\r\n\t\t\t\t},\r\n\t\t\t\tgetCss: function(seg) {\r\n\t\t\t\t\treturn {\r\n\t\t\t\t\t\t'background-color': _this.getBgColor(seg.footprint.eventDef)\r\n\t\t\t\t\t};\r\n\t\t\t\t},\r\n\t\t\t\tfilterEl: function(seg, el) {\r\n\t\t\t\t\treturn _this.filterEventRenderEl(seg.footprint, el);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn false; // signal failure if no fillRenderer\r\n\t\t}\r\n\t},\r\n\r\n\r\n\tunrenderBgSegs: function() {\r\n\t\tif (this.fillRenderer) {\r\n\t\t\tthis.fillRenderer.unrender('bgEvent');\r\n\t\t}\r\n\t},\r\n\r\n\r\n\t// Renders and assigns an `el` property for each foreground event segment.\r\n\t// Only returns segments that successfully rendered.\r\n\trenderFgSegEls: function(segs, disableResizing) {\r\n\t\tvar _this = this;\r\n\t\tvar hasEventRenderHandlers = this.view.hasPublicHandlers('eventRender');\r\n\t\tvar html = '';\r\n\t\tvar renderedSegs = [];\r\n\t\tvar i;\r\n\r\n\t\tif (segs.length) { // don't build an empty html string\r\n\r\n\t\t\t// build a large concatenation of event segment HTML\r\n\t\t\tfor (i = 0; i < segs.length; i++) {\r\n\t\t\t\tthis.beforeFgSegHtml(segs[i]);\r\n\t\t\t\thtml += this.fgSegHtml(segs[i], disableResizing);\r\n\t\t\t}\r\n\r\n\t\t\t// Grab individual elements from the combined HTML string. Use each as the default rendering.\r\n\t\t\t// Then, compute the 'el' for each segment. An el might be null if the eventRender callback returned false.\r\n\t\t\t$(html).each(function(i, node) {\r\n\t\t\t\tvar seg = segs[i];\r\n\t\t\t\tvar el = $(node);\r\n\r\n\t\t\t\tif (hasEventRenderHandlers) { // optimization\r\n\t\t\t\t\tel = _this.filterEventRenderEl(seg.footprint, el);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (el) {\r\n\t\t\t\t\tel.data('fc-seg', seg); // used by handlers\r\n\t\t\t\t\tseg.el = el;\r\n\t\t\t\t\trenderedSegs.push(seg);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\treturn renderedSegs;\r\n\t},\r\n\r\n\r\n\tbeforeFgSegHtml: function(seg) { // hack\r\n\t},\r\n\r\n\r\n\t// Generates the HTML for the default rendering of a foreground event segment. Used by renderFgSegEls()\r\n\tfgSegHtml: function(seg, disableResizing) {\r\n\t\t// subclasses should implement\r\n\t},\r\n\r\n\r\n\t// Generic utility for generating the HTML classNames for an event segment's element\r\n\tgetSegClasses: function(seg, isDraggable, isResizable) {\r\n\t\tvar classes = [\r\n\t\t\t'fc-event',\r\n\t\t\tseg.isStart ? 'fc-start' : 'fc-not-start',\r\n\t\t\tseg.isEnd ? 'fc-end' : 'fc-not-end'\r\n\t\t].concat(this.getClasses(seg.footprint.eventDef));\r\n\r\n\t\tif (isDraggable) {\r\n\t\t\tclasses.push('fc-draggable');\r\n\t\t}\r\n\t\tif (isResizable) {\r\n\t\t\tclasses.push('fc-resizable');\r\n\t\t}\r\n\r\n\t\t// event is currently selected? attach a className.\r\n\t\tif (this.view.isEventDefSelected(seg.footprint.eventDef)) {\r\n\t\t\tclasses.push('fc-selected');\r\n\t\t}\r\n\r\n\t\treturn classes;\r\n\t},\r\n\r\n\r\n\t// Given an event and the default element used for rendering, returns the element that should actually be used.\r\n\t// Basically runs events and elements through the eventRender hook.\r\n\tfilterEventRenderEl: function(eventFootprint, el) {\r\n\t\tvar legacy = eventFootprint.getEventLegacy();\r\n\r\n\t\tvar custom = this.view.publiclyTrigger('eventRender', {\r\n\t\t\tcontext: legacy,\r\n\t\t\targs: [ legacy, el, this.view ]\r\n\t\t});\r\n\r\n\t\tif (custom === false) { // means don't render at all\r\n\t\t\tel = null;\r\n\t\t}\r\n\t\telse if (custom && custom !== true) {\r\n\t\t\tel = $(custom);\r\n\t\t}\r\n\r\n\t\treturn el;\r\n\t},\r\n\r\n\r\n\t// Compute the text that should be displayed on an event's element.\r\n\t// `range` can be the Event object itself, or something range-like, with at least a `start`.\r\n\t// If event times are disabled, or the event has no time, will return a blank string.\r\n\t// If not specified, formatStr will default to the eventTimeFormat setting,\r\n\t// and displayEnd will default to the displayEventEnd setting.\r\n\tgetTimeText: function(eventFootprint, formatStr, displayEnd) {\r\n\t\treturn this._getTimeText(\r\n\t\t\teventFootprint.eventInstance.dateProfile.start,\r\n\t\t\teventFootprint.eventInstance.dateProfile.end,\r\n\t\t\teventFootprint.componentFootprint.isAllDay,\r\n\t\t\tformatStr,\r\n\t\t\tdisplayEnd\r\n\t\t);\r\n\t},\r\n\r\n\r\n\t_getTimeText: function(start, end, isAllDay, formatStr, displayEnd) {\r\n\t\tif (formatStr == null) {\r\n\t\t\tformatStr = this.eventTimeFormat;\r\n\t\t}\r\n\r\n\t\tif (displayEnd == null) {\r\n\t\t\tdisplayEnd = this.displayEventEnd;\r\n\t\t}\r\n\r\n\t\tif (this.displayEventTime && !isAllDay) {\r\n\t\t\tif (displayEnd && end) {\r\n\t\t\t\treturn this.view.formatRange(\r\n\t\t\t\t\t{ start: start, end: end },\r\n\t\t\t\t\tfalse, // allDay\r\n\t\t\t\t\tformatStr\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\treturn start.format(formatStr);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn '';\r\n\t},\r\n\r\n\r\n\tcomputeEventTimeFormat: function() {\r\n\t\treturn this.opt('smallTimeFormat');\r\n\t},\r\n\r\n\r\n\tcomputeDisplayEventTime: function() {\r\n\t\treturn true;\r\n\t},\r\n\r\n\r\n\tcomputeDisplayEventEnd: function() {\r\n\t\treturn true;\r\n\t},\r\n\r\n\r\n\tgetBgClasses: function(eventDef) {\r\n\t\tvar classNames = this.getClasses(eventDef);\r\n\t\tclassNames.push('fc-bgevent');\r\n\t\treturn classNames;\r\n\t},\r\n\r\n\r\n\tgetClasses: function(eventDef) {\r\n\t\tvar objs = this.getStylingObjs(eventDef);\r\n\t\tvar i;\r\n\t\tvar classNames = [];\r\n\r\n\t\tfor (i = 0; i < objs.length; i++) {\r\n\t\t\tclassNames.push.apply( // append\r\n\t\t\t\tclassNames,\r\n\t\t\t\tobjs[i].eventClassName || objs[i].className || []\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\treturn classNames;\r\n\t},\r\n\r\n\r\n\t// Utility for generating event skin-related CSS properties\r\n\tgetSkinCss: function(eventDef) {\r\n\t\treturn {\r\n\t\t\t'background-color': this.getBgColor(eventDef),\r\n\t\t\t'border-color': this.getBorderColor(eventDef),\r\n\t\t\tcolor: this.getTextColor(eventDef)\r\n\t\t};\r\n\t},\r\n\r\n\r\n\t// Queries for caller-specified color, then falls back to default\r\n\tgetBgColor: function(eventDef) {\r\n\t\tvar objs = this.getStylingObjs(eventDef);\r\n\t\tvar i;\r\n\t\tvar val;\r\n\r\n\t\tfor (i = 0; i < objs.length && !val; i++) {\r\n\t\t\tval = objs[i].eventBackgroundColor || objs[i].eventColor ||\r\n\t\t\t\tobjs[i].backgroundColor || objs[i].color;\r\n\t\t}\r\n\r\n\t\tif (!val) {\r\n\t\t\tval = this.opt('eventBackgroundColor') || this.opt('eventColor');\r\n\t\t}\r\n\r\n\t\treturn val;\r\n\t},\r\n\r\n\r\n\t// Queries for caller-specified color, then falls back to default\r\n\tgetBorderColor: function(eventDef) {\r\n\t\tvar objs = this.getStylingObjs(eventDef);\r\n\t\tvar i;\r\n\t\tvar val;\r\n\r\n\t\tfor (i = 0; i < objs.length && !val; i++) {\r\n\t\t\tval = objs[i].eventBorderColor || objs[i].eventColor ||\r\n\t\t\t\tobjs[i].borderColor || objs[i].color;\r\n\t\t}\r\n\r\n\t\tif (!val) {\r\n\t\t\tval = this.opt('eventBorderColor') || this.opt('eventColor');\r\n\t\t}\r\n\r\n\t\treturn val;\r\n\t},\r\n\r\n\r\n\t// Queries for caller-specified color, then falls back to default\r\n\tgetTextColor: function(eventDef) {\r\n\t\tvar objs = this.getStylingObjs(eventDef);\r\n\t\tvar i;\r\n\t\tvar val;\r\n\r\n\t\tfor (i = 0; i < objs.length && !val; i++) {\r\n\t\t\tval = objs[i].eventTextColor ||\r\n\t\t\t\tobjs[i].textColor;\r\n\t\t}\r\n\r\n\t\tif (!val) {\r\n\t\t\tval = this.opt('eventTextColor');\r\n\t\t}\r\n\r\n\t\treturn val;\r\n\t},\r\n\r\n\r\n\tgetStylingObjs: function(eventDef) {\r\n\t\tvar objs = this.getFallbackStylingObjs(eventDef);\r\n\t\tobjs.unshift(eventDef);\r\n\t\treturn objs;\r\n\t},\r\n\r\n\r\n\tgetFallbackStylingObjs: function(eventDef) {\r\n\t\treturn [ eventDef.source ];\r\n\t},\r\n\r\n\r\n\tsortEventSegs: function(segs) {\r\n\t\tsegs.sort(proxy(this, 'compareEventSegs'));\r\n\t},\r\n\r\n\r\n\t// A cmp function for determining which segments should take visual priority\r\n\tcompareEventSegs: function(seg1, seg2) {\r\n\t\tvar f1 = seg1.footprint.componentFootprint;\r\n\t\tvar r1 = f1.unzonedRange;\r\n\t\tvar f2 = seg2.footprint.componentFootprint;\r\n\t\tvar r2 = f2.unzonedRange;\r\n\r\n\t\treturn r1.startMs - r2.startMs || // earlier events go first\r\n\t\t\t(r2.endMs - r2.startMs) - (r1.endMs - r1.startMs) || // tie? longer events go first\r\n\t\t\tf2.isAllDay - f1.isAllDay || // tie? put all-day events first (booleans cast to 0/1)\r\n\t\t\tcompareByFieldSpecs(\r\n\t\t\t\tseg1.footprint.eventDef,\r\n\t\t\t\tseg2.footprint.eventDef,\r\n\t\t\t\tthis.view.eventOrderSpecs\r\n\t\t\t);\r\n\t}\r\n\r\n});\r\n\r\n;;\r\n\r\nvar BusinessHourRenderer = FC.BusinessHourRenderer = Class.extend({\r\n\r\n\tcomponent: null,\r\n\tfillRenderer: null,\r\n\tsegs: null,\r\n\r\n\r\n\t/*\r\n\tcomponent implements:\r\n\t\t- eventRangesToEventFootprints\r\n\t\t- eventFootprintsToSegs\r\n\t*/\r\n\tconstructor: function(component, fillRenderer) {\r\n\t\tthis.component = component;\r\n\t\tthis.fillRenderer = fillRenderer;\r\n\t},\r\n\r\n\r\n\trender: function(businessHourGenerator) {\r\n\t\tvar component = this.component;\r\n\t\tvar unzonedRange = component._getDateProfile().activeUnzonedRange;\r\n\r\n\t\tvar eventInstanceGroup = businessHourGenerator.buildEventInstanceGroup(\r\n\t\t\tcomponent.hasAllDayBusinessHours,\r\n\t\t\tunzonedRange\r\n\t\t);\r\n\r\n\t\tvar eventFootprints = eventInstanceGroup ?\r\n\t\t\tcomponent.eventRangesToEventFootprints(\r\n\t\t\t\teventInstanceGroup.sliceRenderRanges(unzonedRange)\r\n\t\t\t) :\r\n\t\t\t[];\r\n\r\n\t\tthis.renderEventFootprints(eventFootprints);\r\n\t},\r\n\r\n\r\n\trenderEventFootprints: function(eventFootprints) {\r\n\t\tvar segs = this.component.eventFootprintsToSegs(eventFootprints);\r\n\r\n\t\tthis.renderSegs(segs);\r\n\t\tthis.segs = segs;\r\n\t},\r\n\r\n\r\n\trenderSegs: function(segs) {\r\n\t\tif (this.fillRenderer) {\r\n\t\t\tthis.fillRenderer.renderSegs('businessHours', segs, {\r\n\t\t\t\tgetClasses: function(seg) {\r\n\t\t\t\t\treturn [ 'fc-nonbusiness', 'fc-bgevent' ];\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\t},\r\n\r\n\r\n\tunrender: function() {\r\n\t\tif (this.fillRenderer) {\r\n\t\t\tthis.fillRenderer.unrender('businessHours');\r\n\t\t}\r\n\r\n\t\tthis.segs = null;\r\n\t},\r\n\r\n\r\n\tgetSegs: function() {\r\n\t\treturn this.segs || [];\r\n\t}\r\n\r\n});\r\n\r\n;;\r\n\r\nvar FillRenderer = FC.FillRenderer = Class.extend({ // use for highlight, background events, business hours\r\n\r\n\tfillSegTag: 'div',\r\n\tcomponent: null,\r\n\telsByFill: null, // a hash of jQuery element sets used for rendering each fill. Keyed by fill name.\r\n\r\n\r\n\tconstructor: function(component) {\r\n\t\tthis.component = component;\r\n\t\tthis.elsByFill = {};\r\n\t},\r\n\r\n\r\n\trenderFootprint: function(type, componentFootprint, props) {\r\n\t\tthis.renderSegs(\r\n\t\t\ttype,\r\n\t\t\tthis.component.componentFootprintToSegs(componentFootprint),\r\n\t\t\tprops\r\n\t\t);\r\n\t},\r\n\r\n\r\n\trenderSegs: function(type, segs, props) {\r\n\t\tvar els;\r\n\r\n\t\tsegs = this.buildSegEls(type, segs, props); // assignes `.el` to each seg. returns successfully rendered segs\r\n\t\tels = this.attachSegEls(type, segs);\r\n\r\n\t\tif (els) {\r\n\t\t\tthis.reportEls(type, els);\r\n\t\t}\r\n\r\n\t\treturn segs;\r\n\t},\r\n\r\n\r\n\t// Unrenders a specific type of fill that is currently rendered on the grid\r\n\tunrender: function(type) {\r\n\t\tvar el = this.elsByFill[type];\r\n\r\n\t\tif (el) {\r\n\t\t\tel.remove();\r\n\t\t\tdelete this.elsByFill[type];\r\n\t\t}\r\n\t},\r\n\r\n\r\n\t// Renders and assigns an `el` property for each fill segment. Generic enough to work with different types.\r\n\t// Only returns segments that successfully rendered.\r\n\tbuildSegEls: function(type, segs, props) {\r\n\t\tvar _this = this;\r\n\t\tvar html = '';\r\n\t\tvar renderedSegs = [];\r\n\t\tvar i;\r\n\r\n\t\tif (segs.length) {\r\n\r\n\t\t\t// build a large concatenation of segment HTML\r\n\t\t\tfor (i = 0; i < segs.length; i++) {\r\n\t\t\t\thtml += this.buildSegHtml(type, segs[i], props);\r\n\t\t\t}\r\n\r\n\t\t\t// Grab individual elements from the combined HTML string. Use each as the default rendering.\r\n\t\t\t// Then, compute the 'el' for each segment.\r\n\t\t\t$(html).each(function(i, node) {\r\n\t\t\t\tvar seg = segs[i];\r\n\t\t\t\tvar el = $(node);\r\n\r\n\t\t\t\t// allow custom filter methods per-type\r\n\t\t\t\tif (props.filterEl) {\r\n\t\t\t\t\tel = props.filterEl(seg, el);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (el) { // custom filters did not cancel the render\r\n\t\t\t\t\tel = $(el); // allow custom filter to return raw DOM node\r\n\r\n\t\t\t\t\t// correct element type? (would be bad if a non-TD were inserted into a table for example)\r\n\t\t\t\t\tif (el.is(_this.fillSegTag)) {\r\n\t\t\t\t\t\tseg.el = el;\r\n\t\t\t\t\t\trenderedSegs.push(seg);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\treturn renderedSegs;\r\n\t},\r\n\r\n\r\n\t// Builds the HTML needed for one fill segment. Generic enough to work with different types.\r\n\tbuildSegHtml: function(type, seg, props) {\r\n\t\t// custom hooks per-type\r\n\t\tvar classes = props.getClasses ? props.getClasses(seg) : [];\r\n\t\tvar css = cssToStr(props.getCss ? props.getCss(seg) : {});\r\n\r\n\t\treturn '<' + this.fillSegTag +\r\n\t\t\t(classes.length ? ' class=\"' + classes.join(' ') + '\"' : '') +\r\n\t\t\t(css ? ' style=\"' + css + '\"' : '') +\r\n\t\t\t' />';\r\n\t},\r\n\r\n\r\n\t// Should return wrapping DOM structure\r\n\tattachSegEls: function(type, segs) {\r\n\t\t// subclasses must implement\r\n\t},\r\n\r\n\r\n\treportEls: function(type, nodes) {\r\n\t\tif (this.elsByFill[type]) {\r\n\t\t\tthis.elsByFill[type] = this.elsByFill[type].add(nodes);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tthis.elsByFill[type] = $(nodes);\r\n\t\t}\r\n\t}\r\n\r\n});\r\n\r\n;;\r\n\r\nvar HelperRenderer = FC.HelperRenderer = Class.extend({\r\n\r\n\tview: null,\r\n\tcomponent: null,\r\n\teventRenderer: null,\r\n\thelperEls: null,\r\n\r\n\r\n\tconstructor: function(component, eventRenderer) {\r\n\t\tthis.view = component._getView();\r\n\t\tthis.component = component;\r\n\t\tthis.eventRenderer = eventRenderer;\r\n\t},\r\n\r\n\r\n\trenderComponentFootprint: function(componentFootprint) {\r\n\t\tthis.renderEventFootprints([\r\n\t\t\tthis.fabricateEventFootprint(componentFootprint)\r\n\t\t]);\r\n\t},\r\n\r\n\r\n\trenderEventDraggingFootprints: function(eventFootprints, sourceSeg, isTouch) {\r\n\t\tthis.renderEventFootprints(\r\n\t\t\teventFootprints,\r\n\t\t\tsourceSeg,\r\n\t\t\t'fc-dragging',\r\n\t\t\tisTouch ? null : this.view.opt('dragOpacity')\r\n\t\t);\r\n\t},\r\n\r\n\r\n\trenderEventResizingFootprints: function(eventFootprints, sourceSeg, isTouch) {\r\n\t\tthis.renderEventFootprints(\r\n\t\t\teventFootprints,\r\n\t\t\tsourceSeg,\r\n\t\t\t'fc-resizing'\r\n\t\t);\r\n\t},\r\n\r\n\r\n\trenderEventFootprints: function(eventFootprints, sourceSeg, extraClassNames, opacity) {\r\n\t\tvar segs = this.component.eventFootprintsToSegs(eventFootprints);\r\n\t\tvar classNames = 'fc-helper ' + (extraClassNames || '');\r\n\t\tvar i;\r\n\r\n\t\t// assigns each seg's el and returns a subset of segs that were rendered\r\n\t\tsegs = this.eventRenderer.renderFgSegEls(segs);\r\n\r\n\t\tfor (i = 0; i < segs.length; i++) {\r\n\t\t\tsegs[i].el.addClass(classNames);\r\n\t\t}\r\n\r\n\t\tif (opacity != null) {\r\n\t\t\tfor (i = 0; i < segs.length; i++) {\r\n\t\t\t\tsegs[i].el.css('opacity', opacity);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis.helperEls = this.renderSegs(segs, sourceSeg);\r\n\t},\r\n\r\n\r\n\t/*\r\n\tMust return all mock event elements\r\n\t*/\r\n\trenderSegs: function(segs, sourceSeg) {\r\n\t\t// Subclasses must implement\r\n\t},\r\n\r\n\r\n\tunrender: function() {\r\n\t\tif (this.helperEls) {\r\n\t\t\tthis.helperEls.remove();\r\n\t\t\tthis.helperEls = null;\r\n\t\t}\r\n\t},\r\n\r\n\r\n\tfabricateEventFootprint: function(componentFootprint) {\r\n\t\tvar calendar = this.view.calendar;\r\n\t\tvar eventDateProfile = calendar.footprintToDateProfile(componentFootprint);\r\n\t\tvar dummyEvent = new SingleEventDef(new EventSource(calendar));\r\n\t\tvar dummyInstance;\r\n\r\n\t\tdummyEvent.dateProfile = eventDateProfile;\r\n\t\tdummyInstance = dummyEvent.buildInstance();\r\n\r\n\t\treturn new EventFootprint(componentFootprint, dummyEvent, dummyInstance);\r\n\t}\r\n\r\n});\r\n\r\n;;\r\n\r\nvar Component = Model.extend({\r\n\r\n\tel: null,\r\n\r\n\r\n\tsetElement: function(el) {\r\n\t\tthis.el = el;\r\n\t\tthis.bindGlobalHandlers();\r\n\t\tthis.renderSkeleton();\r\n\t\tthis.set('isInDom', true);\r\n\t},\r\n\r\n\r\n\tremoveElement: function() {\r\n\t\tthis.unset('isInDom');\r\n\t\tthis.unrenderSkeleton();\r\n\t\tthis.unbindGlobalHandlers();\r\n\r\n\t\tthis.el.remove();\r\n\t\t// NOTE: don't null-out this.el in case the View was destroyed within an API callback.\r\n\t\t// We don't null-out the View's other jQuery element references upon destroy,\r\n\t\t//  so we shouldn't kill this.el either.\r\n\t},\r\n\r\n\r\n\tbindGlobalHandlers: function() {\r\n\t},\r\n\r\n\r\n\tunbindGlobalHandlers: function() {\r\n\t},\r\n\r\n\r\n\t/*\r\n\tNOTE: Can't have a `render` method. Read the deprecation notice in View::executeDateRender\r\n\t*/\r\n\r\n\r\n\t// Renders the basic structure of the view before any content is rendered\r\n\trenderSkeleton: function() {\r\n\t\t// subclasses should implement\r\n\t},\r\n\r\n\r\n\t// Unrenders the basic structure of the view\r\n\tunrenderSkeleton: function() {\r\n\t\t// subclasses should implement\r\n\t}\r\n\r\n});\r\n\r\n;;\r\n\r\nvar DateComponent = FC.DateComponent = Component.extend({\r\n\r\n\tuid: null,\r\n\tchildrenByUid: null,\r\n\tisRTL: false, // frequently accessed options\r\n\tnextDayThreshold: null, // \"\r\n\tdateProfile: null, // hack\r\n\r\n\teventRendererClass: null,\r\n\thelperRendererClass: null,\r\n\tbusinessHourRendererClass: null,\r\n\tfillRendererClass: null,\r\n\r\n\teventRenderer: null,\r\n\thelperRenderer: null,\r\n\tbusinessHourRenderer: null,\r\n\tfillRenderer: null,\r\n\r\n\thitsNeededDepth: 0, // necessary because multiple callers might need the same hits\r\n\r\n\thasAllDayBusinessHours: false, // TODO: unify with largeUnit and isTimeScale?\r\n\r\n\tisDatesRendered: false,\r\n\r\n\r\n\tconstructor: function() {\r\n\t\tComponent.call(this);\r\n\r\n\t\tthis.uid = String(DateComponent.guid++);\r\n\t\tthis.childrenByUid = {};\r\n\r\n\t\tthis.nextDayThreshold = moment.duration(this.opt('nextDayThreshold'));\r\n\t\tthis.isRTL = this.opt('isRTL');\r\n\r\n\t\tif (this.fillRendererClass) {\r\n\t\t\tthis.fillRenderer = new this.fillRendererClass(this);\r\n\t\t}\r\n\r\n\t\tif (this.eventRendererClass) { // fillRenderer is optional -----v\r\n\t\t\tthis.eventRenderer = new this.eventRendererClass(this, this.fillRenderer);\r\n\t\t}\r\n\r\n\t\tif (this.helperRendererClass && this.eventRenderer) {\r\n\t\t\tthis.helperRenderer = new this.helperRendererClass(this, this.eventRenderer);\r\n\t\t}\r\n\r\n\t\tif (this.businessHourRendererClass && this.fillRenderer) {\r\n\t\t\tthis.businessHourRenderer = new this.businessHourRendererClass(this, this.fillRenderer);\r\n\t\t}\r\n\t},\r\n\r\n\r\n\taddChild: function(child) {\r\n\t\tif (!this.childrenByUid[child.uid]) {\r\n\t\t\tthis.childrenByUid[child.uid] = child;\r\n\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\t},\r\n\r\n\r\n\tremoveChild: function(child) {\r\n\t\tif (this.childrenByUid[child.uid]) {\r\n\t\t\tdelete this.childrenByUid[child.uid];\r\n\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\t},\r\n\r\n\r\n\t// TODO: only do if isInDom?\r\n\t// TODO: make part of Component, along with children/batch-render system?\r\n\tupdateSize: function(totalHeight, isAuto, isResize) {\r\n\t\tthis.callChildren('updateSize', arguments);\r\n\t},\r\n\r\n\r\n\t// Options\r\n\t// -----------------------------------------------------------------------------------------------------------------\r\n\r\n\r\n\topt: function(name) {\r\n\t\treturn this._getView().opt(name); // default implementation\r\n\t},\r\n\r\n\r\n\tpubliclyTrigger: function(/**/) {\r\n\t\tvar calendar = this._getCalendar();\r\n\r\n\t\treturn calendar.publiclyTrigger.apply(calendar, arguments);\r\n\t},\r\n\r\n\r\n\thasPublicHandlers: function(/**/) {\r\n\t\tvar calendar = this._getCalendar();\r\n\r\n\t\treturn calendar.hasPublicHandlers.apply(calendar, arguments);\r\n\t},\r\n\r\n\r\n\t// Date\r\n\t// -----------------------------------------------------------------------------------------------------------------\r\n\r\n\r\n\texecuteDateRender: function(dateProfile) {\r\n\t\tthis.dateProfile = dateProfile; // for rendering\r\n\t\tthis.renderDates(dateProfile);\r\n\t\tthis.isDatesRendered = true;\r\n\t\tthis.callChildren('executeDateRender', arguments);\r\n\t},\r\n\r\n\r\n\texecuteDateUnrender: function() { // wrapper\r\n\t\tthis.callChildren('executeDateUnrender', arguments);\r\n\t\tthis.dateProfile = null;\r\n\t\tthis.unrenderDates();\r\n\t\tthis.isDatesRendered = false;\r\n\t},\r\n\r\n\r\n\t// date-cell content only\r\n\trenderDates: function(dateProfile) {\r\n\t\t// subclasses should implement\r\n\t},\r\n\r\n\r\n\t// date-cell content only\r\n\tunrenderDates: function() {\r\n\t\t// subclasses should override\r\n\t},\r\n\r\n\r\n\t// Now-Indicator\r\n\t// -----------------------------------------------------------------------------------------------------------------\r\n\r\n\r\n\t// Returns a string unit, like 'second' or 'minute' that defined how often the current time indicator\r\n\t// should be refreshed. If something falsy is returned, no time indicator is rendered at all.\r\n\tgetNowIndicatorUnit: function() {\r\n\t\t// subclasses should implement\r\n\t},\r\n\r\n\r\n\t// Renders a current time indicator at the given datetime\r\n\trenderNowIndicator: function(date) {\r\n\t\tthis.callChildren('renderNowIndicator', arguments);\r\n\t},\r\n\r\n\r\n\t// Undoes the rendering actions from renderNowIndicator\r\n\tunrenderNowIndicator: function() {\r\n\t\tthis.callChildren('unrenderNowIndicator', arguments);\r\n\t},\r\n\r\n\r\n\t// Business Hours\r\n\t// ---------------------------------------------------------------------------------------------------------------\r\n\r\n\r\n\trenderBusinessHours: function(businessHourGenerator) {\r\n\t\tif (this.businessHourRenderer) {\r\n\t\t\tthis.businessHourRenderer.render(businessHourGenerator);\r\n\t\t}\r\n\r\n\t\tthis.callChildren('renderBusinessHours', arguments);\r\n\t},\r\n\r\n\r\n\t// Unrenders previously-rendered business-hours\r\n\tunrenderBusinessHours: function() {\r\n\t\tthis.callChildren('unrenderBusinessHours', arguments);\r\n\r\n\t\tif (this.businessHourRenderer) {\r\n\t\t\tthis.businessHourRenderer.unrender();\r\n\t\t}\r\n\t},\r\n\r\n\r\n\t// Event Displaying\r\n\t// -----------------------------------------------------------------------------------------------------------------\r\n\r\n\r\n\texecuteEventRender: function(eventsPayload) {\r\n\t\tif (this.eventRenderer) {\r\n\t\t\tthis.eventRenderer.rangeUpdated(); // poorly named now\r\n\t\t\tthis.eventRenderer.render(eventsPayload);\r\n\t\t}\r\n\t\telse if (this.renderEvents) { // legacy\r\n\t\t\tthis.renderEvents(convertEventsPayloadToLegacyArray(eventsPayload));\r\n\t\t}\r\n\r\n\t\tthis.callChildren('executeEventRender', arguments);\r\n\t},\r\n\r\n\r\n\texecuteEventUnrender: function() {\r\n\t\tthis.callChildren('executeEventUnrender', arguments);\r\n\r\n\t\tif (this.eventRenderer) {\r\n\t\t\tthis.eventRenderer.unrender();\r\n\t\t}\r\n\t\telse if (this.destroyEvents) { // legacy\r\n\t\t\tthis.destroyEvents();\r\n\t\t}\r\n\t},\r\n\r\n\r\n\tgetBusinessHourSegs: function() { // recursive\r\n\t\tvar segs = this.getOwnBusinessHourSegs();\r\n\r\n\t\tthis.iterChildren(function(child) {\r\n\t\t\tsegs.push.apply(segs, child.getBusinessHourSegs());\r\n\t\t});\r\n\r\n\t\treturn segs;\r\n\t},\r\n\r\n\r\n\tgetOwnBusinessHourSegs: function() {\r\n\t\tif (this.businessHourRenderer) {\r\n\t\t\treturn this.businessHourRenderer.getSegs();\r\n\t\t}\r\n\r\n\t\treturn [];\r\n\t},\r\n\r\n\r\n\tgetEventSegs: function() { // recursive\r\n\t\tvar segs = this.getOwnEventSegs();\r\n\r\n\t\tthis.iterChildren(function(child) {\r\n\t\t\tsegs.push.apply(segs, child.getEventSegs());\r\n\t\t});\r\n\r\n\t\treturn segs;\r\n\t},\r\n\r\n\r\n\tgetOwnEventSegs: function() { // just for itself\r\n\t\tif (this.eventRenderer) {\r\n\t\t\treturn this.eventRenderer.getSegs();\r\n\t\t}\r\n\r\n\t\treturn [];\r\n\t},\r\n\r\n\r\n\t// Event Rendering Triggering\r\n\t// -----------------------------------------------------------------------------------------------------------------\r\n\r\n\r\n\ttriggerAfterEventsRendered: function() {\r\n\t\tthis.triggerAfterEventSegsRendered(\r\n\t\t\tthis.getEventSegs()\r\n\t\t);\r\n\r\n\t\tthis.publiclyTrigger('eventAfterAllRender', {\r\n\t\t\tcontext: this,\r\n\t\t\targs: [ this ]\r\n\t\t});\r\n\t},\r\n\r\n\r\n\ttriggerAfterEventSegsRendered: function(segs) {\r\n\t\tvar _this = this;\r\n\r\n\t\t// an optimization, because getEventLegacy is expensive\r\n\t\tif (this.hasPublicHandlers('eventAfterRender')) {\r\n\t\t\tsegs.forEach(function(seg) {\r\n\t\t\t\tvar legacy;\r\n\r\n\t\t\t\tif (seg.el) { // necessary?\r\n\t\t\t\t\tlegacy = seg.footprint.getEventLegacy();\r\n\r\n\t\t\t\t\t_this.publiclyTrigger('eventAfterRender', {\r\n\t\t\t\t\t\tcontext: legacy,\r\n\t\t\t\t\t\targs: [ legacy, seg.el, _this ]\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\t},\r\n\r\n\r\n\ttriggerBeforeEventsDestroyed: function() {\r\n\t\tthis.triggerBeforeEventSegsDestroyed(\r\n\t\t\tthis.getEventSegs()\r\n\t\t);\r\n\t},\r\n\r\n\r\n\ttriggerBeforeEventSegsDestroyed: function(segs) {\r\n\t\tvar _this = this;\r\n\r\n\t\tif (this.hasPublicHandlers('eventDestroy')) {\r\n\t\t\tsegs.forEach(function(seg) {\r\n\t\t\t\tvar legacy;\r\n\r\n\t\t\t\tif (seg.el) { // necessary?\r\n\t\t\t\t\tlegacy = seg.footprint.getEventLegacy();\r\n\r\n\t\t\t\t\t_this.publiclyTrigger('eventDestroy', {\r\n\t\t\t\t\t\tcontext: legacy,\r\n\t\t\t\t\t\targs: [ legacy, seg.el, _this ]\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\t},\r\n\r\n\r\n\t// Event Rendering Utils\r\n\t// -----------------------------------------------------------------------------------------------------------------\r\n\r\n\r\n\t// Hides all rendered event segments linked to the given event\r\n\t// RECURSIVE with subcomponents\r\n\tshowEventsWithId: function(eventDefId) {\r\n\r\n\t\tthis.getEventSegs().forEach(function(seg) {\r\n\t\t\tif (\r\n\t\t\t\tseg.footprint.eventDef.id === eventDefId &&\r\n\t\t\t\tseg.el // necessary?\r\n\t\t\t) {\r\n\t\t\t\tseg.el.css('visibility', '');\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tthis.callChildren('showEventsWithId', arguments);\r\n\t},\r\n\r\n\r\n\t// Shows all rendered event segments linked to the given event\r\n\t// RECURSIVE with subcomponents\r\n\thideEventsWithId: function(eventDefId) {\r\n\r\n\t\tthis.getEventSegs().forEach(function(seg) {\r\n\t\t\tif (\r\n\t\t\t\tseg.footprint.eventDef.id === eventDefId &&\r\n\t\t\t\tseg.el // necessary?\r\n\t\t\t) {\r\n\t\t\t\tseg.el.css('visibility', 'hidden');\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tthis.callChildren('hideEventsWithId', arguments);\r\n\t},\r\n\r\n\r\n\t// Drag-n-Drop Rendering (for both events and external elements)\r\n\t// ---------------------------------------------------------------------------------------------------------------\r\n\r\n\r\n\t// Renders a visual indication of a event or external-element drag over the given drop zone.\r\n\t// If an external-element, seg will be `null`.\r\n\t// Must return elements used for any mock events.\r\n\trenderDrag: function(eventFootprints, seg, isTouch) {\r\n\t\tvar renderedHelper = false;\r\n\r\n\t\tthis.iterChildren(function(child) {\r\n\t\t\tif (child.renderDrag(eventFootprints, seg, isTouch)) {\r\n\t\t\t\trenderedHelper = true;\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\treturn renderedHelper;\r\n\t},\r\n\r\n\r\n\t// Unrenders a visual indication of an event or external-element being dragged.\r\n\tunrenderDrag: function() {\r\n\t\tthis.callChildren('unrenderDrag', arguments);\r\n\t},\r\n\r\n\r\n\t// Event Resizing\r\n\t// ---------------------------------------------------------------------------------------------------------------\r\n\r\n\r\n\t// Renders a visual indication of an event being resized.\r\n\trenderEventResize: function(eventFootprints, seg, isTouch) {\r\n\t\tthis.callChildren('renderEventResize', arguments);\r\n\t},\r\n\r\n\r\n\t// Unrenders a visual indication of an event being resized.\r\n\tunrenderEventResize: function() {\r\n\t\tthis.callChildren('unrenderEventResize', arguments);\r\n\t},\r\n\r\n\r\n\t// Selection\r\n\t// ---------------------------------------------------------------------------------------------------------------\r\n\r\n\r\n\t// Renders a visual indication of the selection\r\n\t// TODO: rename to `renderSelection` after legacy is gone\r\n\trenderSelectionFootprint: function(componentFootprint) {\r\n\t\tthis.renderHighlight(componentFootprint);\r\n\r\n\t\tthis.callChildren('renderSelectionFootprint', arguments);\r\n\t},\r\n\r\n\r\n\t// Unrenders a visual indication of selection\r\n\tunrenderSelection: function() {\r\n\t\tthis.unrenderHighlight();\r\n\r\n\t\tthis.callChildren('unrenderSelection', arguments);\r\n\t},\r\n\r\n\r\n\t// Highlight\r\n\t// ---------------------------------------------------------------------------------------------------------------\r\n\r\n\r\n\t// Renders an emphasis on the given date range. Given a span (unzoned start/end and other misc data)\r\n\trenderHighlight: function(componentFootprint) {\r\n\t\tif (this.fillRenderer) {\r\n\t\t\tthis.fillRenderer.renderFootprint(\r\n\t\t\t\t'highlight',\r\n\t\t\t\tcomponentFootprint,\r\n\t\t\t\t{\r\n\t\t\t\t\tgetClasses: function() {\r\n\t\t\t\t\t\treturn [ 'fc-highlight' ];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\tthis.callChildren('renderHighlight', arguments);\r\n\t},\r\n\r\n\r\n\t// Unrenders the emphasis on a date range\r\n\tunrenderHighlight: function() {\r\n\t\tif (this.fillRenderer) {\r\n\t\t\tthis.fillRenderer.unrender('highlight');\r\n\t\t}\r\n\r\n\t\tthis.callChildren('unrenderHighlight', arguments);\r\n\t},\r\n\r\n\r\n\t// Hit Areas\r\n\t// ---------------------------------------------------------------------------------------------------------------\r\n\t// just because all DateComponents support this interface\r\n\t// doesn't mean they need to have their own internal coord system. they can defer to sub-components.\r\n\r\n\r\n\thitsNeeded: function() {\r\n\t\tif (!(this.hitsNeededDepth++)) {\r\n\t\t\tthis.prepareHits();\r\n\t\t}\r\n\r\n\t\tthis.callChildren('hitsNeeded', arguments);\r\n\t},\r\n\r\n\r\n\thitsNotNeeded: function() {\r\n\t\tif (this.hitsNeededDepth && !(--this.hitsNeededDepth)) {\r\n\t\t\tthis.releaseHits();\r\n\t\t}\r\n\r\n\t\tthis.callChildren('hitsNotNeeded', arguments);\r\n\t},\r\n\r\n\r\n\tprepareHits: function() {\r\n\t\t// subclasses can implement\r\n\t},\r\n\r\n\r\n\treleaseHits: function() {\r\n\t\t// subclasses can implement\r\n\t},\r\n\r\n\r\n\t// Given coordinates from the topleft of the document, return data about the date-related area underneath.\r\n\t// Can return an object with arbitrary properties (although top/right/left/bottom are encouraged).\r\n\t// Must have a `grid` property, a reference to this current grid. TODO: avoid this\r\n\t// The returned object will be processed by getHitFootprint and getHitEl.\r\n\tqueryHit: function(leftOffset, topOffset) {\r\n\t\tvar childrenByUid = this.childrenByUid;\r\n\t\tvar uid;\r\n\t\tvar hit;\r\n\r\n\t\tfor (uid in childrenByUid) {\r\n\t\t\thit = childrenByUid[uid].queryHit(leftOffset, topOffset);\r\n\r\n\t\t\tif (hit) {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn hit;\r\n\t},\r\n\r\n\r\n\tgetSafeHitFootprint: function(hit) {\r\n\t\tvar footprint = this.getHitFootprint(hit);\r\n\r\n\t\tif (!this.dateProfile.activeUnzonedRange.containsRange(footprint.unzonedRange)) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\treturn footprint;\r\n\t},\r\n\r\n\r\n\tgetHitFootprint: function(hit) {\r\n\t},\r\n\r\n\r\n\t// Given position-level information about a date-related area within the grid,\r\n\t// should return a jQuery element that best represents it. passed to dayClick callback.\r\n\tgetHitEl: function(hit) {\r\n\t},\r\n\r\n\r\n\t/* Converting eventRange -> eventFootprint\r\n\t------------------------------------------------------------------------------------------------------------------*/\r\n\r\n\r\n\teventRangesToEventFootprints: function(eventRanges) {\r\n\t\tvar eventFootprints = [];\r\n\t\tvar i;\r\n\r\n\t\tfor (i = 0; i < eventRanges.length; i++) {\r\n\t\t\teventFootprints.push.apply( // append\r\n\t\t\t\teventFootprints,\r\n\t\t\t\tthis.eventRangeToEventFootprints(eventRanges[i])\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\treturn eventFootprints;\r\n\t},\r\n\r\n\r\n\teventRangeToEventFootprints: function(eventRange) {\r\n\t\treturn [ eventRangeToEventFootprint(eventRange) ];\r\n\t},\r\n\r\n\r\n\t/* Converting componentFootprint/eventFootprint -> segs\r\n\t------------------------------------------------------------------------------------------------------------------*/\r\n\r\n\r\n\teventFootprintsToSegs: function(eventFootprints) {\r\n\t\tvar segs = [];\r\n\t\tvar i;\r\n\r\n\t\tfor (i = 0; i < eventFootprints.length; i++) {\r\n\t\t\tsegs.push.apply(segs,\r\n\t\t\t\tthis.eventFootprintToSegs(eventFootprints[i])\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\treturn segs;\r\n\t},\r\n\r\n\r\n\t// Given an event's span (unzoned start/end and other misc data), and the event itself,\r\n\t// slices into segments and attaches event-derived properties to them.\r\n\t// eventSpan - { start, end, isStart, isEnd, otherthings... }\r\n\teventFootprintToSegs: function(eventFootprint) {\r\n\t\tvar unzonedRange = eventFootprint.componentFootprint.unzonedRange;\r\n\t\tvar segs;\r\n\t\tvar i, seg;\r\n\r\n\t\tsegs = this.componentFootprintToSegs(eventFootprint.componentFootprint);\r\n\r\n\t\tfor (i = 0; i < segs.length; i++) {\r\n\t\t\tseg = segs[i];\r\n\r\n\t\t\tif (!unzonedRange.isStart) {\r\n\t\t\t\tseg.isStart = false;\r\n\t\t\t}\r\n\t\t\tif (!unzonedRange.isEnd) {\r\n\t\t\t\tseg.isEnd = false;\r\n\t\t\t}\r\n\r\n\t\t\tseg.footprint = eventFootprint;\r\n\t\t\t// TODO: rename to seg.eventFootprint\r\n\t\t}\r\n\r\n\t\treturn segs;\r\n\t},\r\n\r\n\r\n\tcomponentFootprintToSegs: function(componentFootprint) {\r\n\t\treturn [];\r\n\t},\r\n\r\n\r\n\t// Utils\r\n\t// ---------------------------------------------------------------------------------------------------------------\r\n\r\n\r\n\tcallChildren: function(methodName, args) {\r\n\t\tthis.iterChildren(function(child) {\r\n\t\t\tchild[methodName].apply(child, args);\r\n\t\t});\r\n\t},\r\n\r\n\r\n\titerChildren: function(func) {\r\n\t\tvar childrenByUid = this.childrenByUid;\r\n\t\tvar uid;\r\n\r\n\t\tfor (uid in childrenByUid) {\r\n\t\t\tfunc(childrenByUid[uid]);\r\n\t\t}\r\n\t},\r\n\r\n\r\n\t_getCalendar: function() { // TODO: strip out. move to generic parent.\r\n\t\treturn this.calendar || this.view.calendar;\r\n\t},\r\n\r\n\r\n\t_getView: function() { // TODO: strip out. move to generic parent.\r\n\t\treturn this.view;\r\n\t},\r\n\r\n\r\n\t_getDateProfile: function() {\r\n\t\treturn this._getView().get('dateProfile');\r\n\t}\r\n\r\n});\r\n\r\n\r\nDateComponent.guid = 0; // TODO: better system for this?\r\n\r\n\r\n// legacy\r\n\r\nfunction convertEventsPayloadToLegacyArray(eventsPayload) {\r\n\tvar eventDefId;\r\n\tvar eventInstances;\r\n\tvar legacyEvents = [];\r\n\tvar i;\r\n\r\n\tfor (eventDefId in eventsPayload) {\r\n\t\teventInstances = eventsPayload[eventDefId].eventInstances;\r\n\r\n\t\tfor (i = 0; i < eventInstances.length; i++) {\r\n\t\t\tlegacyEvents.push(\r\n\t\t\t\teventInstances[i].toLegacy()\r\n\t\t\t);\r\n\t\t}\r\n\t}\r\n\r\n\treturn legacyEvents;\r\n}\r\n\r\n;;\r\n\r\nDateComponent.mixin({\r\n\r\n\t// Generates HTML for an anchor to another view into the calendar.\r\n\t// Will either generate an <a> tag or a non-clickable <span> tag, depending on enabled settings.\r\n\t// `gotoOptions` can either be a moment input, or an object with the form:\r\n\t// { date, type, forceOff }\r\n\t// `type` is a view-type like \"day\" or \"week\". default value is \"day\".\r\n\t// `attrs` and `innerHtml` are use to generate the rest of the HTML tag.\r\n\tbuildGotoAnchorHtml: function(gotoOptions, attrs, innerHtml) {\r\n\t\tvar date, type, forceOff;\r\n\t\tvar finalOptions;\r\n\r\n\t\tif ($.isPlainObject(gotoOptions)) {\r\n\t\t\tdate = gotoOptions.date;\r\n\t\t\ttype = gotoOptions.type;\r\n\t\t\tforceOff = gotoOptions.forceOff;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tdate = gotoOptions; // a single moment input\r\n\t\t}\r\n\t\tdate = FC.moment(date); // if a string, parse it\r\n\r\n\t\tfinalOptions = { // for serialization into the link\r\n\t\t\tdate: date.format('YYYY-MM-DD'),\r\n\t\t\ttype: type || 'day'\r\n\t\t};\r\n\r\n\t\tif (typeof attrs === 'string') {\r\n\t\t\tinnerHtml = attrs;\r\n\t\t\tattrs = null;\r\n\t\t}\r\n\r\n\t\tattrs = attrs ? ' ' + attrsToStr(attrs) : ''; // will have a leading space\r\n\t\tinnerHtml = innerHtml || '';\r\n\r\n\t\tif (!forceOff && this.opt('navLinks')) {\r\n\t\t\treturn '<a' + attrs +\r\n\t\t\t\t' data-goto=\"' + htmlEscape(JSON.stringify(finalOptions)) + '\">' +\r\n\t\t\t\tinnerHtml +\r\n\t\t\t\t'</a>';\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn '<span' + attrs + '>' +\r\n\t\t\t\tinnerHtml +\r\n\t\t\t\t'</span>';\r\n\t\t}\r\n\t},\r\n\r\n\r\n\tgetAllDayHtml: function() {\r\n\t\treturn this.opt('allDayHtml') || htmlEscape(this.opt('allDayText'));\r\n\t},\r\n\r\n\r\n\t// Computes HTML classNames for a single-day element\r\n\tgetDayClasses: function(date, noThemeHighlight) {\r\n\t\tvar view = this._getView();\r\n\t\tvar classes = [];\r\n\t\tvar today;\r\n\r\n\t\tif (!this.dateProfile.activeUnzonedRange.containsDate(date)) {\r\n\t\t\tclasses.push('fc-disabled-day'); // TODO: jQuery UI theme?\r\n\t\t}\r\n\t\telse {\r\n\t\t\tclasses.push('fc-' + dayIDs[date.day()]);\r\n\r\n\t\t\tif (view.isDateInOtherMonth(date, this.dateProfile)) { // TODO: use DateComponent subclass somehow\r\n\t\t\t\tclasses.push('fc-other-month');\r\n\t\t\t}\r\n\r\n\t\t\ttoday = view.calendar.getNow();\r\n\r\n\t\t\tif (date.isSame(today, 'day')) {\r\n\t\t\t\tclasses.push('fc-today');\r\n\r\n\t\t\t\tif (noThemeHighlight !== true) {\r\n\t\t\t\t\tclasses.push(view.calendar.theme.getClass('today'));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse if (date < today) {\r\n\t\t\t\tclasses.push('fc-past');\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tclasses.push('fc-future');\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn classes;\r\n\t},\r\n\r\n\r\n\t// Utility for formatting a range. Accepts a range object, formatting string, and optional separator.\r\n\t// Displays all-day ranges naturally, with an inclusive end. Takes the current isRTL into account.\r\n\t// The timezones of the dates within `range` will be respected.\r\n\tformatRange: function(range, isAllDay, formatStr, separator) {\r\n\t\tvar end = range.end;\r\n\r\n\t\tif (isAllDay) {\r\n\t\t\tend = end.clone().subtract(1); // convert to inclusive. last ms of previous day\r\n\t\t}\r\n\r\n\t\treturn formatRange(range.start, end, formatStr, separator, this.isRTL);\r\n\t},\r\n\r\n\r\n\t// Compute the number of the give units in the \"current\" range.\r\n\t// Will return a floating-point number. Won't round.\r\n\tcurrentRangeAs: function(unit) {\r\n\t\treturn this._getDateProfile().currentUnzonedRange.as(unit);\r\n\t},\r\n\r\n\r\n\t// Returns the date range of the full days the given range visually appears to occupy.\r\n\t// Returns a plain object with start/end, NOT an UnzonedRange!\r\n\tcomputeDayRange: function(unzonedRange) {\r\n\t\tvar calendar = this._getCalendar();\r\n\t\tvar startDay = calendar.msToUtcMoment(unzonedRange.startMs, true); // the beginning of the day the range starts\r\n\t\tvar end = calendar.msToUtcMoment(unzonedRange.endMs);\r\n\t\tvar endTimeMS = +end.time(); // # of milliseconds into `endDay`\r\n\t\tvar endDay = end.clone().stripTime(); // the beginning of the day the range exclusively ends\r\n\r\n\t\t// If the end time is actually inclusively part of the next day and is equal to or\r\n\t\t// beyond the next day threshold, adjust the end to be the exclusive end of `endDay`.\r\n\t\t// Otherwise, leaving it as inclusive will cause it to exclude `endDay`.\r\n\t\tif (endTimeMS && endTimeMS >= this.nextDayThreshold) {\r\n\t\t\tendDay.add(1, 'days');\r\n\t\t}\r\n\r\n\t\t// If end is within `startDay` but not past nextDayThreshold, assign the default duration of one day.\r\n\t\tif (endDay <= startDay) {\r\n\t\t\tendDay = startDay.clone().add(1, 'days');\r\n\t\t}\r\n\r\n\t\treturn { start: startDay, end: endDay };\r\n\t},\r\n\r\n\r\n\t// Does the given range visually appear to occupy more than one day?\r\n\tisMultiDayRange: function(unzonedRange) {\r\n\t\tvar dayRange = this.computeDayRange(unzonedRange);\r\n\r\n\t\treturn dayRange.end.diff(dayRange.start, 'days') > 1;\r\n\t}\r\n\r\n});\r\n\r\n;;\r\n\r\nvar InteractiveDateComponent = FC.InteractiveDateComponent = DateComponent.extend({\r\n\r\n\tdateClickingClass: null,\r\n\tdateSelectingClass: null,\r\n\teventPointingClass: null,\r\n\teventDraggingClass: null,\r\n\teventResizingClass: null,\r\n\texternalDroppingClass: null,\r\n\r\n\tdateClicking: null,\r\n\tdateSelecting: null,\r\n\teventPointing: null,\r\n\teventDragging: null,\r\n\teventResizing: null,\r\n\texternalDropping: null,\r\n\r\n\t// self-config, overridable by subclasses\r\n\tsegSelector: '.fc-event-container > *', // what constitutes an event element?\r\n\r\n\t// if defined, holds the unit identified (ex: \"year\" or \"month\") that determines the level of granularity\r\n\t// of the date areas. if not defined, assumes to be day and time granularity.\r\n\t// TODO: port isTimeScale into same system?\r\n\tlargeUnit: null,\r\n\r\n\r\n\tconstructor: function() {\r\n\t\tDateComponent.call(this);\r\n\r\n\t\tif (this.dateSelectingClass) {\r\n\t\t\tthis.dateClicking = new this.dateClickingClass(this);\r\n\t\t}\r\n\r\n\t\tif (this.dateSelectingClass) {\r\n\t\t\tthis.dateSelecting = new this.dateSelectingClass(this);\r\n\t\t}\r\n\r\n\t\tif (this.eventPointingClass) {\r\n\t\t\tthis.eventPointing = new this.eventPointingClass(this);\r\n\t\t}\r\n\r\n\t\tif (this.eventDraggingClass && this.eventPointing) {\r\n\t\t\tthis.eventDragging = new this.eventDraggingClass(this, this.eventPointing);\r\n\t\t}\r\n\r\n\t\tif (this.eventResizingClass && this.eventPointing) {\r\n\t\t\tthis.eventResizing = new this.eventResizingClass(this, this.eventPointing);\r\n\t\t}\r\n\r\n\t\tif (this.externalDroppingClass) {\r\n\t\t\tthis.externalDropping = new this.externalDroppingClass(this);\r\n\t\t}\r\n\t},\r\n\r\n\r\n\t// Sets the container element that the view should render inside of, does global DOM-related initializations,\r\n\t// and renders all the non-date-related content inside.\r\n\tsetElement: function(el) {\r\n\t\tDateComponent.prototype.setElement.apply(this, arguments);\r\n\r\n\t\tif (this.dateClicking) {\r\n\t\t\tthis.dateClicking.bindToEl(el);\r\n\t\t}\r\n\r\n\t\tif (this.dateSelecting) {\r\n\t\t\tthis.dateSelecting.bindToEl(el);\r\n\t\t}\r\n\r\n\t\tthis.bindAllSegHandlersToEl(el);\r\n\t},\r\n\r\n\r\n\tunrender: function() {\r\n\t\tthis.endInteractions();\r\n\r\n\t\tDateComponent.prototype.unrender.apply(this, arguments);\r\n\t},\r\n\r\n\r\n\texecuteEventUnrender: function() {\r\n\t\tthis.endInteractions();\r\n\r\n\t\tDateComponent.prototype.executeEventUnrender.apply(this, arguments);\r\n\t},\r\n\r\n\r\n\tbindGlobalHandlers: function() {\r\n\t\tDateComponent.prototype.bindGlobalHandlers.apply(this, arguments);\r\n\r\n\t\tif (this.externalDropping) {\r\n\t\t\tthis.externalDropping.bindToDocument();\r\n\t\t}\r\n\t},\r\n\r\n\r\n\tunbindGlobalHandlers: function() {\r\n\t\tDateComponent.prototype.unbindGlobalHandlers.apply(this, arguments);\r\n\r\n\t\tif (this.externalDropping) {\r\n\t\t\tthis.externalDropping.unbindFromDocument();\r\n\t\t}\r\n\t},\r\n\r\n\r\n\tbindDateHandlerToEl: function(el, name, handler) {\r\n\t\tvar _this = this;\r\n\r\n\t\t// attach a handler to the grid's root element.\r\n\t\t// jQuery will take care of unregistering them when removeElement gets called.\r\n\t\tthis.el.on(name, function(ev) {\r\n\t\t\tif (\r\n\t\t\t\t!$(ev.target).is(\r\n\t\t\t\t\t_this.segSelector + ',' + // directly on an event element\r\n\t\t\t\t\t_this.segSelector + ' *,' + // within an event element\r\n\t\t\t\t\t'.fc-more,' + // a \"more..\" link\r\n\t\t\t\t\t'a[data-goto]' // a clickable nav link\r\n\t\t\t\t)\r\n\t\t\t) {\r\n\t\t\t\treturn handler.call(_this, ev);\r\n\t\t\t}\r\n\t\t});\r\n\t},\r\n\r\n\r\n\tbindAllSegHandlersToEl: function(el) {\r\n\t\t[\r\n\t\t\tthis.eventPointing,\r\n\t\t\tthis.eventDragging,\r\n\t\t\tthis.eventResizing\r\n\t\t].forEach(function(eventInteraction) {\r\n\t\t\tif (eventInteraction) {\r\n\t\t\t\teventInteraction.bindToEl(el);\r\n\t\t\t}\r\n\t\t});\r\n\t},\r\n\r\n\r\n\tbindSegHandlerToEl: function(el, name, handler) {\r\n\t\tvar _this = this;\r\n\r\n\t\tel.on(name, this.segSelector, function(ev) {\r\n\t\t\tvar seg = $(this).data('fc-seg'); // grab segment data. put there by View::renderEventsPayload\r\n\r\n\t\t\tif (seg && !_this.shouldIgnoreEventPointing()) {\r\n\t\t\t\treturn handler.call(_this, seg, ev); // context will be the Grid\r\n\t\t\t}\r\n\t\t});\r\n\t},\r\n\r\n\r\n\tshouldIgnoreMouse: function() {\r\n\t\t// HACK\r\n\t\t// This will still work even though bindDateHandlerToEl doesn't use GlobalEmitter.\r\n\t\treturn GlobalEmitter.get().shouldIgnoreMouse();\r\n\t},\r\n\r\n\r\n\tshouldIgnoreTouch: function() {\r\n\t\tvar view = this._getView();\r\n\r\n\t\t// On iOS (and Android?) when a new selection is initiated overtop another selection,\r\n\t\t// the touchend never fires because the elements gets removed mid-touch-interaction (my theory).\r\n\t\t// HACK: simply don't allow this to happen.\r\n\t\t// ALSO: prevent selection when an *event* is already raised.\r\n\t\treturn view.isSelected || view.selectedEvent;\r\n\t},\r\n\r\n\r\n\tshouldIgnoreEventPointing: function() {\r\n\t\t// only call the handlers if there is not a drag/resize in progress\r\n\t\treturn (this.eventDragging && this.eventDragging.isDragging) ||\r\n\t\t\t(this.eventResizing && this.eventResizing.isResizing);\r\n\t},\r\n\r\n\r\n\tcanStartSelection: function(seg, ev) {\r\n\t\treturn getEvIsTouch(ev) &&\r\n\t\t\t!this.canStartResize(seg, ev) &&\r\n\t\t\t(this.isEventDefDraggable(seg.footprint.eventDef) ||\r\n\t\t\t this.isEventDefResizable(seg.footprint.eventDef));\r\n\t},\r\n\r\n\r\n\tcanStartDrag: function(seg, ev) {\r\n\t\treturn !this.canStartResize(seg, ev) &&\r\n\t\t\tthis.isEventDefDraggable(seg.footprint.eventDef);\r\n\t},\r\n\r\n\r\n\tcanStartResize: function(seg, ev) {\r\n\t\tvar view = this._getView();\r\n\t\tvar eventDef = seg.footprint.eventDef;\r\n\r\n\t\treturn (!getEvIsTouch(ev) || view.isEventDefSelected(eventDef)) &&\r\n\t\t\tthis.isEventDefResizable(eventDef) &&\r\n\t\t\t$(ev.target).is('.fc-resizer');\r\n\t},\r\n\r\n\r\n\t// Kills all in-progress dragging.\r\n\t// Useful for when public API methods that result in re-rendering are invoked during a drag.\r\n\t// Also useful for when touch devices misbehave and don't fire their touchend.\r\n\tendInteractions: function() {\r\n\t\t[\r\n\t\t\tthis.dateClicking,\r\n\t\t\tthis.dateSelecting,\r\n\t\t\tthis.eventPointing,\r\n\t\t\tthis.eventDragging,\r\n\t\t\tthis.eventResizing\r\n\t\t].forEach(function(interaction) {\r\n\t\t\tif (interaction) {\r\n\t\t\t\tinteraction.end();\r\n\t\t\t}\r\n\t\t});\r\n\t},\r\n\r\n\r\n\t// Event Drag-n-Drop\r\n\t// ---------------------------------------------------------------------------------------------------------------\r\n\r\n\r\n\t// Computes if the given event is allowed to be dragged by the user\r\n\tisEventDefDraggable: function(eventDef) {\r\n\t\treturn this.isEventDefStartEditable(eventDef);\r\n\t},\r\n\r\n\r\n\tisEventDefStartEditable: function(eventDef) {\r\n\t\tvar isEditable = eventDef.isStartExplicitlyEditable();\r\n\r\n\t\tif (isEditable == null) {\r\n\t\t\tisEditable = this.opt('eventStartEditable');\r\n\r\n\t\t\tif (isEditable == null) {\r\n\t\t\t\tisEditable = this.isEventDefGenerallyEditable(eventDef);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn isEditable;\r\n\t},\r\n\r\n\r\n\tisEventDefGenerallyEditable: function(eventDef) {\r\n\t\tvar isEditable = eventDef.isExplicitlyEditable();\r\n\r\n\t\tif (isEditable == null) {\r\n\t\t\tisEditable = this.opt('editable');\r\n\t\t}\r\n\r\n\t\treturn isEditable;\r\n\t},\r\n\r\n\r\n\t// Event Resizing\r\n\t// ---------------------------------------------------------------------------------------------------------------\r\n\r\n\r\n\t// Computes if the given event is allowed to be resized from its starting edge\r\n\tisEventDefResizableFromStart: function(eventDef) {\r\n\t\treturn this.opt('eventResizableFromStart') && this.isEventDefResizable(eventDef);\r\n\t},\r\n\r\n\r\n\t// Computes if the given event is allowed to be resized from its ending edge\r\n\tisEventDefResizableFromEnd: function(eventDef) {\r\n\t\treturn this.isEventDefResizable(eventDef);\r\n\t},\r\n\r\n\r\n\t// Computes if the given event is allowed to be resized by the user at all\r\n\tisEventDefResizable: function(eventDef) {\r\n\t\tvar isResizable = eventDef.isDurationExplicitlyEditable();\r\n\r\n\t\tif (isResizable == null) {\r\n\t\t\tisResizable = this.opt('eventDurationEditable');\r\n\r\n\t\t\tif (isResizable == null) {\r\n\t\t\t\tisResizable = this.isEventDefGenerallyEditable(eventDef);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn isResizable;\r\n\t},\r\n\r\n\r\n\t// Event Mutation / Constraints\r\n\t// ---------------------------------------------------------------------------------------------------------------\r\n\r\n\r\n\t// Diffs the two dates, returning a duration, based on granularity of the grid\r\n\t// TODO: port isTimeScale into this system?\r\n\tdiffDates: function(a, b) {\r\n\t\tif (this.largeUnit) {\r\n\t\t\treturn diffByUnit(a, b, this.largeUnit);\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn diffDayTime(a, b);\r\n\t\t}\r\n\t},\r\n\r\n\r\n\t// is it allowed, in relation to the view's validRange?\r\n\t// NOTE: very similar to isExternalInstanceGroupAllowed\r\n\tisEventInstanceGroupAllowed: function(eventInstanceGroup) {\r\n\t\tvar view = this._getView();\r\n\t\tvar dateProfile = this.dateProfile;\r\n\t\tvar eventFootprints = this.eventRangesToEventFootprints(eventInstanceGroup.getAllEventRanges());\r\n\t\tvar i;\r\n\r\n\t\tfor (i = 0; i < eventFootprints.length; i++) {\r\n\t\t\t// TODO: just use getAllEventRanges directly\r\n\t\t\tif (!dateProfile.validUnzonedRange.containsRange(eventFootprints[i].componentFootprint.unzonedRange)) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn view.calendar.isEventInstanceGroupAllowed(eventInstanceGroup);\r\n\t},\r\n\r\n\r\n\t// NOTE: very similar to isEventInstanceGroupAllowed\r\n\t// when it's a completely anonymous external drag, no event.\r\n\tisExternalInstanceGroupAllowed: function(eventInstanceGroup) {\r\n\t\tvar view = this._getView();\r\n\t\tvar dateProfile = this.dateProfile;\r\n\t\tvar eventFootprints = this.eventRangesToEventFootprints(eventInstanceGroup.getAllEventRanges());\r\n\t\tvar i;\r\n\r\n\t\tfor (i = 0; i < eventFootprints.length; i++) {\r\n\t\t\tif (!dateProfile.validUnzonedRange.containsRange(eventFootprints[i].componentFootprint.unzonedRange)) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfor (i = 0; i < eventFootprints.length; i++) {\r\n\t\t\t// treat it as a selection\r\n\t\t\t// TODO: pass in eventInstanceGroup instead\r\n\t\t\t//  because we don't want calendar's constraint system to depend on a component's\r\n\t\t\t//  determination of footprints.\r\n\t\t\tif (!view.calendar.isSelectionFootprintAllowed(eventFootprints[i].componentFootprint)) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n});\r\n\r\n;;\r\n\r\n/*\r\nA set of rendering and date-related methods for a visual component comprised of one or more rows of day columns.\r\nPrerequisite: the object being mixed into needs to be a *Grid*\r\n*/\r\nvar DayTableMixin = FC.DayTableMixin = {\r\n\r\n\tbreakOnWeeks: false, // should create a new row for each week?\r\n\tdayDates: null, // whole-day dates for each column. left to right\r\n\tdayIndices: null, // for each day from start, the offset\r\n\tdaysPerRow: null,\r\n\trowCnt: null,\r\n\tcolCnt: null,\r\n\tcolHeadFormat: null,\r\n\r\n\r\n\t// Populates internal variables used for date calculation and rendering\r\n\tupdateDayTable: function() {\r\n\t\tvar view = this.view;\r\n\t\tvar calendar = view.calendar;\r\n\t\tvar date = calendar.msToUtcMoment(this.dateProfile.renderUnzonedRange.startMs, true);\r\n\t\tvar end = calendar.msToUtcMoment(this.dateProfile.renderUnzonedRange.endMs, true);\r\n\t\tvar dayIndex = -1;\r\n\t\tvar dayIndices = [];\r\n\t\tvar dayDates = [];\r\n\t\tvar daysPerRow;\r\n\t\tvar firstDay;\r\n\t\tvar rowCnt;\r\n\r\n\t\twhile (date.isBefore(end)) { // loop each day from start to end\r\n\t\t\tif (view.isHiddenDay(date)) {\r\n\t\t\t\tdayIndices.push(dayIndex + 0.5); // mark that it's between indices\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tdayIndex++;\r\n\t\t\t\tdayIndices.push(dayIndex);\r\n\t\t\t\tdayDates.push(date.clone());\r\n\t\t\t}\r\n\t\t\tdate.add(1, 'days');\r\n\t\t}\r\n\r\n\t\tif (this.breakOnWeeks) {\r\n\t\t\t// count columns until the day-of-week repeats\r\n\t\t\tfirstDay = dayDates[0].day();\r\n\t\t\tfor (daysPerRow = 1; daysPerRow < dayDates.length; daysPerRow++) {\r\n\t\t\t\tif (dayDates[daysPerRow].day() == firstDay) {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\trowCnt = Math.ceil(dayDates.length / daysPerRow);\r\n\t\t}\r\n\t\telse {\r\n\t\t\trowCnt = 1;\r\n\t\t\tdaysPerRow = dayDates.length;\r\n\t\t}\r\n\r\n\t\tthis.dayDates = dayDates;\r\n\t\tthis.dayIndices = dayIndices;\r\n\t\tthis.daysPerRow = daysPerRow;\r\n\t\tthis.rowCnt = rowCnt;\r\n\r\n\t\tthis.updateDayTableCols();\r\n\t},\r\n\r\n\r\n\t// Computes and assigned the colCnt property and updates any options that may be computed from it\r\n\tupdateDayTableCols: function() {\r\n\t\tthis.colCnt = this.computeColCnt();\r\n\t\tthis.colHeadFormat = this.opt('columnFormat') || this.computeColHeadFormat();\r\n\t},\r\n\r\n\r\n\t// Determines how many columns there should be in the table\r\n\tcomputeColCnt: function() {\r\n\t\treturn this.daysPerRow;\r\n\t},\r\n\r\n\r\n\t// Computes the ambiguously-timed moment for the given cell\r\n\tgetCellDate: function(row, col) {\r\n\t\treturn this.dayDates[\r\n\t\t\t\tthis.getCellDayIndex(row, col)\r\n\t\t\t].clone();\r\n\t},\r\n\r\n\r\n\t// Computes the ambiguously-timed date range for the given cell\r\n\tgetCellRange: function(row, col) {\r\n\t\tvar start = this.getCellDate(row, col);\r\n\t\tvar end = start.clone().add(1, 'days');\r\n\r\n\t\treturn { start: start, end: end };\r\n\t},\r\n\r\n\r\n\t// Returns the number of day cells, chronologically, from the first of the grid (0-based)\r\n\tgetCellDayIndex: function(row, col) {\r\n\t\treturn row * this.daysPerRow + this.getColDayIndex(col);\r\n\t},\r\n\r\n\r\n\t// Returns the numner of day cells, chronologically, from the first cell in *any given row*\r\n\tgetColDayIndex: function(col) {\r\n\t\tif (this.isRTL) {\r\n\t\t\treturn this.colCnt - 1 - col;\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn col;\r\n\t\t}\r\n\t},\r\n\r\n\r\n\t// Given a date, returns its chronolocial cell-index from the first cell of the grid.\r\n\t// If the date lies between cells (because of hiddenDays), returns a floating-point value between offsets.\r\n\t// If before the first offset, returns a negative number.\r\n\t// If after the last offset, returns an offset past the last cell offset.\r\n\t// Only works for *start* dates of cells. Will not work for exclusive end dates for cells.\r\n\tgetDateDayIndex: function(date) {\r\n\t\tvar dayIndices = this.dayIndices;\r\n\t\tvar dayOffset = date.diff(this.dayDates[0], 'days');\r\n\r\n\t\tif (dayOffset < 0) {\r\n\t\t\treturn dayIndices[0] - 1;\r\n\t\t}\r\n\t\telse if (dayOffset >= dayIndices.length) {\r\n\t\t\treturn dayIndices[dayIndices.length - 1] + 1;\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn dayIndices[dayOffset];\r\n\t\t}\r\n\t},\r\n\r\n\r\n\t/* Options\r\n\t------------------------------------------------------------------------------------------------------------------*/\r\n\r\n\r\n\t// Computes a default column header formatting string if `colFormat` is not explicitly defined\r\n\tcomputeColHeadFormat: function() {\r\n\t\t// if more than one week row, or if there are a lot of columns with not much space,\r\n\t\t// put just the day numbers will be in each cell\r\n\t\tif (this.rowCnt > 1 || this.colCnt > 10) {\r\n\t\t\treturn 'ddd'; // \"Sat\"\r\n\t\t}\r\n\t\t// multiple days, so full single date string WON'T be in title text\r\n\t\telse if (this.colCnt > 1) {\r\n\t\t\treturn this.opt('dayOfMonthFormat'); // \"Sat 12/10\"\r\n\t\t}\r\n\t\t// single day, so full single date string will probably be in title text\r\n\t\telse {\r\n\t\t\treturn 'dddd'; // \"Saturday\"\r\n\t\t}\r\n\t},\r\n\r\n\r\n\t/* Slicing\r\n\t------------------------------------------------------------------------------------------------------------------*/\r\n\r\n\r\n\t// Slices up a date range into a segment for every week-row it intersects with\r\n\tsliceRangeByRow: function(unzonedRange) {\r\n\t\tvar daysPerRow = this.daysPerRow;\r\n\t\tvar normalRange = this.view.computeDayRange(unzonedRange); // make whole-day range, considering nextDayThreshold\r\n\t\tvar rangeFirst = this.getDateDayIndex(normalRange.start); // inclusive first index\r\n\t\tvar rangeLast = this.getDateDayIndex(normalRange.end.clone().subtract(1, 'days')); // inclusive last index\r\n\t\tvar segs = [];\r\n\t\tvar row;\r\n\t\tvar rowFirst, rowLast; // inclusive day-index range for current row\r\n\t\tvar segFirst, segLast; // inclusive day-index range for segment\r\n\r\n\t\tfor (row = 0; row < this.rowCnt; row++) {\r\n\t\t\trowFirst = row * daysPerRow;\r\n\t\t\trowLast = rowFirst + daysPerRow - 1;\r\n\r\n\t\t\t// intersect segment's offset range with the row's\r\n\t\t\tsegFirst = Math.max(rangeFirst, rowFirst);\r\n\t\t\tsegLast = Math.min(rangeLast, rowLast);\r\n\r\n\t\t\t// deal with in-between indices\r\n\t\t\tsegFirst = Math.ceil(segFirst); // in-between starts round to next cell\r\n\t\t\tsegLast = Math.floor(segLast); // in-between ends round to prev cell\r\n\r\n\t\t\tif (segFirst <= segLast) { // was there any intersection with the current row?\r\n\t\t\t\tsegs.push({\r\n\t\t\t\t\trow: row,\r\n\r\n\t\t\t\t\t// normalize to start of row\r\n\t\t\t\t\tfirstRowDayIndex: segFirst - rowFirst,\r\n\t\t\t\t\tlastRowDayIndex: segLast - rowFirst,\r\n\r\n\t\t\t\t\t// must be matching integers to be the segment's start/end\r\n\t\t\t\t\tisStart: segFirst === rangeFirst,\r\n\t\t\t\t\tisEnd: segLast === rangeLast\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn segs;\r\n\t},\r\n\r\n\r\n\t// Slices up a date range into a segment for every day-cell it intersects with.\r\n\t// TODO: make more DRY with sliceRangeByRow somehow.\r\n\tsliceRangeByDay: function(unzonedRange) {\r\n\t\tvar daysPerRow = this.daysPerRow;\r\n\t\tvar normalRange = this.view.computeDayRange(unzonedRange); // make whole-day range, considering nextDayThreshold\r\n\t\tvar rangeFirst = this.getDateDayIndex(normalRange.start); // inclusive first index\r\n\t\tvar rangeLast = this.getDateDayIndex(normalRange.end.clone().subtract(1, 'days')); // inclusive last index\r\n\t\tvar segs = [];\r\n\t\tvar row;\r\n\t\tvar rowFirst, rowLast; // inclusive day-index range for current row\r\n\t\tvar i;\r\n\t\tvar segFirst, segLast; // inclusive day-index range for segment\r\n\r\n\t\tfor (row = 0; row < this.rowCnt; row++) {\r\n\t\t\trowFirst = row * daysPerRow;\r\n\t\t\trowLast = rowFirst + daysPerRow - 1;\r\n\r\n\t\t\tfor (i = rowFirst; i <= rowLast; i++) {\r\n\r\n\t\t\t\t// intersect segment's offset range with the row's\r\n\t\t\t\tsegFirst = Math.max(rangeFirst, i);\r\n\t\t\t\tsegLast = Math.min(rangeLast, i);\r\n\r\n\t\t\t\t// deal with in-between indices\r\n\t\t\t\tsegFirst = Math.ceil(segFirst); // in-between starts round to next cell\r\n\t\t\t\tsegLast = Math.floor(segLast); // in-between ends round to prev cell\r\n\r\n\t\t\t\tif (segFirst <= segLast) { // was there any intersection with the current row?\r\n\t\t\t\t\tsegs.push({\r\n\t\t\t\t\t\trow: row,\r\n\r\n\t\t\t\t\t\t// normalize to start of row\r\n\t\t\t\t\t\tfirstRowDayIndex: segFirst - rowFirst,\r\n\t\t\t\t\t\tlastRowDayIndex: segLast - rowFirst,\r\n\r\n\t\t\t\t\t\t// must be matching integers to be the segment's start/end\r\n\t\t\t\t\t\tisStart: segFirst === rangeFirst,\r\n\t\t\t\t\t\tisEnd: segLast === rangeLast\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn segs;\r\n\t},\r\n\r\n\r\n\t/* Header Rendering\r\n\t------------------------------------------------------------------------------------------------------------------*/\r\n\r\n\r\n\trenderHeadHtml: function() {\r\n\t\tvar theme = this.view.calendar.theme;\r\n\r\n\t\treturn '' +\r\n\t\t\t'<div class=\"fc-row ' + theme.getClass('headerRow') + '\">' +\r\n\t\t\t\t'<table class=\"' + theme.getClass('tableGrid') + '\">' +\r\n\t\t\t\t\t'<thead>' +\r\n\t\t\t\t\t\tthis.renderHeadTrHtml() +\r\n\t\t\t\t\t'</thead>' +\r\n\t\t\t\t'</table>' +\r\n\t\t\t'</div>';\r\n\t},\r\n\r\n\r\n\trenderHeadIntroHtml: function() {\r\n\t\treturn this.renderIntroHtml(); // fall back to generic\r\n\t},\r\n\r\n\r\n\trenderHeadTrHtml: function() {\r\n\t\treturn '' +\r\n\t\t\t'<tr>' +\r\n\t\t\t\t(this.isRTL ? '' : this.renderHeadIntroHtml()) +\r\n\t\t\t\tthis.renderHeadDateCellsHtml() +\r\n\t\t\t\t(this.isRTL ? this.renderHeadIntroHtml() : '') +\r\n\t\t\t'</tr>';\r\n\t},\r\n\r\n\r\n\trenderHeadDateCellsHtml: function() {\r\n\t\tvar htmls = [];\r\n\t\tvar col, date;\r\n\r\n\t\tfor (col = 0; col < this.colCnt; col++) {\r\n\t\t\tdate = this.getCellDate(0, col);\r\n\t\t\thtmls.push(this.renderHeadDateCellHtml(date));\r\n\t\t}\r\n\r\n\t\treturn htmls.join('');\r\n\t},\r\n\r\n\r\n\t// TODO: when internalApiVersion, accept an object for HTML attributes\r\n\t// (colspan should be no different)\r\n\trenderHeadDateCellHtml: function(date, colspan, otherAttrs) {\r\n\t\tvar view = this.view;\r\n\t\tvar isDateValid = this.dateProfile.activeUnzonedRange.containsDate(date); // TODO: called too frequently. cache somehow.\r\n\t\tvar classNames = [\r\n\t\t\t'fc-day-header',\r\n\t\t\tview.calendar.theme.getClass('widgetHeader')\r\n\t\t];\r\n\t\tvar innerHtml = htmlEscape(date.format(this.colHeadFormat));\r\n\r\n\t\t// if only one row of days, the classNames on the header can represent the specific days beneath\r\n\t\tif (this.rowCnt === 1) {\r\n\t\t\tclassNames = classNames.concat(\r\n\t\t\t\t// includes the day-of-week class\r\n\t\t\t\t// noThemeHighlight=true (don't highlight the header)\r\n\t\t\t\tthis.getDayClasses(date, true)\r\n\t\t\t);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tclassNames.push('fc-' + dayIDs[date.day()]); // only add the day-of-week class\r\n\t\t}\r\n\r\n\t\treturn '' +\r\n            '<th class=\"' + classNames.join(' ') + '\"' +\r\n\t\t\t\t((isDateValid && this.rowCnt) === 1 ?\r\n\t\t\t\t\t' data-date=\"' + date.format('YYYY-MM-DD') + '\"' :\r\n\t\t\t\t\t'') +\r\n\t\t\t\t(colspan > 1 ?\r\n\t\t\t\t\t' colspan=\"' + colspan + '\"' :\r\n\t\t\t\t\t'') +\r\n\t\t\t\t(otherAttrs ?\r\n\t\t\t\t\t' ' + otherAttrs :\r\n\t\t\t\t\t'') +\r\n\t\t\t\t'>' +\r\n\t\t\t\t(isDateValid ?\r\n\t\t\t\t\t// don't make a link if the heading could represent multiple days, or if there's only one day (forceOff)\r\n\t\t\t\t\tview.buildGotoAnchorHtml(\r\n\t\t\t\t\t\t{ date: date, forceOff: this.rowCnt > 1 || this.colCnt === 1 },\r\n\t\t\t\t\t\tinnerHtml\r\n\t\t\t\t\t) :\r\n\t\t\t\t\t// if not valid, display text, but no link\r\n\t\t\t\t\tinnerHtml\r\n\t\t\t\t) +\r\n\t\t\t'</th>';\r\n\t},\r\n\r\n\r\n\t/* Background Rendering\r\n\t------------------------------------------------------------------------------------------------------------------*/\r\n\r\n\r\n\trenderBgTrHtml: function(row) {\r\n\t\treturn '' +\r\n\t\t\t'<tr>' +\r\n\t\t\t\t(this.isRTL ? '' : this.renderBgIntroHtml(row)) +\r\n\t\t\t\tthis.renderBgCellsHtml(row) +\r\n\t\t\t\t(this.isRTL ? this.renderBgIntroHtml(row) : '') +\r\n\t\t\t'</tr>';\r\n\t},\r\n\r\n\r\n\trenderBgIntroHtml: function(row) {\r\n\t\treturn this.renderIntroHtml(); // fall back to generic\r\n\t},\r\n\r\n\r\n\trenderBgCellsHtml: function(row) {\r\n\t\tvar htmls = [];\r\n\t\tvar col, date;\r\n\r\n\t\tfor (col = 0; col < this.colCnt; col++) {\r\n\t\t\tdate = this.getCellDate(row, col);\r\n\t\t\thtmls.push(this.renderBgCellHtml(date));\r\n\t\t}\r\n\r\n\t\treturn htmls.join('');\r\n\t},\r\n\r\n\r\n\trenderBgCellHtml: function(date, otherAttrs) {\r\n\t\tvar view = this.view;\r\n\t\tvar isDateValid = this.dateProfile.activeUnzonedRange.containsDate(date); // TODO: called too frequently. cache somehow.\r\n\t\tvar classes = this.getDayClasses(date);\r\n\r\n\t\tclasses.unshift('fc-day', view.calendar.theme.getClass('widgetContent'));\r\n\r\n\t\treturn '<td class=\"' + classes.join(' ') + '\"' +\r\n\t\t\t(isDateValid ?\r\n\t\t\t\t' data-date=\"' + date.format('YYYY-MM-DD') + '\"' : // if date has a time, won't format it\r\n\t\t\t\t'') +\r\n\t\t\t(otherAttrs ?\r\n\t\t\t\t' ' + otherAttrs :\r\n\t\t\t\t'') +\r\n\t\t\t'></td>';\r\n\t},\r\n\r\n\r\n\t/* Generic\r\n\t------------------------------------------------------------------------------------------------------------------*/\r\n\r\n\r\n\t// Generates the default HTML intro for any row. User classes should override\r\n\trenderIntroHtml: function() {\r\n\t},\r\n\r\n\r\n\t// TODO: a generic method for dealing with <tr>, RTL, intro\r\n\t// when increment internalApiVersion\r\n\t// wrapTr (scheduler)\r\n\r\n\r\n\t/* Utils\r\n\t------------------------------------------------------------------------------------------------------------------*/\r\n\r\n\r\n\t// Applies the generic \"intro\" and \"outro\" HTML to the given cells.\r\n\t// Intro means the leftmost cell when the calendar is LTR and the rightmost cell when RTL. Vice-versa for outro.\r\n\tbookendCells: function(trEl) {\r\n\t\tvar introHtml = this.renderIntroHtml();\r\n\r\n\t\tif (introHtml) {\r\n\t\t\tif (this.isRTL) {\r\n\t\t\t\ttrEl.append(introHtml);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\ttrEl.prepend(introHtml);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n};\r\n\r\n;;\r\n\r\n/* An abstract class from which other views inherit from\r\n----------------------------------------------------------------------------------------------------------------------*/\r\n\r\nvar View = FC.View = InteractiveDateComponent.extend({\r\n\r\n\ttype: null, // subclass' view name (string)\r\n\tname: null, // deprecated. use `type` instead\r\n\ttitle: null, // the text that will be displayed in the header's title\r\n\r\n\tcalendar: null, // owner Calendar object\r\n\tviewSpec: null,\r\n\toptions: null, // hash containing all options. already merged with view-specific-options\r\n\r\n\trenderQueue: null,\r\n\tbatchRenderDepth: 0,\r\n\tqueuedScroll: null,\r\n\r\n\tisSelected: false, // boolean whether a range of time is user-selected or not\r\n\tselectedEventInstance: null,\r\n\r\n\teventOrderSpecs: null, // criteria for ordering events when they have same date/time\r\n\r\n\t// for date utils, computed from options\r\n\tisHiddenDayHash: null,\r\n\r\n\t// now indicator\r\n\tisNowIndicatorRendered: null,\r\n\tinitialNowDate: null, // result first getNow call\r\n\tinitialNowQueriedMs: null, // ms time the getNow was called\r\n\tnowIndicatorTimeoutID: null, // for refresh timing of now indicator\r\n\tnowIndicatorIntervalID: null, // \"\r\n\r\n\tconstructor: function(calendar, viewSpec) {\r\n\t\tthis.calendar = calendar;\r\n\t\tthis.viewSpec = viewSpec;\r\n\r\n\t\t// shortcuts\r\n\t\tthis.type = viewSpec.type;\r\n\t\tthis.options = viewSpec.options;\r\n\r\n\t\t// .name is deprecated\r\n\t\tthis.name = this.type;\r\n\r\n\t\tInteractiveDateComponent.call(this);\r\n\r\n\t\tthis.initRenderQueue();\r\n\t\tthis.initHiddenDays();\r\n\t\tthis.bindBaseRenderHandlers();\r\n\t\tthis.eventOrderSpecs = parseFieldSpecs(this.opt('eventOrder'));\r\n\r\n\t\t// legacy\r\n\t\tif (this.initialize) {\r\n\t\t\tthis.initialize();\r\n\t\t}\r\n\t},\r\n\r\n\r\n\t_getView: function() {\r\n\t\treturn this;\r\n\t},\r\n\r\n\r\n\t// Retrieves an option with the given name\r\n\topt: function(name) {\r\n\t\treturn this.options[name];\r\n\t},\r\n\r\n\r\n\t/* Render Queue\r\n\t------------------------------------------------------------------------------------------------------------------*/\r\n\r\n\r\n\tinitRenderQueue: function() {\r\n\t\tthis.renderQueue = new RenderQueue({\r\n\t\t\tevent: this.opt('eventRenderWait')\r\n\t\t});\r\n\r\n\t\tthis.renderQueue.on('start', this.onRenderQueueStart.bind(this));\r\n\t\tthis.renderQueue.on('stop', this.onRenderQueueStop.bind(this));\r\n\r\n\t\tthis.on('before:change', this.startBatchRender);\r\n\t\tthis.on('change', this.stopBatchRender);\r\n\t},\r\n\r\n\r\n\tonRenderQueueStart: function() {\r\n\t\tthis.calendar.freezeContentHeight();\r\n\t\tthis.addScroll(this.queryScroll());\r\n\t},\r\n\r\n\r\n\tonRenderQueueStop: function() {\r\n\t\tif (this.calendar.updateViewSize()) { // success?\r\n\t\t\tthis.popScroll();\r\n\t\t}\r\n\t\tthis.calendar.thawContentHeight();\r\n\t},\r\n\r\n\r\n\tstartBatchRender: function() {\r\n\t\tif (!(this.batchRenderDepth++)) {\r\n\t\t\tthis.renderQueue.pause();\r\n\t\t}\r\n\t},\r\n\r\n\r\n\tstopBatchRender: function() {\r\n\t\tif (!(--this.batchRenderDepth)) {\r\n\t\t\tthis.renderQueue.resume();\r\n\t\t}\r\n\t},\r\n\r\n\r\n\trequestRender: function(func, namespace, actionType) {\r\n\t\tthis.renderQueue.queue(func, namespace, actionType);\r\n\t},\r\n\r\n\r\n\t// given func will auto-bind to `this`\r\n\twhenSizeUpdated: function(func) {\r\n\t\tif (this.renderQueue.isRunning) {\r\n\t\t\tthis.renderQueue.one('stop', func.bind(this));\r\n\t\t}\r\n\t\telse {\r\n\t\t\tfunc.call(this);\r\n\t\t}\r\n\t},\r\n\r\n\r\n\t/* Title and Date Formatting\r\n\t------------------------------------------------------------------------------------------------------------------*/\r\n\r\n\r\n\t// Computes what the title at the top of the calendar should be for this view\r\n\tcomputeTitle: function(dateProfile) {\r\n\t\tvar unzonedRange;\r\n\r\n\t\t// for views that span a large unit of time, show the proper interval, ignoring stray days before and after\r\n\t\tif (/^(year|month)$/.test(dateProfile.currentRangeUnit)) {\r\n\t\t\tunzonedRange = dateProfile.currentUnzonedRange;\r\n\t\t}\r\n\t\telse { // for day units or smaller, use the actual day range\r\n\t\t\tunzonedRange = dateProfile.activeUnzonedRange;\r\n\t\t}\r\n\r\n\t\treturn this.formatRange(\r\n\t\t\t{\r\n\t\t\t\tstart: this.calendar.msToMoment(unzonedRange.startMs, dateProfile.isRangeAllDay),\r\n\t\t\t\tend: this.calendar.msToMoment(unzonedRange.endMs, dateProfile.isRangeAllDay)\r\n\t\t\t},\r\n\t\t\tdateProfile.isRangeAllDay,\r\n\t\t\tthis.opt('titleFormat') || this.computeTitleFormat(dateProfile),\r\n\t\t\tthis.opt('titleRangeSeparator')\r\n\t\t);\r\n\t},\r\n\r\n\r\n\t// Generates the format string that should be used to generate the title for the current date range.\r\n\t// Attempts to compute the most appropriate format if not explicitly specified with `titleFormat`.\r\n\tcomputeTitleFormat: function(dateProfile) {\r\n\t\tvar currentRangeUnit = dateProfile.currentRangeUnit;\r\n\r\n\t\tif (currentRangeUnit == 'year') {\r\n\t\t\treturn 'YYYY';\r\n\t\t}\r\n\t\telse if (currentRangeUnit == 'month') {\r\n\t\t\treturn this.opt('monthYearFormat'); // like \"September 2014\"\r\n\t\t}\r\n\t\telse if (dateProfile.currentUnzonedRange.as('days') > 1) {\r\n\t\t\treturn 'll'; // multi-day range. shorter, like \"Sep 9 - 10 2014\"\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn 'LL'; // one day. longer, like \"September 9 2014\"\r\n\t\t}\r\n\t},\r\n\r\n\r\n\t// Date Setting/Unsetting\r\n\t// -----------------------------------------------------------------------------------------------------------------\r\n\r\n\r\n\tsetDate: function(date) {\r\n\t\tvar currentDateProfile = this.get('dateProfile');\r\n\t\tvar newDateProfile = this.buildDateProfile(date, null, true); // forceToValid=true\r\n\r\n\t\tif (\r\n\t\t\t!currentDateProfile ||\r\n\t\t\t!currentDateProfile.activeUnzonedRange.equals(newDateProfile.activeUnzonedRange)\r\n\t\t) {\r\n\t\t\tthis.set('dateProfile', newDateProfile);\r\n\t\t}\r\n\t},\r\n\r\n\r\n\tunsetDate: function() {\r\n\t\tthis.unset('dateProfile');\r\n\t},\r\n\r\n\r\n\t// Event Data\r\n\t// -----------------------------------------------------------------------------------------------------------------\r\n\r\n\r\n\tfetchInitialEvents: function(dateProfile) {\r\n\t\tvar calendar = this.calendar;\r\n\t\tvar forceAllDay = dateProfile.isRangeAllDay && !this.usesMinMaxTime;\r\n\r\n\t\treturn calendar.requestEvents(\r\n\t\t\tcalendar.msToMoment(dateProfile.activeUnzonedRange.startMs, forceAllDay),\r\n\t\t\tcalendar.msToMoment(dateProfile.activeUnzonedRange.endMs, forceAllDay)\r\n\t\t);\r\n\t},\r\n\r\n\r\n\tbindEventChanges: function() {\r\n\t\tthis.listenTo(this.calendar, 'eventsReset', this.resetEvents); // TODO: make this a real event\r\n\t},\r\n\r\n\r\n\tunbindEventChanges: function() {\r\n\t\tthis.stopListeningTo(this.calendar, 'eventsReset');\r\n\t},\r\n\r\n\r\n\tsetEvents: function(eventsPayload) {\r\n\t\tthis.set('currentEvents', eventsPayload);\r\n\t\tthis.set('hasEvents', true);\r\n\t},\r\n\r\n\r\n\tunsetEvents: function() {\r\n\t\tthis.unset('currentEvents');\r\n\t\tthis.unset('hasEvents');\r\n\t},\r\n\r\n\r\n\tresetEvents: function(eventsPayload) {\r\n\t\tthis.startBatchRender();\r\n\t\tthis.unsetEvents();\r\n\t\tthis.setEvents(eventsPayload);\r\n\t\tthis.stopBatchRender();\r\n\t},\r\n\r\n\r\n\t// Date High-level Rendering\r\n\t// -----------------------------------------------------------------------------------------------------------------\r\n\r\n\r\n\trequestDateRender: function(dateProfile) {\r\n\t\tvar _this = this;\r\n\r\n\t\tthis.requestRender(function() {\r\n\t\t\t_this.executeDateRender(dateProfile);\r\n\t\t}, 'date', 'init');\r\n\t},\r\n\r\n\r\n\trequestDateUnrender: function() {\r\n\t\tvar _this = this;\r\n\r\n\t\tthis.requestRender(function() {\r\n\t\t\t_this.executeDateUnrender();\r\n\t\t}, 'date', 'destroy');\r\n\t},\r\n\r\n\r\n\t// if dateProfile not specified, uses current\r\n\texecuteDateRender: function(dateProfile) {\r\n\t\tDateComponent.prototype.executeDateRender.apply(this, arguments);\r\n\r\n\t\tif (this.render) {\r\n\t\t\tthis.render(); // TODO: deprecate\r\n\t\t}\r\n\r\n\t\tthis.trigger('datesRendered');\r\n\t\tthis.addScroll({ isDateInit: true });\r\n\t\tthis.startNowIndicator(); // shouldn't render yet because updateSize will be called soon\r\n\t},\r\n\r\n\r\n\texecuteDateUnrender: function() {\r\n\t\tthis.unselect();\r\n\t\tthis.stopNowIndicator();\r\n\t\tthis.trigger('before:datesUnrendered');\r\n\r\n\t\tif (this.destroy) {\r\n\t\t\tthis.destroy(); // TODO: deprecate\r\n\t\t}\r\n\r\n\t\tDateComponent.prototype.executeDateUnrender.apply(this, arguments);\r\n\t},\r\n\r\n\r\n\t// \"Base\" rendering\r\n\t// -----------------------------------------------------------------------------------------------------------------\r\n\r\n\r\n\tbindBaseRenderHandlers: function() {\r\n\t\tvar _this = this;\r\n\r\n\t\tthis.on('datesRendered', function() {\r\n\t\t\t_this.whenSizeUpdated(\r\n\t\t\t\t_this.triggerViewRender\r\n\t\t\t);\r\n\t\t});\r\n\r\n\t\tthis.on('before:datesUnrendered', function() {\r\n\t\t\t_this.triggerViewDestroy();\r\n\t\t});\r\n\t},\r\n\r\n\r\n\ttriggerViewRender: function() {\r\n\t\tthis.publiclyTrigger('viewRender', {\r\n\t\t\tcontext: this,\r\n\t\t\targs: [ this, this.el ]\r\n\t\t});\r\n\t},\r\n\r\n\r\n\ttriggerViewDestroy: function() {\r\n\t\tthis.publiclyTrigger('viewDestroy', {\r\n\t\t\tcontext: this,\r\n\t\t\targs: [ this, this.el ]\r\n\t\t});\r\n\t},\r\n\r\n\r\n\t// Event High-level Rendering\r\n\t// -----------------------------------------------------------------------------------------------------------------\r\n\r\n\r\n\trequestEventsRender: function(eventsPayload) {\r\n\t\tvar _this = this;\r\n\r\n\t\tthis.requestRender(function() {\r\n\t\t\t_this.executeEventRender(eventsPayload);\r\n\t\t\t_this.whenSizeUpdated(\r\n\t\t\t\t_this.triggerAfterEventsRendered\r\n\t\t\t);\r\n\t\t}, 'event', 'init');\r\n\t},\r\n\r\n\r\n\trequestEventsUnrender: function() {\r\n\t\tvar _this = this;\r\n\r\n\t\tthis.requestRender(function() {\r\n\t\t\t_this.triggerBeforeEventsDestroyed();\r\n\t\t\t_this.executeEventUnrender();\r\n\t\t}, 'event', 'destroy');\r\n\t},\r\n\r\n\r\n\t// Business Hour High-level Rendering\r\n\t// -----------------------------------------------------------------------------------------------------------------\r\n\r\n\r\n\trequestBusinessHoursRender: function(businessHourGenerator) {\r\n\t\tvar _this = this;\r\n\r\n\t\tthis.requestRender(function() {\r\n\t\t\t_this.renderBusinessHours(businessHourGenerator);\r\n\t\t}, 'businessHours', 'init');\r\n\t},\r\n\r\n\trequestBusinessHoursUnrender: function() {\r\n\t\tvar _this = this;\r\n\r\n\t\tthis.requestRender(function() {\r\n\t\t\t_this.unrenderBusinessHours();\r\n\t\t}, 'businessHours', 'destroy');\r\n\t},\r\n\r\n\r\n\t// Misc view rendering utils\r\n\t// -----------------------------------------------------------------------------------------------------------------\r\n\r\n\r\n\t// Binds DOM handlers to elements that reside outside the view container, such as the document\r\n\tbindGlobalHandlers: function() {\r\n\t\tInteractiveDateComponent.prototype.bindGlobalHandlers.apply(this, arguments);\r\n\r\n\t\tthis.listenTo(GlobalEmitter.get(), {\r\n\t\t\ttouchstart: this.processUnselect,\r\n\t\t\tmousedown: this.handleDocumentMousedown\r\n\t\t});\r\n\t},\r\n\r\n\r\n\t// Unbinds DOM handlers from elements that reside outside the view container\r\n\tunbindGlobalHandlers: function() {\r\n\t\tInteractiveDateComponent.prototype.unbindGlobalHandlers.apply(this, arguments);\r\n\r\n\t\tthis.stopListeningTo(GlobalEmitter.get());\r\n\t},\r\n\r\n\r\n\t/* Now Indicator\r\n\t------------------------------------------------------------------------------------------------------------------*/\r\n\r\n\r\n\t// Immediately render the current time indicator and begins re-rendering it at an interval,\r\n\t// which is defined by this.getNowIndicatorUnit().\r\n\t// TODO: somehow do this for the current whole day's background too\r\n\tstartNowIndicator: function() {\r\n\t\tvar _this = this;\r\n\t\tvar unit;\r\n\t\tvar update;\r\n\t\tvar delay; // ms wait value\r\n\r\n\t\tif (this.opt('nowIndicator')) {\r\n\t\t\tunit = this.getNowIndicatorUnit();\r\n\t\t\tif (unit) {\r\n\t\t\t\tupdate = proxy(this, 'updateNowIndicator'); // bind to `this`\r\n\r\n\t\t\t\tthis.initialNowDate = this.calendar.getNow();\r\n\t\t\t\tthis.initialNowQueriedMs = +new Date();\r\n\r\n\t\t\t\t// wait until the beginning of the next interval\r\n\t\t\t\tdelay = this.initialNowDate.clone().startOf(unit).add(1, unit) - this.initialNowDate;\r\n\t\t\t\tthis.nowIndicatorTimeoutID = setTimeout(function() {\r\n\t\t\t\t\t_this.nowIndicatorTimeoutID = null;\r\n\t\t\t\t\tupdate();\r\n\t\t\t\t\tdelay = +moment.duration(1, unit);\r\n\t\t\t\t\tdelay = Math.max(100, delay); // prevent too frequent\r\n\t\t\t\t\t_this.nowIndicatorIntervalID = setInterval(update, delay); // update every interval\r\n\t\t\t\t}, delay);\r\n\t\t\t}\r\n\r\n\t\t\t// rendering will be initiated in updateSize\r\n\t\t}\r\n\t},\r\n\r\n\r\n\t// rerenders the now indicator, computing the new current time from the amount of time that has passed\r\n\t// since the initial getNow call.\r\n\tupdateNowIndicator: function() {\r\n\t\tif (\r\n\t\t\tthis.isDatesRendered &&\r\n\t\t\tthis.initialNowDate // activated before?\r\n\t\t) {\r\n\t\t\tthis.unrenderNowIndicator(); // won't unrender if unnecessary\r\n\t\t\tthis.renderNowIndicator(\r\n\t\t\t\tthis.initialNowDate.clone().add(new Date() - this.initialNowQueriedMs) // add ms\r\n\t\t\t);\r\n\t\t\tthis.isNowIndicatorRendered = true;\r\n\t\t}\r\n\t},\r\n\r\n\r\n\t// Immediately unrenders the view's current time indicator and stops any re-rendering timers.\r\n\t// Won't cause side effects if indicator isn't rendered.\r\n\tstopNowIndicator: function() {\r\n\t\tif (this.isNowIndicatorRendered) {\r\n\r\n\t\t\tif (this.nowIndicatorTimeoutID) {\r\n\t\t\t\tclearTimeout(this.nowIndicatorTimeoutID);\r\n\t\t\t\tthis.nowIndicatorTimeoutID = null;\r\n\t\t\t}\r\n\t\t\tif (this.nowIndicatorIntervalID) {\r\n\t\t\t\tclearTimeout(this.nowIndicatorIntervalID);\r\n\t\t\t\tthis.nowIndicatorIntervalID = null;\r\n\t\t\t}\r\n\r\n\t\t\tthis.unrenderNowIndicator();\r\n\t\t\tthis.isNowIndicatorRendered = false;\r\n\t\t}\r\n\t},\r\n\r\n\r\n\t/* Dimensions\r\n\t------------------------------------------------------------------------------------------------------------------*/\r\n\r\n\r\n\tupdateSize: function(totalHeight, isAuto, isResize) {\r\n\r\n\t\tif (this.setHeight) { // for legacy API\r\n\t\t\tthis.setHeight(totalHeight, isAuto);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tInteractiveDateComponent.prototype.updateSize.apply(this, arguments);\r\n\t\t}\r\n\r\n\t\tthis.updateNowIndicator();\r\n\t},\r\n\r\n\r\n\t/* Scroller\r\n\t------------------------------------------------------------------------------------------------------------------*/\r\n\r\n\r\n\taddScroll: function(scroll) {\r\n\t\tvar queuedScroll = this.queuedScroll || (this.queuedScroll = {});\r\n\r\n\t\t$.extend(queuedScroll, scroll);\r\n\t},\r\n\r\n\r\n\tpopScroll: function() {\r\n\t\tthis.applyQueuedScroll();\r\n\t\tthis.queuedScroll = null;\r\n\t},\r\n\r\n\r\n\tapplyQueuedScroll: function() {\r\n\t\tif (this.queuedScroll) {\r\n\t\t\tthis.applyScroll(this.queuedScroll);\r\n\t\t}\r\n\t},\r\n\r\n\r\n\tqueryScroll: function() {\r\n\t\tvar scroll = {};\r\n\r\n\t\tif (this.isDatesRendered) {\r\n\t\t\t$.extend(scroll, this.queryDateScroll());\r\n\t\t}\r\n\r\n\t\treturn scroll;\r\n\t},\r\n\r\n\r\n\tapplyScroll: function(scroll) {\r\n\t\tif (scroll.isDateInit && this.isDatesRendered) {\r\n\t\t\t$.extend(scroll, this.computeInitialDateScroll());\r\n\t\t}\r\n\r\n\t\tif (this.isDatesRendered) {\r\n\t\t\tthis.applyDateScroll(scroll);\r\n\t\t}\r\n\t},\r\n\r\n\r\n\tcomputeInitialDateScroll: function() {\r\n\t\treturn {}; // subclasses must implement\r\n\t},\r\n\r\n\r\n\tqueryDateScroll: function() {\r\n\t\treturn {}; // subclasses must implement\r\n\t},\r\n\r\n\r\n\tapplyDateScroll: function(scroll) {\r\n\t\t; // subclasses must implement\r\n\t},\r\n\r\n\r\n\t/* Event Drag-n-Drop\r\n\t------------------------------------------------------------------------------------------------------------------*/\r\n\r\n\r\n\treportEventDrop: function(eventInstance, eventMutation, el, ev) {\r\n\t\tvar eventManager = this.calendar.eventManager;\r\n\t\tvar undoFunc = eventManager.mutateEventsWithId(\r\n\t\t\teventInstance.def.id,\r\n\t\t\teventMutation,\r\n\t\t\tthis.calendar\r\n\t\t);\r\n\t\tvar dateMutation = eventMutation.dateMutation;\r\n\r\n\t\t// update the EventInstance, for handlers\r\n\t\tif (dateMutation) {\r\n\t\t\teventInstance.dateProfile = dateMutation.buildNewDateProfile(\r\n\t\t\t\teventInstance.dateProfile,\r\n\t\t\t\tthis.calendar\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\tthis.triggerEventDrop(\r\n\t\t\teventInstance,\r\n\t\t\t// a drop doesn't necessarily mean a date mutation (ex: resource change)\r\n\t\t\t(dateMutation && dateMutation.dateDelta) || moment.duration(),\r\n\t\t\tundoFunc,\r\n\t\t\tel, ev\r\n\t\t);\r\n\t},\r\n\r\n\r\n\t// Triggers event-drop handlers that have subscribed via the API\r\n\ttriggerEventDrop: function(eventInstance, dateDelta, undoFunc, el, ev) {\r\n\t\tthis.publiclyTrigger('eventDrop', {\r\n\t\t\tcontext: el[0],\r\n\t\t\targs: [\r\n\t\t\t\teventInstance.toLegacy(),\r\n\t\t\t\tdateDelta,\r\n\t\t\t\tundoFunc,\r\n\t\t\t\tev,\r\n\t\t\t\t{}, // {} = jqui dummy\r\n\t\t\t\tthis\r\n\t\t\t]\r\n\t\t});\r\n\t},\r\n\r\n\r\n\t/* External Element Drag-n-Drop\r\n\t------------------------------------------------------------------------------------------------------------------*/\r\n\r\n\r\n\t// Must be called when an external element, via jQuery UI, has been dropped onto the calendar.\r\n\t// `meta` is the parsed data that has been embedded into the dragging event.\r\n\t// `dropLocation` is an object that contains the new zoned start/end/allDay values for the event.\r\n\treportExternalDrop: function(singleEventDef, isEvent, isSticky, el, ev, ui) {\r\n\r\n\t\tif (isEvent) {\r\n\t\t\tthis.calendar.eventManager.addEventDef(singleEventDef, isSticky);\r\n\t\t}\r\n\r\n\t\tthis.triggerExternalDrop(singleEventDef, isEvent, el, ev, ui);\r\n\t},\r\n\r\n\r\n\t// Triggers external-drop handlers that have subscribed via the API\r\n\ttriggerExternalDrop: function(singleEventDef, isEvent, el, ev, ui) {\r\n\r\n\t\t// trigger 'drop' regardless of whether element represents an event\r\n\t\tthis.publiclyTrigger('drop', {\r\n\t\t\tcontext: el[0],\r\n\t\t\targs: [\r\n\t\t\t\tsingleEventDef.dateProfile.start.clone(),\r\n\t\t\t\tev,\r\n\t\t\t\tui,\r\n\t\t\t\tthis\r\n\t\t\t]\r\n\t\t});\r\n\r\n\t\tif (isEvent) {\r\n\t\t\t// signal an external event landed\r\n\t\t\tthis.publiclyTrigger('eventReceive', {\r\n\t\t\t\tcontext: this,\r\n\t\t\t\targs: [\r\n\t\t\t\t\tsingleEventDef.buildInstance().toLegacy(),\r\n\t\t\t\t\tthis\r\n\t\t\t\t]\r\n\t\t\t});\r\n\t\t}\r\n\t},\r\n\r\n\r\n\t/* Event Resizing\r\n\t------------------------------------------------------------------------------------------------------------------*/\r\n\r\n\r\n\t// Must be called when an event in the view has been resized to a new length\r\n\treportEventResize: function(eventInstance, eventMutation, el, ev) {\r\n\t\tvar eventManager = this.calendar.eventManager;\r\n\t\tvar undoFunc = eventManager.mutateEventsWithId(\r\n\t\t\teventInstance.def.id,\r\n\t\t\teventMutation,\r\n\t\t\tthis.calendar\r\n\t\t);\r\n\r\n\t\t// update the EventInstance, for handlers\r\n\t\teventInstance.dateProfile = eventMutation.dateMutation.buildNewDateProfile(\r\n\t\t\teventInstance.dateProfile,\r\n\t\t\tthis.calendar\r\n\t\t);\r\n\r\n\t\tthis.triggerEventResize(\r\n\t\t\teventInstance,\r\n\t\t\teventMutation.dateMutation.endDelta,\r\n\t\t\tundoFunc,\r\n\t\t\tel, ev\r\n\t\t);\r\n\t},\r\n\r\n\r\n\t// Triggers event-resize handlers that have subscribed via the API\r\n\ttriggerEventResize: function(eventInstance, durationDelta, undoFunc, el, ev) {\r\n\t\tthis.publiclyTrigger('eventResize', {\r\n\t\t\tcontext: el[0],\r\n\t\t\targs: [\r\n\t\t\t\teventInstance.toLegacy(),\r\n\t\t\t\tdurationDelta,\r\n\t\t\t\tundoFunc,\r\n\t\t\t\tev,\r\n\t\t\t\t{}, // {} = jqui dummy\r\n\t\t\t\tthis\r\n\t\t\t]\r\n\t\t});\r\n\t},\r\n\r\n\r\n\t/* Selection (time range)\r\n\t------------------------------------------------------------------------------------------------------------------*/\r\n\r\n\r\n\t// Selects a date span on the view. `start` and `end` are both Moments.\r\n\t// `ev` is the native mouse event that begin the interaction.\r\n\tselect: function(footprint, ev) {\r\n\t\tthis.unselect(ev);\r\n\t\tthis.renderSelectionFootprint(footprint);\r\n\t\tthis.reportSelection(footprint, ev);\r\n\t},\r\n\r\n\r\n\trenderSelectionFootprint: function(footprint, ev) {\r\n\t\tif (this.renderSelection) { // legacy method in custom view classes\r\n\t\t\tthis.renderSelection(\r\n\t\t\t\tfootprint.toLegacy(this.calendar)\r\n\t\t\t);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tInteractiveDateComponent.prototype.renderSelectionFootprint.apply(this, arguments);\r\n\t\t}\r\n\t},\r\n\r\n\r\n\t// Called when a new selection is made. Updates internal state and triggers handlers.\r\n\treportSelection: function(footprint, ev) {\r\n\t\tthis.isSelected = true;\r\n\t\tthis.triggerSelect(footprint, ev);\r\n\t},\r\n\r\n\r\n\t// Triggers handlers to 'select'\r\n\ttriggerSelect: function(footprint, ev) {\r\n\t\tvar dateProfile = this.calendar.footprintToDateProfile(footprint); // abuse of \"Event\"DateProfile?\r\n\r\n\t\tthis.publiclyTrigger('select', {\r\n\t\t\tcontext: this,\r\n\t\t\targs: [\r\n\t\t\t\tdateProfile.start,\r\n\t\t\t\tdateProfile.end,\r\n\t\t\t\tev,\r\n\t\t\t\tthis\r\n\t\t\t]\r\n\t\t});\r\n\t},\r\n\r\n\r\n\t// Undoes a selection. updates in the internal state and triggers handlers.\r\n\t// `ev` is the native mouse event that began the interaction.\r\n\tunselect: function(ev) {\r\n\t\tif (this.isSelected) {\r\n\t\t\tthis.isSelected = false;\r\n\t\t\tif (this.destroySelection) {\r\n\t\t\t\tthis.destroySelection(); // TODO: deprecate\r\n\t\t\t}\r\n\t\t\tthis.unrenderSelection();\r\n\t\t\tthis.publiclyTrigger('unselect', {\r\n\t\t\t\tcontext: this,\r\n\t\t\t\targs: [ ev, this ]\r\n\t\t\t});\r\n\t\t}\r\n\t},\r\n\r\n\r\n\t/* Event Selection\r\n\t------------------------------------------------------------------------------------------------------------------*/\r\n\r\n\r\n\tselectEventInstance: function(eventInstance) {\r\n\t\tif (\r\n\t\t\t!this.selectedEventInstance ||\r\n\t\t\tthis.selectedEventInstance !== eventInstance\r\n\t\t) {\r\n\t\t\tthis.unselectEventInstance();\r\n\r\n\t\t\tthis.getEventSegs().forEach(function(seg) {\r\n\t\t\t\tif (\r\n\t\t\t\t\tseg.footprint.eventInstance === eventInstance &&\r\n\t\t\t\t\tseg.el // necessary?\r\n\t\t\t\t) {\r\n\t\t\t\t\tseg.el.addClass('fc-selected');\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t\tthis.selectedEventInstance = eventInstance;\r\n\t\t}\r\n\t},\r\n\r\n\r\n\tunselectEventInstance: function() {\r\n\t\tif (this.selectedEventInstance) {\r\n\r\n\t\t\tthis.getEventSegs().forEach(function(seg) {\r\n\t\t\t\tif (seg.el) { // necessary?\r\n\t\t\t\t\tseg.el.removeClass('fc-selected');\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t\tthis.selectedEventInstance = null;\r\n\t\t}\r\n\t},\r\n\r\n\r\n\tisEventDefSelected: function(eventDef) {\r\n\t\t// event references might change on refetchEvents(), while selectedEventInstance doesn't,\r\n\t\t// so compare IDs\r\n\t\treturn this.selectedEventInstance && this.selectedEventInstance.def.id === eventDef.id;\r\n\t},\r\n\r\n\r\n\t/* Mouse / Touch Unselecting (time range & event unselection)\r\n\t------------------------------------------------------------------------------------------------------------------*/\r\n\t// TODO: move consistently to down/start or up/end?\r\n\t// TODO: don't kill previous selection if touch scrolling\r\n\r\n\r\n\thandleDocumentMousedown: function(ev) {\r\n\t\tif (isPrimaryMouseButton(ev)) {\r\n\t\t\tthis.processUnselect(ev);\r\n\t\t}\r\n\t},\r\n\r\n\r\n\tprocessUnselect: function(ev) {\r\n\t\tthis.processRangeUnselect(ev);\r\n\t\tthis.processEventUnselect(ev);\r\n\t},\r\n\r\n\r\n\tprocessRangeUnselect: function(ev) {\r\n\t\tvar ignore;\r\n\r\n\t\t// is there a time-range selection?\r\n\t\tif (this.isSelected && this.opt('unselectAuto')) {\r\n\t\t\t// only unselect if the clicked element is not identical to or inside of an 'unselectCancel' element\r\n\t\t\tignore = this.opt('unselectCancel');\r\n\t\t\tif (!ignore || !$(ev.target).closest(ignore).length) {\r\n\t\t\t\tthis.unselect(ev);\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\r\n\tprocessEventUnselect: function(ev) {\r\n\t\tif (this.selectedEventInstance) {\r\n\t\t\tif (!$(ev.target).closest('.fc-selected').length) {\r\n\t\t\t\tthis.unselectEventInstance();\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\r\n\t/* Triggers\r\n\t------------------------------------------------------------------------------------------------------------------*/\r\n\r\n\r\n\ttriggerBaseRendered: function() {\r\n\t\tthis.publiclyTrigger('viewRender', {\r\n\t\t\tcontext: this,\r\n\t\t\targs: [ this, this.el ]\r\n\t\t});\r\n\t},\r\n\r\n\r\n\ttriggerBaseUnrendered: function() {\r\n\t\tthis.publiclyTrigger('viewDestroy', {\r\n\t\t\tcontext: this,\r\n\t\t\targs: [ this, this.el ]\r\n\t\t});\r\n\t},\r\n\r\n\r\n\t// Triggers handlers to 'dayClick'\r\n\t// Span has start/end of the clicked area. Only the start is useful.\r\n\ttriggerDayClick: function(footprint, dayEl, ev) {\r\n\t\tvar dateProfile = this.calendar.footprintToDateProfile(footprint); // abuse of \"Event\"DateProfile?\r\n\r\n\t\tthis.publiclyTrigger('dayClick', {\r\n\t\t\tcontext: dayEl,\r\n\t\t\targs: [ dateProfile.start, ev, this ]\r\n\t\t});\r\n\t}\r\n\r\n});\r\n\r\n\r\nView.watch('displayingDates', [ 'isInDom', 'dateProfile' ], function(deps) {\r\n\tthis.requestDateRender(deps.dateProfile);\r\n}, function() {\r\n\tthis.requestDateUnrender();\r\n});\r\n\r\n\r\nView.watch('displayingBusinessHours', [ 'displayingDates', 'businessHourGenerator' ], function(deps) {\r\n\tthis.requestBusinessHoursRender(deps.businessHourGenerator);\r\n}, function() {\r\n\tthis.requestBusinessHoursUnrender();\r\n});\r\n\r\n\r\nView.watch('initialEvents', [ 'dateProfile' ], function(deps) {\r\n\treturn this.fetchInitialEvents(deps.dateProfile);\r\n});\r\n\r\n\r\nView.watch('bindingEvents', [ 'initialEvents' ], function(deps) {\r\n\tthis.setEvents(deps.initialEvents);\r\n\tthis.bindEventChanges();\r\n}, function() {\r\n\tthis.unbindEventChanges();\r\n\tthis.unsetEvents();\r\n});\r\n\r\n\r\nView.watch('displayingEvents', [ 'displayingDates', 'hasEvents' ], function() {\r\n\tthis.requestEventsRender(this.get('currentEvents'));\r\n}, function() {\r\n\tthis.requestEventsUnrender();\r\n});\r\n\r\n\r\nView.watch('title', [ 'dateProfile' ], function(deps) {\r\n\treturn (this.title = this.computeTitle(deps.dateProfile)); // assign to View for legacy reasons\r\n});\r\n\r\n\r\nView.watch('legacyDateProps', [ 'dateProfile' ], function(deps) {\r\n\tvar calendar = this.calendar;\r\n\tvar dateProfile = deps.dateProfile;\r\n\r\n\t// DEPRECATED, but we need to keep it updated...\r\n\tthis.start = calendar.msToMoment(dateProfile.activeUnzonedRange.startMs, dateProfile.isRangeAllDay);\r\n\tthis.end = calendar.msToMoment(dateProfile.activeUnzonedRange.endMs, dateProfile.isRangeAllDay);\r\n\tthis.intervalStart = calendar.msToMoment(dateProfile.currentUnzonedRange.startMs, dateProfile.isRangeAllDay);\r\n\tthis.intervalEnd = calendar.msToMoment(dateProfile.currentUnzonedRange.endMs, dateProfile.isRangeAllDay);\r\n});\r\n\r\n;;\r\n\r\nView.mixin({\r\n\r\n\tusesMinMaxTime: false, // whether minTime/maxTime will affect the activeUnzonedRange. Views must opt-in.\r\n\r\n\t// DEPRECATED\r\n\tstart: null, // use activeUnzonedRange\r\n\tend: null, // use activeUnzonedRange\r\n\tintervalStart: null, // use currentUnzonedRange\r\n\tintervalEnd: null, // use currentUnzonedRange\r\n\r\n\r\n\t/* Date Range Computation\r\n\t------------------------------------------------------------------------------------------------------------------*/\r\n\r\n\r\n\t// Builds a structure with info about what the dates/ranges will be for the \"prev\" view.\r\n\tbuildPrevDateProfile: function(date) {\r\n\t\tvar dateProfile = this.get('dateProfile');\r\n\t\tvar prevDate = date.clone().startOf(dateProfile.currentRangeUnit)\r\n\t\t\t.subtract(dateProfile.dateIncrement);\r\n\r\n\t\treturn this.buildDateProfile(prevDate, -1);\r\n\t},\r\n\r\n\r\n\t// Builds a structure with info about what the dates/ranges will be for the \"next\" view.\r\n\tbuildNextDateProfile: function(date) {\r\n\t\tvar dateProfile = this.get('dateProfile');\r\n\t\tvar nextDate = date.clone().startOf(dateProfile.currentRangeUnit)\r\n\t\t\t.add(dateProfile.dateIncrement);\r\n\r\n\t\treturn this.buildDateProfile(nextDate, 1);\r\n\t},\r\n\r\n\r\n\t// Builds a structure holding dates/ranges for rendering around the given date.\r\n\t// Optional direction param indicates whether the date is being incremented/decremented\r\n\t// from its previous value. decremented = -1, incremented = 1 (default).\r\n\tbuildDateProfile: function(date, direction, forceToValid) {\r\n\t\tvar isDateAllDay = !date.hasTime();\r\n\t\tvar validUnzonedRange;\r\n\t\tvar minTime = null;\r\n\t\tvar maxTime = null;\r\n\t\tvar currentInfo;\r\n\t\tvar isRangeAllDay;\r\n\t\tvar renderUnzonedRange;\r\n\t\tvar activeUnzonedRange;\r\n\t\tvar isValid;\r\n\r\n\t\tvalidUnzonedRange = this.buildValidRange();\r\n\t\tvalidUnzonedRange = this.trimHiddenDays(validUnzonedRange);\r\n\r\n\t\tif (forceToValid) {\r\n\t\t\tdate = this.calendar.msToUtcMoment(\r\n\t\t\t\tvalidUnzonedRange.constrainDate(date), // returns MS\r\n\t\t\t\tisDateAllDay\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\tcurrentInfo = this.buildCurrentRangeInfo(date, direction);\r\n\t\tisRangeAllDay = /^(year|month|week|day)$/.test(currentInfo.unit);\r\n\t\trenderUnzonedRange = this.buildRenderRange(\r\n\t\t\tthis.trimHiddenDays(currentInfo.unzonedRange),\r\n\t\t\tcurrentInfo.unit,\r\n\t\t\tisRangeAllDay\r\n\t\t);\r\n\t\trenderUnzonedRange = this.trimHiddenDays(renderUnzonedRange);\r\n\t\tactiveUnzonedRange = renderUnzonedRange.clone();\r\n\r\n\t\tif (!this.opt('showNonCurrentDates')) {\r\n\t\t\tactiveUnzonedRange = activeUnzonedRange.intersect(currentInfo.unzonedRange);\r\n\t\t}\r\n\r\n\t\tminTime = moment.duration(this.opt('minTime'));\r\n\t\tmaxTime = moment.duration(this.opt('maxTime'));\r\n\t\tactiveUnzonedRange = this.adjustActiveRange(activeUnzonedRange, minTime, maxTime);\r\n\t\tactiveUnzonedRange = activeUnzonedRange.intersect(validUnzonedRange); // might return null\r\n\r\n\t\tif (activeUnzonedRange) {\r\n\t\t\tdate = this.calendar.msToUtcMoment(\r\n\t\t\t\tactiveUnzonedRange.constrainDate(date), // returns MS\r\n\t\t\t\tisDateAllDay\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\t// it's invalid if the originally requested date is not contained,\r\n\t\t// or if the range is completely outside of the valid range.\r\n\t\tisValid = currentInfo.unzonedRange.intersectsWith(validUnzonedRange);\r\n\r\n\t\treturn {\r\n\t\t\t// constraint for where prev/next operations can go and where events can be dragged/resized to.\r\n\t\t\t// an object with optional start and end properties.\r\n\t\t\tvalidUnzonedRange: validUnzonedRange,\r\n\r\n\t\t\t// range the view is formally responsible for.\r\n\t\t\t// for example, a month view might have 1st-31st, excluding padded dates\r\n\t\t\tcurrentUnzonedRange: currentInfo.unzonedRange,\r\n\r\n\t\t\t// name of largest unit being displayed, like \"month\" or \"week\"\r\n\t\t\tcurrentRangeUnit: currentInfo.unit,\r\n\r\n\t\t\tisRangeAllDay: isRangeAllDay,\r\n\r\n\t\t\t// dates that display events and accept drag-n-drop\r\n\t\t\t// will be `null` if no dates accept events\r\n\t\t\tactiveUnzonedRange: activeUnzonedRange,\r\n\r\n\t\t\t// date range with a rendered skeleton\r\n\t\t\t// includes not-active days that need some sort of DOM\r\n\t\t\trenderUnzonedRange: renderUnzonedRange,\r\n\r\n\t\t\t// Duration object that denotes the first visible time of any given day\r\n\t\t\tminTime: minTime,\r\n\r\n\t\t\t// Duration object that denotes the exclusive visible end time of any given day\r\n\t\t\tmaxTime: maxTime,\r\n\r\n\t\t\tisValid: isValid,\r\n\r\n\t\t\tdate: date,\r\n\r\n\t\t\t// how far the current date will move for a prev/next operation\r\n\t\t\tdateIncrement: this.buildDateIncrement(currentInfo.duration)\r\n\t\t\t\t// pass a fallback (might be null) ^\r\n\t\t};\r\n\t},\r\n\r\n\r\n\t// Builds an object with optional start/end properties.\r\n\t// Indicates the minimum/maximum dates to display.\r\n\t// not responsible for trimming hidden days.\r\n\tbuildValidRange: function() {\r\n\t\treturn this.getUnzonedRangeOption('validRange', this.calendar.getNow()) ||\r\n\t\t\tnew UnzonedRange(); // completely open-ended\r\n\t},\r\n\r\n\r\n\t// Builds a structure with info about the \"current\" range, the range that is\r\n\t// highlighted as being the current month for example.\r\n\t// See buildDateProfile for a description of `direction`.\r\n\t// Guaranteed to have `range` and `unit` properties. `duration` is optional.\r\n\t// TODO: accept a MS-time instead of a moment `date`?\r\n\tbuildCurrentRangeInfo: function(date, direction) {\r\n\t\tvar duration = null;\r\n\t\tvar unit = null;\r\n\t\tvar unzonedRange = null;\r\n\t\tvar dayCount;\r\n\r\n\t\tif (this.viewSpec.duration) {\r\n\t\t\tduration = this.viewSpec.duration;\r\n\t\t\tunit = this.viewSpec.durationUnit;\r\n\t\t\tunzonedRange = this.buildRangeFromDuration(date, direction, duration, unit);\r\n\t\t}\r\n\t\telse if ((dayCount = this.opt('dayCount'))) {\r\n\t\t\tunit = 'day';\r\n\t\t\tunzonedRange = this.buildRangeFromDayCount(date, direction, dayCount);\r\n\t\t}\r\n\t\telse if ((unzonedRange = this.buildCustomVisibleRange(date))) {\r\n\t\t\tunit = computeGreatestUnit(unzonedRange.getStart(), unzonedRange.getEnd());\r\n\t\t}\r\n\t\telse {\r\n\t\t\tduration = this.getFallbackDuration();\r\n\t\t\tunit = computeGreatestUnit(duration);\r\n\t\t\tunzonedRange = this.buildRangeFromDuration(date, direction, duration, unit);\r\n\t\t}\r\n\r\n\t\treturn { duration: duration, unit: unit, unzonedRange: unzonedRange };\r\n\t},\r\n\r\n\r\n\tgetFallbackDuration: function() {\r\n\t\treturn moment.duration({ days: 1 });\r\n\t},\r\n\r\n\r\n\t// Returns a new activeUnzonedRange to have time values (un-ambiguate)\r\n\t// minTime or maxTime causes the range to expand.\r\n\tadjustActiveRange: function(unzonedRange, minTime, maxTime) {\r\n\t\tvar start = unzonedRange.getStart();\r\n\t\tvar end = unzonedRange.getEnd();\r\n\r\n\t\tif (this.usesMinMaxTime) {\r\n\r\n\t\t\tif (minTime < 0) {\r\n\t\t\t\tstart.time(0).add(minTime);\r\n\t\t\t}\r\n\r\n\t\t\tif (maxTime > 24 * 60 * 60 * 1000) { // beyond 24 hours?\r\n\t\t\t\tend.time(maxTime - (24 * 60 * 60 * 1000));\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn new UnzonedRange(start, end);\r\n\t},\r\n\r\n\r\n\t// Builds the \"current\" range when it is specified as an explicit duration.\r\n\t// `unit` is the already-computed computeGreatestUnit value of duration.\r\n\t// TODO: accept a MS-time instead of a moment `date`?\r\n\tbuildRangeFromDuration: function(date, direction, duration, unit) {\r\n\t\tvar alignment = this.opt('dateAlignment');\r\n\t\tvar start = date.clone();\r\n\t\tvar end;\r\n\t\tvar dateIncrementInput;\r\n\t\tvar dateIncrementDuration;\r\n\r\n\t\t// if the view displays a single day or smaller\r\n\t\tif (duration.as('days') <= 1) {\r\n\t\t\tif (this.isHiddenDay(start)) {\r\n\t\t\t\tstart = this.skipHiddenDays(start, direction);\r\n\t\t\t\tstart.startOf('day');\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// compute what the alignment should be\r\n\t\tif (!alignment) {\r\n\t\t\tdateIncrementInput = this.opt('dateIncrement');\r\n\r\n\t\t\tif (dateIncrementInput) {\r\n\t\t\t\tdateIncrementDuration = moment.duration(dateIncrementInput);\r\n\r\n\t\t\t\t// use the smaller of the two units\r\n\t\t\t\tif (dateIncrementDuration < duration) {\r\n\t\t\t\t\talignment = computeDurationGreatestUnit(dateIncrementDuration, dateIncrementInput);\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\talignment = unit;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\talignment = unit;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tstart.startOf(alignment);\r\n\t\tend = start.clone().add(duration);\r\n\r\n\t\treturn new UnzonedRange(start, end);\r\n\t},\r\n\r\n\r\n\t// Builds the \"current\" range when a dayCount is specified.\r\n\t// TODO: accept a MS-time instead of a moment `date`?\r\n\tbuildRangeFromDayCount: function(date, direction, dayCount) {\r\n\t\tvar customAlignment = this.opt('dateAlignment');\r\n\t\tvar runningCount = 0;\r\n\t\tvar start = date.clone();\r\n\t\tvar end;\r\n\r\n\t\tif (customAlignment) {\r\n\t\t\tstart.startOf(customAlignment);\r\n\t\t}\r\n\r\n\t\tstart.startOf('day');\r\n\t\tstart = this.skipHiddenDays(start, direction);\r\n\r\n\t\tend = start.clone();\r\n\t\tdo {\r\n\t\t\tend.add(1, 'day');\r\n\t\t\tif (!this.isHiddenDay(end)) {\r\n\t\t\t\trunningCount++;\r\n\t\t\t}\r\n\t\t} while (runningCount < dayCount);\r\n\r\n\t\treturn new UnzonedRange(start, end);\r\n\t},\r\n\r\n\r\n\t// Builds a normalized range object for the \"visible\" range,\r\n\t// which is a way to define the currentUnzonedRange and activeUnzonedRange at the same time.\r\n\t// TODO: accept a MS-time instead of a moment `date`?\r\n\tbuildCustomVisibleRange: function(date) {\r\n\t\tvar visibleUnzonedRange = this.getUnzonedRangeOption(\r\n\t\t\t'visibleRange',\r\n\t\t\tthis.calendar.applyTimezone(date) // correct zone. also generates new obj that avoids mutations\r\n\t\t);\r\n\r\n\t\tif (visibleUnzonedRange && (visibleUnzonedRange.startMs === null || visibleUnzonedRange.endMs === null)) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\treturn visibleUnzonedRange;\r\n\t},\r\n\r\n\r\n\t// Computes the range that will represent the element/cells for *rendering*,\r\n\t// but which may have voided days/times.\r\n\t// not responsible for trimming hidden days.\r\n\tbuildRenderRange: function(currentUnzonedRange, currentRangeUnit, isRangeAllDay) {\r\n\t\treturn currentUnzonedRange.clone();\r\n\t},\r\n\r\n\r\n\t// Compute the duration value that should be added/substracted to the current date\r\n\t// when a prev/next operation happens.\r\n\tbuildDateIncrement: function(fallback) {\r\n\t\tvar dateIncrementInput = this.opt('dateIncrement');\r\n\t\tvar customAlignment;\r\n\r\n\t\tif (dateIncrementInput) {\r\n\t\t\treturn moment.duration(dateIncrementInput);\r\n\t\t}\r\n\t\telse if ((customAlignment = this.opt('dateAlignment'))) {\r\n\t\t\treturn moment.duration(1, customAlignment);\r\n\t\t}\r\n\t\telse if (fallback) {\r\n\t\t\treturn fallback;\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn moment.duration({ days: 1 });\r\n\t\t}\r\n\t},\r\n\r\n\r\n\t// Remove days from the beginning and end of the range that are computed as hidden.\r\n\ttrimHiddenDays: function(inputUnzonedRange) {\r\n\t\tvar start = inputUnzonedRange.getStart();\r\n\t\tvar end = inputUnzonedRange.getEnd();\r\n\r\n\t\tif (start) {\r\n\t\t\tstart = this.skipHiddenDays(start);\r\n\t\t}\r\n\r\n\t\tif (end) {\r\n\t\t\tend = this.skipHiddenDays(end, -1, true);\r\n\t\t}\r\n\r\n\t\treturn new UnzonedRange(start, end);\r\n\t},\r\n\r\n\r\n\t// For DateComponent::getDayClasses\r\n\tisDateInOtherMonth: function(date, dateProfile) {\r\n\t\treturn false;\r\n\t},\r\n\r\n\r\n\t// Arguments after name will be forwarded to a hypothetical function value\r\n\t// WARNING: passed-in arguments will be given to generator functions as-is and can cause side-effects.\r\n\t// Always clone your objects if you fear mutation.\r\n\tgetUnzonedRangeOption: function(name) {\r\n\t\tvar val = this.opt(name);\r\n\r\n\t\tif (typeof val === 'function') {\r\n\t\t\tval = val.apply(\r\n\t\t\t\tnull,\r\n\t\t\t\tArray.prototype.slice.call(arguments, 1)\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\tif (val) {\r\n\t\t\treturn this.calendar.parseUnzonedRange(val);\r\n\t\t}\r\n\t},\r\n\r\n\r\n\t/* Hidden Days\r\n\t------------------------------------------------------------------------------------------------------------------*/\r\n\r\n\r\n\t// Initializes internal variables related to calculating hidden days-of-week\r\n\tinitHiddenDays: function() {\r\n\t\tvar hiddenDays = this.opt('hiddenDays') || []; // array of day-of-week indices that are hidden\r\n\t\tvar isHiddenDayHash = []; // is the day-of-week hidden? (hash with day-of-week-index -> bool)\r\n\t\tvar dayCnt = 0;\r\n\t\tvar i;\r\n\r\n\t\tif (this.opt('weekends') === false) {\r\n\t\t\thiddenDays.push(0, 6); // 0=sunday, 6=saturday\r\n\t\t}\r\n\r\n\t\tfor (i = 0; i < 7; i++) {\r\n\t\t\tif (\r\n\t\t\t\t!(isHiddenDayHash[i] = $.inArray(i, hiddenDays) !== -1)\r\n\t\t\t) {\r\n\t\t\t\tdayCnt++;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (!dayCnt) {\r\n\t\t\tthrow 'invalid hiddenDays'; // all days were hidden? bad.\r\n\t\t}\r\n\r\n\t\tthis.isHiddenDayHash = isHiddenDayHash;\r\n\t},\r\n\r\n\r\n\t// Is the current day hidden?\r\n\t// `day` is a day-of-week index (0-6), or a Moment\r\n\tisHiddenDay: function(day) {\r\n\t\tif (moment.isMoment(day)) {\r\n\t\t\tday = day.day();\r\n\t\t}\r\n\t\treturn this.isHiddenDayHash[day];\r\n\t},\r\n\r\n\r\n\t// Incrementing the current day until it is no longer a hidden day, returning a copy.\r\n\t// DOES NOT CONSIDER validUnzonedRange!\r\n\t// If the initial value of `date` is not a hidden day, don't do anything.\r\n\t// Pass `isExclusive` as `true` if you are dealing with an end date.\r\n\t// `inc` defaults to `1` (increment one day forward each time)\r\n\tskipHiddenDays: function(date, inc, isExclusive) {\r\n\t\tvar out = date.clone();\r\n\t\tinc = inc || 1;\r\n\t\twhile (\r\n\t\t\tthis.isHiddenDayHash[(out.day() + (isExclusive ? inc : 0) + 7) % 7]\r\n\t\t) {\r\n\t\t\tout.add(inc, 'days');\r\n\t\t}\r\n\t\treturn out;\r\n\t}\r\n\r\n});\r\n\r\n;;\r\n\r\n/* Toolbar with buttons and title\r\n----------------------------------------------------------------------------------------------------------------------*/\r\n\r\nfunction Toolbar(calendar, toolbarOptions) {\r\n\tvar t = this;\r\n\r\n\t// exports\r\n\tt.setToolbarOptions = setToolbarOptions;\r\n\tt.render = render;\r\n\tt.removeElement = removeElement;\r\n\tt.updateTitle = updateTitle;\r\n\tt.activateButton = activateButton;\r\n\tt.deactivateButton = deactivateButton;\r\n\tt.disableButton = disableButton;\r\n\tt.enableButton = enableButton;\r\n\tt.getViewsWithButtons = getViewsWithButtons;\r\n\tt.el = null; // mirrors local `el`\r\n\r\n\t// locals\r\n\tvar el;\r\n\tvar viewsWithButtons = [];\r\n\r\n\t// method to update toolbar-specific options, not calendar-wide options\r\n\tfunction setToolbarOptions(newToolbarOptions) {\r\n\t\ttoolbarOptions = newToolbarOptions;\r\n\t}\r\n\r\n\t// can be called repeatedly and will rerender\r\n\tfunction render() {\r\n\t\tvar sections = toolbarOptions.layout;\r\n\r\n\t\tif (sections) {\r\n\t\t\tif (!el) {\r\n\t\t\t\tel = this.el = $(\"<div class='fc-toolbar \"+ toolbarOptions.extraClasses + \"'/>\");\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tel.empty();\r\n\t\t\t}\r\n\t\t\tel.append(renderSection('left'))\r\n\t\t\t\t.append(renderSection('right'))\r\n\t\t\t\t.append(renderSection('center'))\r\n\t\t\t\t.append('<div class=\"fc-clear\"/>');\r\n\t\t}\r\n\t\telse {\r\n\t\t\tremoveElement();\r\n\t\t}\r\n\t}\r\n\r\n\r\n\tfunction removeElement() {\r\n\t\tif (el) {\r\n\t\t\tel.remove();\r\n\t\t\tel = t.el = null;\r\n\t\t}\r\n\t}\r\n\r\n\r\n\tfunction renderSection(position) {\r\n\t\tvar theme = calendar.theme;\r\n\t\tvar sectionEl = $('<div class=\"fc-' + position + '\"/>');\r\n\t\tvar buttonStr = toolbarOptions.layout[position];\r\n\t\tvar calendarCustomButtons = calendar.opt('customButtons') || {};\r\n\t\tvar calendarButtonTextOverrides = calendar.overrides.buttonText || {};\r\n\t\tvar calendarButtonText = calendar.opt('buttonText') || {};\r\n\r\n\t\tif (buttonStr) {\r\n\t\t\t$.each(buttonStr.split(' '), function(i) {\r\n\t\t\t\tvar groupChildren = $();\r\n\t\t\t\tvar isOnlyButtons = true;\r\n\t\t\t\tvar groupEl;\r\n\r\n\t\t\t\t$.each(this.split(','), function(j, buttonName) {\r\n\t\t\t\t\tvar customButtonProps;\r\n\t\t\t\t\tvar viewSpec;\r\n\t\t\t\t\tvar buttonClick;\r\n\t\t\t\t\tvar buttonIcon; // only one of these will be set\r\n\t\t\t\t\tvar buttonText; // \"\r\n\t\t\t\t\tvar buttonInnerHtml;\r\n\t\t\t\t\tvar buttonClasses;\r\n\t\t\t\t\tvar buttonEl;\r\n\r\n\t\t\t\t\tif (buttonName == 'title') {\r\n\t\t\t\t\t\tgroupChildren = groupChildren.add($('<h2>&nbsp;</h2>')); // we always want it to take up height\r\n\t\t\t\t\t\tisOnlyButtons = false;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\r\n\t\t\t\t\t\tif ((customButtonProps = calendarCustomButtons[buttonName])) {\r\n\t\t\t\t\t\t\tbuttonClick = function(ev) {\r\n\t\t\t\t\t\t\t\tif (customButtonProps.click) {\r\n\t\t\t\t\t\t\t\t\tcustomButtonProps.click.call(buttonEl[0], ev);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t};\r\n\t\t\t\t\t\t\t(buttonIcon = theme.getCustomButtonIconClass(customButtonProps)) ||\r\n\t\t\t\t\t\t\t(buttonIcon = theme.getIconClass(buttonName)) ||\r\n\t\t\t\t\t\t\t(buttonText = customButtonProps.text); // jshint ignore:line\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse if ((viewSpec = calendar.getViewSpec(buttonName))) {\r\n\t\t\t\t\t\t\tviewsWithButtons.push(buttonName);\r\n\t\t\t\t\t\t\tbuttonClick = function() {\r\n\t\t\t\t\t\t\t\tcalendar.changeView(buttonName);\r\n\t\t\t\t\t\t\t};\r\n\t\t\t\t\t\t\t(buttonText = viewSpec.buttonTextOverride) ||\r\n\t\t\t\t\t\t\t(buttonIcon = theme.getIconClass(buttonName)) ||\r\n\t\t\t\t\t\t\t(buttonText = viewSpec.buttonTextDefault); // jshint ignore:line\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse if (calendar[buttonName]) { // a calendar method\r\n\t\t\t\t\t\t\tbuttonClick = function() {\r\n\t\t\t\t\t\t\t\tcalendar[buttonName]();\r\n\t\t\t\t\t\t\t};\r\n\t\t\t\t\t\t\t(buttonText = calendarButtonTextOverrides[buttonName]) ||\r\n\t\t\t\t\t\t\t(buttonIcon = theme.getIconClass(buttonName)) ||\r\n\t\t\t\t\t\t\t(buttonText = calendarButtonText[buttonName]); // jshint ignore:line\r\n\t\t\t\t\t\t\t//            ^ everything else is considered default\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif (buttonClick) {\r\n\r\n\t\t\t\t\t\t\tbuttonClasses = [\r\n\t\t\t\t\t\t\t\t'fc-' + buttonName + '-button',\r\n\t\t\t\t\t\t\t\ttheme.getClass('button'),\r\n\t\t\t\t\t\t\t\ttheme.getClass('stateDefault')\r\n\t\t\t\t\t\t\t];\r\n\r\n\t\t\t\t\t\t\tif (buttonText) {\r\n\t\t\t\t\t\t\t\tbuttonInnerHtml = htmlEscape(buttonText);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse if (buttonIcon) {\r\n\t\t\t\t\t\t\t\tbuttonInnerHtml = \"<span class='\" + buttonIcon + \"'></span>\";\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tbuttonEl = $( // type=\"button\" so that it doesn't submit a form\r\n\t\t\t\t\t\t\t\t'<button type=\"button\" class=\"' + buttonClasses.join(' ') + '\">' +\r\n\t\t\t\t\t\t\t\t\tbuttonInnerHtml +\r\n\t\t\t\t\t\t\t\t'</button>'\r\n\t\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t\t.click(function(ev) {\r\n\t\t\t\t\t\t\t\t\t// don't process clicks for disabled buttons\r\n\t\t\t\t\t\t\t\t\tif (!buttonEl.hasClass(theme.getClass('stateDisabled'))) {\r\n\r\n\t\t\t\t\t\t\t\t\t\tbuttonClick(ev);\r\n\r\n\t\t\t\t\t\t\t\t\t\t// after the click action, if the button becomes the \"active\" tab, or disabled,\r\n\t\t\t\t\t\t\t\t\t\t// it should never have a hover class, so remove it now.\r\n\t\t\t\t\t\t\t\t\t\tif (\r\n\t\t\t\t\t\t\t\t\t\t\tbuttonEl.hasClass(theme.getClass('stateActive')) ||\r\n\t\t\t\t\t\t\t\t\t\t\tbuttonEl.hasClass(theme.getClass('stateDisabled'))\r\n\t\t\t\t\t\t\t\t\t\t) {\r\n\t\t\t\t\t\t\t\t\t\t\tbuttonEl.removeClass(theme.getClass('stateHover'));\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t})\r\n\t\t\t\t\t\t\t\t.mousedown(function() {\r\n\t\t\t\t\t\t\t\t\t// the *down* effect (mouse pressed in).\r\n\t\t\t\t\t\t\t\t\t// only on buttons that are not the \"active\" tab, or disabled\r\n\t\t\t\t\t\t\t\t\tbuttonEl\r\n\t\t\t\t\t\t\t\t\t\t.not('.' + theme.getClass('stateActive'))\r\n\t\t\t\t\t\t\t\t\t\t.not('.' + theme.getClass('stateDisabled'))\r\n\t\t\t\t\t\t\t\t\t\t.addClass(theme.getClass('stateDown'));\r\n\t\t\t\t\t\t\t\t})\r\n\t\t\t\t\t\t\t\t.mouseup(function() {\r\n\t\t\t\t\t\t\t\t\t// undo the *down* effect\r\n\t\t\t\t\t\t\t\t\tbuttonEl.removeClass(theme.getClass('stateDown'));\r\n\t\t\t\t\t\t\t\t})\r\n\t\t\t\t\t\t\t\t.hover(\r\n\t\t\t\t\t\t\t\t\tfunction() {\r\n\t\t\t\t\t\t\t\t\t\t// the *hover* effect.\r\n\t\t\t\t\t\t\t\t\t\t// only on buttons that are not the \"active\" tab, or disabled\r\n\t\t\t\t\t\t\t\t\t\tbuttonEl\r\n\t\t\t\t\t\t\t\t\t\t\t.not('.' + theme.getClass('stateActive'))\r\n\t\t\t\t\t\t\t\t\t\t\t.not('.' + theme.getClass('stateDisabled'))\r\n\t\t\t\t\t\t\t\t\t\t\t.addClass(theme.getClass('stateHover'));\r\n\t\t\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\t\t\tfunction() {\r\n\t\t\t\t\t\t\t\t\t\t// undo the *hover* effect\r\n\t\t\t\t\t\t\t\t\t\tbuttonEl\r\n\t\t\t\t\t\t\t\t\t\t\t.removeClass(theme.getClass('stateHover'))\r\n\t\t\t\t\t\t\t\t\t\t\t.removeClass(theme.getClass('stateDown')); // if mouseleave happens before mouseup\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\t\tgroupChildren = groupChildren.add(buttonEl);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\r\n\t\t\t\tif (isOnlyButtons) {\r\n\t\t\t\t\tgroupChildren\r\n\t\t\t\t\t\t.first().addClass(theme.getClass('cornerLeft')).end()\r\n\t\t\t\t\t\t.last().addClass(theme.getClass('cornerRight')).end();\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (groupChildren.length > 1) {\r\n\t\t\t\t\tgroupEl = $('<div/>');\r\n\t\t\t\t\tif (isOnlyButtons) {\r\n\t\t\t\t\t\tgroupEl.addClass(theme.getClass('buttonGroup'));\r\n\t\t\t\t\t}\r\n\t\t\t\t\tgroupEl.append(groupChildren);\r\n\t\t\t\t\tsectionEl.append(groupEl);\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tsectionEl.append(groupChildren); // 1 or 0 children\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\treturn sectionEl;\r\n\t}\r\n\r\n\r\n\tfunction updateTitle(text) {\r\n\t\tif (el) {\r\n\t\t\tel.find('h2').text(text);\r\n\t\t}\r\n\t}\r\n\r\n\r\n\tfunction activateButton(buttonName) {\r\n\t\tif (el) {\r\n\t\t\tel.find('.fc-' + buttonName + '-button')\r\n\t\t\t\t.addClass(calendar.theme.getClass('stateActive'));\r\n\t\t}\r\n\t}\r\n\r\n\r\n\tfunction deactivateButton(buttonName) {\r\n\t\tif (el) {\r\n\t\t\tel.find('.fc-' + buttonName + '-button')\r\n\t\t\t\t.removeClass(calendar.theme.getClass('stateActive'));\r\n\t\t}\r\n\t}\r\n\r\n\r\n\tfunction disableButton(buttonName) {\r\n\t\tif (el) {\r\n\t\t\tel.find('.fc-' + buttonName + '-button')\r\n\t\t\t\t.prop('disabled', true)\r\n\t\t\t\t.addClass(calendar.theme.getClass('stateDisabled'));\r\n\t\t}\r\n\t}\r\n\r\n\r\n\tfunction enableButton(buttonName) {\r\n\t\tif (el) {\r\n\t\t\tel.find('.fc-' + buttonName + '-button')\r\n\t\t\t\t.prop('disabled', false)\r\n\t\t\t\t.removeClass(calendar.theme.getClass('stateDisabled'));\r\n\t\t}\r\n\t}\r\n\r\n\r\n\tfunction getViewsWithButtons() {\r\n\t\treturn viewsWithButtons;\r\n\t}\r\n\r\n}\r\n\r\n;;\r\n\r\nvar Calendar = FC.Calendar = Class.extend(EmitterMixin, ListenerMixin, {\r\n\r\n\tview: null, // current View object\r\n\tviewsByType: null, // holds all instantiated view instances, current or not\r\n\tcurrentDate: null, // unzoned moment. private (public API should use getDate instead)\r\n\ttheme: null,\r\n\tbusinessHourGenerator: null,\r\n\tloadingLevel: 0, // number of simultaneous loading tasks\r\n\r\n\r\n\tconstructor: function(el, overrides) {\r\n\r\n\t\t// declare the current calendar instance relies on GlobalEmitter. needed for garbage collection.\r\n\t\t// unneeded() is called in destroy.\r\n\t\tGlobalEmitter.needed();\r\n\r\n\t\tthis.el = el;\r\n\t\tthis.viewsByType = {};\r\n\t\tthis.viewSpecCache = {};\r\n\r\n\t\tthis.initOptionsInternals(overrides);\r\n\t\tthis.initMomentInternals(); // needs to happen after options hash initialized\r\n\t\tthis.initCurrentDate();\r\n\t\tthis.initEventManager();\r\n\r\n\t\tthis.constructed();\r\n\t},\r\n\r\n\r\n\t// useful for monkeypatching. TODO: BaseClass?\r\n\tconstructed: function() {\r\n\t},\r\n\r\n\r\n\t// Public API\r\n\t// -----------------------------------------------------------------------------------------------------------------\r\n\r\n\r\n\tgetView: function() {\r\n\t\treturn this.view;\r\n\t},\r\n\r\n\r\n\tpubliclyTrigger: function(name, triggerInfo) {\r\n\t\tvar optHandler = this.opt(name);\r\n\t\tvar context;\r\n\t\tvar args;\r\n\r\n\t\tif ($.isPlainObject(triggerInfo)) {\r\n\t\t\tcontext = triggerInfo.context;\r\n\t\t\targs = triggerInfo.args;\r\n\t\t}\r\n\t\telse if ($.isArray(triggerInfo)) {\r\n\t\t\targs = triggerInfo;\r\n\t\t}\r\n\r\n\t\tif (context == null) {\r\n\t\t\tcontext = this.el[0]; // fallback context\r\n\t\t}\r\n\r\n\t\tif (!args) {\r\n\t\t\targs = [];\r\n\t\t}\r\n\r\n\t\tthis.triggerWith(name, context, args); // Emitter's method\r\n\r\n\t\tif (optHandler) {\r\n\t\t\treturn optHandler.apply(context, args);\r\n\t\t}\r\n\t},\r\n\r\n\r\n\thasPublicHandlers: function(name) {\r\n\t\treturn this.hasHandlers(name) ||\r\n\t\t\tthis.opt(name); // handler specified in options\r\n\t},\r\n\r\n\r\n\t// View\r\n\t// -----------------------------------------------------------------------------------------------------------------\r\n\r\n\r\n\t// Given a view name for a custom view or a standard view, creates a ready-to-go View object\r\n\tinstantiateView: function(viewType) {\r\n\t\tvar spec = this.getViewSpec(viewType);\r\n\r\n\t\treturn new spec['class'](this, spec);\r\n\t},\r\n\r\n\r\n\t// Returns a boolean about whether the view is okay to instantiate at some point\r\n\tisValidViewType: function(viewType) {\r\n\t\treturn Boolean(this.getViewSpec(viewType));\r\n\t},\r\n\r\n\r\n\tchangeView: function(viewName, dateOrRange) {\r\n\r\n\t\tif (dateOrRange) {\r\n\r\n\t\t\tif (dateOrRange.start && dateOrRange.end) { // a range\r\n\t\t\t\tthis.recordOptionOverrides({ // will not rerender\r\n\t\t\t\t\tvisibleRange: dateOrRange\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t\telse { // a date\r\n\t\t\t\tthis.currentDate = this.moment(dateOrRange).stripZone(); // just like gotoDate\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis.renderView(viewName);\r\n\t},\r\n\r\n\r\n\t// Forces navigation to a view for the given date.\r\n\t// `viewType` can be a specific view name or a generic one like \"week\" or \"day\".\r\n\tzoomTo: function(newDate, viewType) {\r\n\t\tvar spec;\r\n\r\n\t\tviewType = viewType || 'day'; // day is default zoom\r\n\t\tspec = this.getViewSpec(viewType) || this.getUnitViewSpec(viewType);\r\n\r\n\t\tthis.currentDate = newDate.clone();\r\n\t\tthis.renderView(spec ? spec.type : null);\r\n\t},\r\n\r\n\r\n\t// Current Date\r\n\t// -----------------------------------------------------------------------------------------------------------------\r\n\r\n\r\n\tinitCurrentDate: function() {\r\n\t\tvar defaultDateInput = this.opt('defaultDate');\r\n\r\n\t\t// compute the initial ambig-timezone date\r\n\t\tif (defaultDateInput != null) {\r\n\t\t\tthis.currentDate = this.moment(defaultDateInput).stripZone();\r\n\t\t}\r\n\t\telse {\r\n\t\t\tthis.currentDate = this.getNow(); // getNow already returns unzoned\r\n\t\t}\r\n\t},\r\n\r\n\r\n\tprev: function() {\r\n\t\tvar prevInfo = this.view.buildPrevDateProfile(this.currentDate);\r\n\r\n\t\tif (prevInfo.isValid) {\r\n\t\t\tthis.currentDate = prevInfo.date;\r\n\t\t\tthis.renderView();\r\n\t\t}\r\n\t},\r\n\r\n\r\n\tnext: function() {\r\n\t\tvar nextInfo = this.view.buildNextDateProfile(this.currentDate);\r\n\r\n\t\tif (nextInfo.isValid) {\r\n\t\t\tthis.currentDate = nextInfo.date;\r\n\t\t\tthis.renderView();\r\n\t\t}\r\n\t},\r\n\r\n\r\n\tprevYear: function() {\r\n\t\tthis.currentDate.add(-1, 'years');\r\n\t\tthis.renderView();\r\n\t},\r\n\r\n\r\n\tnextYear: function() {\r\n\t\tthis.currentDate.add(1, 'years');\r\n\t\tthis.renderView();\r\n\t},\r\n\r\n\r\n\ttoday: function() {\r\n\t\tthis.currentDate = this.getNow(); // should deny like prev/next?\r\n\t\tthis.renderView();\r\n\t},\r\n\r\n\r\n\tgotoDate: function(zonedDateInput) {\r\n\t\tthis.currentDate = this.moment(zonedDateInput).stripZone();\r\n\t\tthis.renderView();\r\n\t},\r\n\r\n\r\n\tincrementDate: function(delta) {\r\n\t\tthis.currentDate.add(moment.duration(delta));\r\n\t\tthis.renderView();\r\n\t},\r\n\r\n\r\n\t// for external API\r\n\tgetDate: function() {\r\n\t\treturn this.applyTimezone(this.currentDate); // infuse the calendar's timezone\r\n\t},\r\n\r\n\r\n\t// Loading Triggering\r\n\t// -----------------------------------------------------------------------------------------------------------------\r\n\r\n\r\n\t// Should be called when any type of async data fetching begins\r\n\tpushLoading: function() {\r\n\t\tif (!(this.loadingLevel++)) {\r\n\t\t\tthis.publiclyTrigger('loading', [ true, this.view ]);\r\n\t\t}\r\n\t},\r\n\r\n\r\n\t// Should be called when any type of async data fetching completes\r\n\tpopLoading: function() {\r\n\t\tif (!(--this.loadingLevel)) {\r\n\t\t\tthis.publiclyTrigger('loading', [ false, this.view ]);\r\n\t\t}\r\n\t},\r\n\r\n\r\n\t// Selection\r\n\t// -----------------------------------------------------------------------------------------------------------------\r\n\r\n\r\n\t// this public method receives start/end dates in any format, with any timezone\r\n\tselect: function(zonedStartInput, zonedEndInput) {\r\n\t\tthis.view.select(\r\n\t\t\tthis.buildSelectFootprint.apply(this, arguments)\r\n\t\t);\r\n\t},\r\n\r\n\r\n\tunselect: function() { // safe to be called before renderView\r\n\t\tif (this.view) {\r\n\t\t\tthis.view.unselect();\r\n\t\t}\r\n\t},\r\n\r\n\r\n\t// Given arguments to the select method in the API, returns a span (unzoned start/end and other info)\r\n\tbuildSelectFootprint: function(zonedStartInput, zonedEndInput) {\r\n\t\tvar start = this.moment(zonedStartInput).stripZone();\r\n\t\tvar end;\r\n\r\n\t\tif (zonedEndInput) {\r\n\t\t\tend = this.moment(zonedEndInput).stripZone();\r\n\t\t}\r\n\t\telse if (start.hasTime()) {\r\n\t\t\tend = start.clone().add(this.defaultTimedEventDuration);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tend = start.clone().add(this.defaultAllDayEventDuration);\r\n\t\t}\r\n\r\n\t\treturn new ComponentFootprint(\r\n\t\t\tnew UnzonedRange(start, end),\r\n\t\t\t!start.hasTime()\r\n\t\t);\r\n\t},\r\n\r\n\r\n\t// Misc\r\n\t// -----------------------------------------------------------------------------------------------------------------\r\n\r\n\r\n\t// will return `null` if invalid range\r\n\tparseUnzonedRange: function(rangeInput) {\r\n\t\tvar start = null;\r\n\t\tvar end = null;\r\n\r\n\t\tif (rangeInput.start) {\r\n\t\t\tstart = this.moment(rangeInput.start).stripZone();\r\n\t\t}\r\n\r\n\t\tif (rangeInput.end) {\r\n\t\t\tend = this.moment(rangeInput.end).stripZone();\r\n\t\t}\r\n\r\n\t\tif (!start && !end) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\tif (start && end && end.isBefore(start)) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\treturn new UnzonedRange(start, end);\r\n\t},\r\n\r\n\r\n\trerenderEvents: function() { // API method. destroys old events if previously rendered.\r\n\t\tthis.view.flash('displayingEvents');\r\n\t},\r\n\r\n\r\n\tinitEventManager: function() {\r\n\t\tvar _this = this;\r\n\t\tvar eventManager = new EventManager(this);\r\n\t\tvar rawSources = this.opt('eventSources') || [];\r\n\t\tvar singleRawSource = this.opt('events');\r\n\r\n\t\tthis.eventManager = eventManager;\r\n\r\n\t\tif (singleRawSource) {\r\n\t\t\trawSources.unshift(singleRawSource);\r\n\t\t}\r\n\r\n\t\teventManager.on('release', function(eventsPayload) {\r\n\t\t\t_this.trigger('eventsReset', eventsPayload);\r\n\t\t});\r\n\r\n\t\teventManager.freeze();\r\n\r\n\t\trawSources.forEach(function(rawSource) {\r\n\t\t\tvar source = EventSourceParser.parse(rawSource, _this);\r\n\r\n\t\t\tif (source) {\r\n\t\t\t\teventManager.addSource(source);\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\teventManager.thaw();\r\n\t},\r\n\r\n\r\n\trequestEvents: function(start, end) {\r\n\t\treturn this.eventManager.requestEvents(\r\n\t\t\tstart,\r\n\t\t\tend,\r\n\t\t\tthis.opt('timezone'),\r\n\t\t\t!this.opt('lazyFetching')\r\n\t\t);\r\n\t}\r\n\r\n});\r\n\r\n;;\r\n/*\r\nOptions binding/triggering system.\r\n*/\r\nCalendar.mixin({\r\n\r\n\tdirDefaults: null, // option defaults related to LTR or RTL\r\n\tlocaleDefaults: null, // option defaults related to current locale\r\n\toverrides: null, // option overrides given to the fullCalendar constructor\r\n\tdynamicOverrides: null, // options set with dynamic setter method. higher precedence than view overrides.\r\n\toptionsModel: null, // all defaults combined with overrides\r\n\r\n\r\n\tinitOptionsInternals: function(overrides) {\r\n\t\tthis.overrides = $.extend({}, overrides); // make a copy\r\n\t\tthis.dynamicOverrides = {};\r\n\t\tthis.optionsModel = new Model();\r\n\r\n\t\tthis.populateOptionsHash();\r\n\t},\r\n\r\n\r\n\t// public getter/setter\r\n\toption: function(name, value) {\r\n\t\tvar newOptionHash;\r\n\r\n\t\tif (typeof name === 'string') {\r\n\t\t\tif (value === undefined) { // getter\r\n\t\t\t\treturn this.optionsModel.get(name);\r\n\t\t\t}\r\n\t\t\telse { // setter for individual option\r\n\t\t\t\tnewOptionHash = {};\r\n\t\t\t\tnewOptionHash[name] = value;\r\n\t\t\t\tthis.setOptions(newOptionHash);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if (typeof name === 'object') { // compound setter with object input\r\n\t\t\tthis.setOptions(name);\r\n\t\t}\r\n\t},\r\n\r\n\r\n\t// private getter\r\n\topt: function(name) {\r\n\t\treturn this.optionsModel.get(name);\r\n\t},\r\n\r\n\r\n\tsetOptions: function(newOptionHash) {\r\n\t\tvar optionCnt = 0;\r\n\t\tvar optionName;\r\n\r\n\t\tthis.recordOptionOverrides(newOptionHash); // will trigger optionsModel watchers\r\n\r\n\t\tfor (optionName in newOptionHash) {\r\n\t\t\toptionCnt++;\r\n\t\t}\r\n\r\n\t\t// special-case handling of single option change.\r\n\t\t// if only one option change, `optionName` will be its name.\r\n\t\tif (optionCnt === 1) {\r\n\t\t\tif (optionName === 'height' || optionName === 'contentHeight' || optionName === 'aspectRatio') {\r\n\t\t\t\tthis.updateViewSize(true); // isResize=true\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\telse if (optionName === 'defaultDate') {\r\n\t\t\t\treturn; // can't change date this way. use gotoDate instead\r\n\t\t\t}\r\n\t\t\telse if (optionName === 'businessHours') {\r\n\t\t\t\treturn; // optionsModel already reacts to this\r\n\t\t\t}\r\n\t\t\telse if (optionName === 'timezone') {\r\n\t\t\t\tthis.view.flash('initialEvents');\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// catch-all. rerender the header and footer and rebuild/rerender the current view\r\n\t\tthis.renderHeader();\r\n\t\tthis.renderFooter();\r\n\r\n\t\t// even non-current views will be affected by this option change. do before rerender\r\n\t\t// TODO: detangle\r\n\t\tthis.viewsByType = {};\r\n\r\n\t\tthis.reinitView();\r\n\t},\r\n\r\n\r\n\t// Computes the flattened options hash for the calendar and assigns to `this.options`.\r\n\t// Assumes this.overrides and this.dynamicOverrides have already been initialized.\r\n\tpopulateOptionsHash: function() {\r\n\t\tvar locale, localeDefaults;\r\n\t\tvar isRTL, dirDefaults;\r\n\t\tvar rawOptions;\r\n\r\n\t\tlocale = firstDefined( // explicit locale option given?\r\n\t\t\tthis.dynamicOverrides.locale,\r\n\t\t\tthis.overrides.locale\r\n\t\t);\r\n\t\tlocaleDefaults = localeOptionHash[locale];\r\n\t\tif (!localeDefaults) { // explicit locale option not given or invalid?\r\n\t\t\tlocale = Calendar.defaults.locale;\r\n\t\t\tlocaleDefaults = localeOptionHash[locale] || {};\r\n\t\t}\r\n\r\n\t\tisRTL = firstDefined( // based on options computed so far, is direction RTL?\r\n\t\t\tthis.dynamicOverrides.isRTL,\r\n\t\t\tthis.overrides.isRTL,\r\n\t\t\tlocaleDefaults.isRTL,\r\n\t\t\tCalendar.defaults.isRTL\r\n\t\t);\r\n\t\tdirDefaults = isRTL ? Calendar.rtlDefaults : {};\r\n\r\n\t\tthis.dirDefaults = dirDefaults;\r\n\t\tthis.localeDefaults = localeDefaults;\r\n\r\n\t\trawOptions = mergeOptions([ // merge defaults and overrides. lowest to highest precedence\r\n\t\t\tCalendar.defaults, // global defaults\r\n\t\t\tdirDefaults,\r\n\t\t\tlocaleDefaults,\r\n\t\t\tthis.overrides,\r\n\t\t\tthis.dynamicOverrides\r\n\t\t]);\r\n\t\tpopulateInstanceComputableOptions(rawOptions); // fill in gaps with computed options\r\n\r\n\t\tthis.optionsModel.reset(rawOptions);\r\n\t},\r\n\r\n\r\n\t// stores the new options internally, but does not rerender anything.\r\n\trecordOptionOverrides: function(newOptionHash) {\r\n\t\tvar optionName;\r\n\r\n\t\tfor (optionName in newOptionHash) {\r\n\t\t\tthis.dynamicOverrides[optionName] = newOptionHash[optionName];\r\n\t\t}\r\n\r\n\t\tthis.viewSpecCache = {}; // the dynamic override invalidates the options in this cache, so just clear it\r\n\t\tthis.populateOptionsHash(); // this.options needs to be recomputed after the dynamic override\r\n\t}\r\n\r\n});\r\n\r\n;;\r\n\r\nCalendar.mixin({\r\n\r\n\tdefaultAllDayEventDuration: null,\r\n\tdefaultTimedEventDuration: null,\r\n\tlocaleData: null,\r\n\r\n\r\n\tinitMomentInternals: function() {\r\n\t\tvar _this = this;\r\n\r\n\t\tthis.defaultAllDayEventDuration = moment.duration(this.opt('defaultAllDayEventDuration'));\r\n\t\tthis.defaultTimedEventDuration = moment.duration(this.opt('defaultTimedEventDuration'));\r\n\r\n\t\t// Called immediately, and when any of the options change.\r\n\t\t// Happens before any internal objects rebuild or rerender, because this is very core.\r\n\t\tthis.optionsModel.watch('buildingMomentLocale', [\r\n\t\t\t'?locale', '?monthNames', '?monthNamesShort', '?dayNames', '?dayNamesShort',\r\n\t\t\t'?firstDay', '?weekNumberCalculation'\r\n\t\t], function(opts) {\r\n\t\t\tvar weekNumberCalculation = opts.weekNumberCalculation;\r\n\t\t\tvar firstDay = opts.firstDay;\r\n\t\t\tvar _week;\r\n\r\n\t\t\t// normalize\r\n\t\t\tif (weekNumberCalculation === 'iso') {\r\n\t\t\t\tweekNumberCalculation = 'ISO'; // normalize\r\n\t\t\t}\r\n\r\n\t\t\tvar localeData = Object.create( // make a cheap copy\r\n\t\t\t\tgetMomentLocaleData(opts.locale) // will fall back to en\r\n\t\t\t);\r\n\r\n\t\t\tif (opts.monthNames) {\r\n\t\t\t\tlocaleData._months = opts.monthNames;\r\n\t\t\t}\r\n\t\t\tif (opts.monthNamesShort) {\r\n\t\t\t\tlocaleData._monthsShort = opts.monthNamesShort;\r\n\t\t\t}\r\n\t\t\tif (opts.dayNames) {\r\n\t\t\t\tlocaleData._weekdays = opts.dayNames;\r\n\t\t\t}\r\n\t\t\tif (opts.dayNamesShort) {\r\n\t\t\t\tlocaleData._weekdaysShort = opts.dayNamesShort;\r\n\t\t\t}\r\n\r\n\t\t\tif (firstDay == null && weekNumberCalculation === 'ISO') {\r\n\t\t\t\tfirstDay = 1;\r\n\t\t\t}\r\n\t\t\tif (firstDay != null) {\r\n\t\t\t\t_week = Object.create(localeData._week); // _week: { dow: # }\r\n\t\t\t\t_week.dow = firstDay;\r\n\t\t\t\tlocaleData._week = _week;\r\n\t\t\t}\r\n\r\n\t\t\tif ( // whitelist certain kinds of input\r\n\t\t\t\tweekNumberCalculation === 'ISO' ||\r\n\t\t\t\tweekNumberCalculation === 'local' ||\r\n\t\t\t\ttypeof weekNumberCalculation === 'function'\r\n\t\t\t) {\r\n\t\t\t\tlocaleData._fullCalendar_weekCalc = weekNumberCalculation; // moment-ext will know what to do with it\r\n\t\t\t}\r\n\r\n\t\t\t_this.localeData = localeData;\r\n\r\n\t\t\t// If the internal current date object already exists, move to new locale.\r\n\t\t\t// We do NOT need to do this technique for event dates, because this happens when converting to \"segments\".\r\n\t\t\tif (_this.currentDate) {\r\n\t\t\t\t_this.localizeMoment(_this.currentDate); // sets to localeData\r\n\t\t\t}\r\n\t\t});\r\n\t},\r\n\r\n\r\n\t// Builds a moment using the settings of the current calendar: timezone and locale.\r\n\t// Accepts anything the vanilla moment() constructor accepts.\r\n\tmoment: function() {\r\n\t\tvar mom;\r\n\r\n\t\tif (this.opt('timezone') === 'local') {\r\n\t\t\tmom = FC.moment.apply(null, arguments);\r\n\r\n\t\t\t// Force the moment to be local, because FC.moment doesn't guarantee it.\r\n\t\t\tif (mom.hasTime()) { // don't give ambiguously-timed moments a local zone\r\n\t\t\t\tmom.local();\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if (this.opt('timezone') === 'UTC') {\r\n\t\t\tmom = FC.moment.utc.apply(null, arguments); // process as UTC\r\n\t\t}\r\n\t\telse {\r\n\t\t\tmom = FC.moment.parseZone.apply(null, arguments); // let the input decide the zone\r\n\t\t}\r\n\r\n\t\tthis.localizeMoment(mom); // TODO\r\n\r\n\t\treturn mom;\r\n\t},\r\n\r\n\r\n\tmsToMoment: function(ms, forceAllDay) {\r\n\t\tvar mom = FC.moment.utc(ms); // TODO: optimize by using Date.UTC\r\n\r\n\t\tif (forceAllDay) {\r\n\t\t\tmom.stripTime();\r\n\t\t}\r\n\t\telse {\r\n\t\t\tmom = this.applyTimezone(mom); // may or may not apply locale\r\n\t\t}\r\n\r\n\t\tthis.localizeMoment(mom);\r\n\r\n\t\treturn mom;\r\n\t},\r\n\r\n\r\n\tmsToUtcMoment: function(ms, forceAllDay) {\r\n\t\tvar mom = FC.moment.utc(ms); // TODO: optimize by using Date.UTC\r\n\r\n\t\tif (forceAllDay) {\r\n\t\t\tmom.stripTime();\r\n\t\t}\r\n\r\n\t\tthis.localizeMoment(mom);\r\n\r\n\t\treturn mom;\r\n\t},\r\n\r\n\r\n\t// Updates the given moment's locale settings to the current calendar locale settings.\r\n\tlocalizeMoment: function(mom) {\r\n\t\tmom._locale = this.localeData;\r\n\t},\r\n\r\n\r\n\t// Returns a boolean about whether or not the calendar knows how to calculate\r\n\t// the timezone offset of arbitrary dates in the current timezone.\r\n\tgetIsAmbigTimezone: function() {\r\n\t\treturn this.opt('timezone') !== 'local' && this.opt('timezone') !== 'UTC';\r\n\t},\r\n\r\n\r\n\t// Returns a copy of the given date in the current timezone. Has no effect on dates without times.\r\n\tapplyTimezone: function(date) {\r\n\t\tif (!date.hasTime()) {\r\n\t\t\treturn date.clone();\r\n\t\t}\r\n\r\n\t\tvar zonedDate = this.moment(date.toArray());\r\n\t\tvar timeAdjust = date.time() - zonedDate.time();\r\n\t\tvar adjustedZonedDate;\r\n\r\n\t\t// Safari sometimes has problems with this coersion when near DST. Adjust if necessary. (bug #2396)\r\n\t\tif (timeAdjust) { // is the time result different than expected?\r\n\t\t\tadjustedZonedDate = zonedDate.clone().add(timeAdjust); // add milliseconds\r\n\t\t\tif (date.time() - adjustedZonedDate.time() === 0) { // does it match perfectly now?\r\n\t\t\t\tzonedDate = adjustedZonedDate;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn zonedDate;\r\n\t},\r\n\r\n\r\n\t/*\r\n\tAssumes the footprint is non-open-ended.\r\n\t*/\r\n\tfootprintToDateProfile: function(componentFootprint, ignoreEnd) {\r\n\t\tvar start = FC.moment.utc(componentFootprint.unzonedRange.startMs);\r\n\t\tvar end;\r\n\r\n\t\tif (!ignoreEnd) {\r\n\t\t\tend = FC.moment.utc(componentFootprint.unzonedRange.endMs);\r\n\t\t}\r\n\r\n\t\tif (componentFootprint.isAllDay) {\r\n\t\t\tstart.stripTime();\r\n\r\n\t\t\tif (end) {\r\n\t\t\t\tend.stripTime();\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\tstart = this.applyTimezone(start);\r\n\r\n\t\t\tif (end) {\r\n\t\t\t\tend = this.applyTimezone(end);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn new EventDateProfile(start, end, this);\r\n\t},\r\n\r\n\r\n\t// Returns a moment for the current date, as defined by the client's computer or from the `now` option.\r\n\t// Will return an moment with an ambiguous timezone.\r\n\tgetNow: function() {\r\n\t\tvar now = this.opt('now');\r\n\t\tif (typeof now === 'function') {\r\n\t\t\tnow = now();\r\n\t\t}\r\n\t\treturn this.moment(now).stripZone();\r\n\t},\r\n\r\n\r\n\t// Produces a human-readable string for the given duration.\r\n\t// Side-effect: changes the locale of the given duration.\r\n\thumanizeDuration: function(duration) {\r\n\t\treturn duration.locale(this.opt('locale')).humanize();\r\n\t},\r\n\r\n\r\n\r\n\t// Event-Specific Date Utilities. TODO: move\r\n\t// -----------------------------------------------------------------------------------------------------------------\r\n\r\n\r\n\t// Get an event's normalized end date. If not present, calculate it from the defaults.\r\n\tgetEventEnd: function(event) {\r\n\t\tif (event.end) {\r\n\t\t\treturn event.end.clone();\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn this.getDefaultEventEnd(event.allDay, event.start);\r\n\t\t}\r\n\t},\r\n\r\n\r\n\t// Given an event's allDay status and start date, return what its fallback end date should be.\r\n\t// TODO: rename to computeDefaultEventEnd\r\n\tgetDefaultEventEnd: function(allDay, zonedStart) {\r\n\t\tvar end = zonedStart.clone();\r\n\r\n\t\tif (allDay) {\r\n\t\t\tend.stripTime().add(this.defaultAllDayEventDuration);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tend.add(this.defaultTimedEventDuration);\r\n\t\t}\r\n\r\n\t\tif (this.getIsAmbigTimezone()) {\r\n\t\t\tend.stripZone(); // we don't know what the tzo should be\r\n\t\t}\r\n\r\n\t\treturn end;\r\n\t}\r\n\r\n});\r\n\r\n;;\r\n\r\nCalendar.mixin({\r\n\r\n\tviewSpecCache: null, // cache of view definitions (initialized in Calendar.js)\r\n\r\n\r\n\t// Gets information about how to create a view. Will use a cache.\r\n\tgetViewSpec: function(viewType) {\r\n\t\tvar cache = this.viewSpecCache;\r\n\r\n\t\treturn cache[viewType] || (cache[viewType] = this.buildViewSpec(viewType));\r\n\t},\r\n\r\n\r\n\t// Given a duration singular unit, like \"week\" or \"day\", finds a matching view spec.\r\n\t// Preference is given to views that have corresponding buttons.\r\n\tgetUnitViewSpec: function(unit) {\r\n\t\tvar viewTypes;\r\n\t\tvar i;\r\n\t\tvar spec;\r\n\r\n\t\tif ($.inArray(unit, unitsDesc) != -1) {\r\n\r\n\t\t\t// put views that have buttons first. there will be duplicates, but oh well\r\n\t\t\tviewTypes = this.header.getViewsWithButtons(); // TODO: include footer as well?\r\n\t\t\t$.each(FC.views, function(viewType) { // all views\r\n\t\t\t\tviewTypes.push(viewType);\r\n\t\t\t});\r\n\r\n\t\t\tfor (i = 0; i < viewTypes.length; i++) {\r\n\t\t\t\tspec = this.getViewSpec(viewTypes[i]);\r\n\t\t\t\tif (spec) {\r\n\t\t\t\t\tif (spec.singleUnit == unit) {\r\n\t\t\t\t\t\treturn spec;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\r\n\t// Builds an object with information on how to create a given view\r\n\tbuildViewSpec: function(requestedViewType) {\r\n\t\tvar viewOverrides = this.overrides.views || {};\r\n\t\tvar specChain = []; // for the view. lowest to highest priority\r\n\t\tvar defaultsChain = []; // for the view. lowest to highest priority\r\n\t\tvar overridesChain = []; // for the view. lowest to highest priority\r\n\t\tvar viewType = requestedViewType;\r\n\t\tvar spec; // for the view\r\n\t\tvar overrides; // for the view\r\n\t\tvar durationInput;\r\n\t\tvar duration;\r\n\t\tvar unit;\r\n\r\n\t\t// iterate from the specific view definition to a more general one until we hit an actual View class\r\n\t\twhile (viewType) {\r\n\t\t\tspec = fcViews[viewType];\r\n\t\t\toverrides = viewOverrides[viewType];\r\n\t\t\tviewType = null; // clear. might repopulate for another iteration\r\n\r\n\t\t\tif (typeof spec === 'function') { // TODO: deprecate\r\n\t\t\t\tspec = { 'class': spec };\r\n\t\t\t}\r\n\r\n\t\t\tif (spec) {\r\n\t\t\t\tspecChain.unshift(spec);\r\n\t\t\t\tdefaultsChain.unshift(spec.defaults || {});\r\n\t\t\t\tdurationInput = durationInput || spec.duration;\r\n\t\t\t\tviewType = viewType || spec.type;\r\n\t\t\t}\r\n\r\n\t\t\tif (overrides) {\r\n\t\t\t\toverridesChain.unshift(overrides); // view-specific option hashes have options at zero-level\r\n\t\t\t\tdurationInput = durationInput || overrides.duration;\r\n\t\t\t\tviewType = viewType || overrides.type;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tspec = mergeProps(specChain);\r\n\t\tspec.type = requestedViewType;\r\n\t\tif (!spec['class']) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\t// fall back to top-level `duration` option\r\n\t\tdurationInput = durationInput ||\r\n\t\t\tthis.dynamicOverrides.duration ||\r\n\t\t\tthis.overrides.duration;\r\n\r\n\t\tif (durationInput) {\r\n\t\t\tduration = moment.duration(durationInput);\r\n\r\n\t\t\tif (duration.valueOf()) { // valid?\r\n\r\n\t\t\t\tunit = computeDurationGreatestUnit(duration, durationInput);\r\n\r\n\t\t\t\tspec.duration = duration;\r\n\t\t\t\tspec.durationUnit = unit;\r\n\r\n\t\t\t\t// view is a single-unit duration, like \"week\" or \"day\"\r\n\t\t\t\t// incorporate options for this. lowest priority\r\n\t\t\t\tif (duration.as(unit) === 1) {\r\n\t\t\t\t\tspec.singleUnit = unit;\r\n\t\t\t\t\toverridesChain.unshift(viewOverrides[unit] || {});\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tspec.defaults = mergeOptions(defaultsChain);\r\n\t\tspec.overrides = mergeOptions(overridesChain);\r\n\r\n\t\tthis.buildViewSpecOptions(spec);\r\n\t\tthis.buildViewSpecButtonText(spec, requestedViewType);\r\n\r\n\t\treturn spec;\r\n\t},\r\n\r\n\r\n\t// Builds and assigns a view spec's options object from its already-assigned defaults and overrides\r\n\tbuildViewSpecOptions: function(spec) {\r\n\t\tspec.options = mergeOptions([ // lowest to highest priority\r\n\t\t\tCalendar.defaults, // global defaults\r\n\t\t\tspec.defaults, // view's defaults (from ViewSubclass.defaults)\r\n\t\t\tthis.dirDefaults,\r\n\t\t\tthis.localeDefaults, // locale and dir take precedence over view's defaults!\r\n\t\t\tthis.overrides, // calendar's overrides (options given to constructor)\r\n\t\t\tspec.overrides, // view's overrides (view-specific options)\r\n\t\t\tthis.dynamicOverrides // dynamically set via setter. highest precedence\r\n\t\t]);\r\n\t\tpopulateInstanceComputableOptions(spec.options);\r\n\t},\r\n\r\n\r\n\t// Computes and assigns a view spec's buttonText-related options\r\n\tbuildViewSpecButtonText: function(spec, requestedViewType) {\r\n\r\n\t\t// given an options object with a possible `buttonText` hash, lookup the buttonText for the\r\n\t\t// requested view, falling back to a generic unit entry like \"week\" or \"day\"\r\n\t\tfunction queryButtonText(options) {\r\n\t\t\tvar buttonText = options.buttonText || {};\r\n\t\t\treturn buttonText[requestedViewType] ||\r\n\t\t\t\t// view can decide to look up a certain key\r\n\t\t\t\t(spec.buttonTextKey ? buttonText[spec.buttonTextKey] : null) ||\r\n\t\t\t\t// a key like \"month\"\r\n\t\t\t\t(spec.singleUnit ? buttonText[spec.singleUnit] : null);\r\n\t\t}\r\n\r\n\t\t// highest to lowest priority\r\n\t\tspec.buttonTextOverride =\r\n\t\t\tqueryButtonText(this.dynamicOverrides) ||\r\n\t\t\tqueryButtonText(this.overrides) || // constructor-specified buttonText lookup hash takes precedence\r\n\t\t\tspec.overrides.buttonText; // `buttonText` for view-specific options is a string\r\n\r\n\t\t// highest to lowest priority. mirrors buildViewSpecOptions\r\n\t\tspec.buttonTextDefault =\r\n\t\t\tqueryButtonText(this.localeDefaults) ||\r\n\t\t\tqueryButtonText(this.dirDefaults) ||\r\n\t\t\tspec.defaults.buttonText || // a single string. from ViewSubclass.defaults\r\n\t\t\tqueryButtonText(Calendar.defaults) ||\r\n\t\t\t(spec.duration ? this.humanizeDuration(spec.duration) : null) || // like \"3 days\"\r\n\t\t\trequestedViewType; // fall back to given view name\r\n\t}\r\n\r\n});\r\n\r\n;;\r\n\r\nCalendar.mixin({\r\n\r\n\tel: null,\r\n\tcontentEl: null,\r\n\tsuggestedViewHeight: null,\r\n\tignoreUpdateViewSize: 0,\r\n\tfreezeContentHeightDepth: 0,\r\n\twindowResizeProxy: null,\r\n\r\n\r\n\trender: function() {\r\n\t\tif (!this.contentEl) {\r\n\t\t\tthis.initialRender();\r\n\t\t}\r\n\t\telse if (this.elementVisible()) {\r\n\t\t\t// mainly for the public API\r\n\t\t\tthis.calcSize();\r\n\t\t\tthis.renderView();\r\n\t\t}\r\n\t},\r\n\r\n\r\n\tinitialRender: function() {\r\n\t\tvar _this = this;\r\n\t\tvar el = this.el;\r\n\r\n\t\tel.addClass('fc');\r\n\r\n\t\t// event delegation for nav links\r\n\t\tel.on('click.fc', 'a[data-goto]', function(ev) {\r\n\t\t\tvar anchorEl = $(this);\r\n\t\t\tvar gotoOptions = anchorEl.data('goto'); // will automatically parse JSON\r\n\t\t\tvar date = _this.moment(gotoOptions.date);\r\n\t\t\tvar viewType = gotoOptions.type;\r\n\r\n\t\t\t// property like \"navLinkDayClick\". might be a string or a function\r\n\t\t\tvar customAction = _this.view.opt('navLink' + capitaliseFirstLetter(viewType) + 'Click');\r\n\r\n\t\t\tif (typeof customAction === 'function') {\r\n\t\t\t\tcustomAction(date, ev);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tif (typeof customAction === 'string') {\r\n\t\t\t\t\tviewType = customAction;\r\n\t\t\t\t}\r\n\t\t\t\t_this.zoomTo(date, viewType);\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\t// called immediately, and upon option change\r\n\t\tthis.optionsModel.watch('settingTheme', [ '?theme', '?themeSystem' ], function(opts) {\r\n\t\t\tvar themeClass = ThemeRegistry.getThemeClass(opts.themeSystem || opts.theme);\r\n\t\t\tvar theme = new themeClass(_this.optionsModel);\r\n\t\t\tvar widgetClass = theme.getClass('widget');\r\n\r\n\t\t\t_this.theme = theme;\r\n\r\n\t\t\tif (widgetClass) {\r\n\t\t\t\tel.addClass(widgetClass);\r\n\t\t\t}\r\n\t\t}, function() {\r\n\t\t\tvar widgetClass = _this.theme.getClass('widget');\r\n\r\n\t\t\t_this.theme = null;\r\n\r\n\t\t\tif (widgetClass) {\r\n\t\t\t\tel.removeClass(widgetClass);\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tthis.optionsModel.watch('settingBusinessHourGenerator', [ '?businessHours' ], function(deps) {\r\n\t\t\t_this.businessHourGenerator = new BusinessHourGenerator(deps.businessHours, _this);\r\n\r\n\t\t\tif (_this.view) {\r\n\t\t\t\t_this.view.set('businessHourGenerator', _this.businessHourGenerator);\r\n\t\t\t}\r\n\t\t}, function() {\r\n\t\t\t_this.businessHourGenerator = null;\r\n\t\t});\r\n\r\n\t\t// called immediately, and upon option change.\r\n\t\t// HACK: locale often affects isRTL, so we explicitly listen to that too.\r\n\t\tthis.optionsModel.watch('applyingDirClasses', [ '?isRTL', '?locale' ], function(opts) {\r\n\t\t\tel.toggleClass('fc-ltr', !opts.isRTL);\r\n\t\t\tel.toggleClass('fc-rtl', opts.isRTL);\r\n\t\t});\r\n\r\n\t\tthis.contentEl = $(\"<div class='fc-view-container'/>\").prependTo(el);\r\n\r\n\t\tthis.initToolbars();\r\n\t\tthis.renderHeader();\r\n\t\tthis.renderFooter();\r\n\t\tthis.renderView(this.opt('defaultView'));\r\n\r\n\t\tif (this.opt('handleWindowResize')) {\r\n\t\t\t$(window).resize(\r\n\t\t\t\tthis.windowResizeProxy = debounce( // prevents rapid calls\r\n\t\t\t\t\tthis.windowResize.bind(this),\r\n\t\t\t\t\tthis.opt('windowResizeDelay')\r\n\t\t\t\t)\r\n\t\t\t);\r\n\t\t}\r\n\t},\r\n\r\n\r\n\tdestroy: function() {\r\n\t\tif (this.view) {\r\n\t\t\tthis.clearView();\r\n\t\t}\r\n\r\n\t\tthis.toolbarsManager.proxyCall('removeElement');\r\n\t\tthis.contentEl.remove();\r\n\t\tthis.el.removeClass('fc fc-ltr fc-rtl');\r\n\r\n\t\t// removes theme-related root className\r\n\t\tthis.optionsModel.unwatch('settingTheme');\r\n\t\tthis.optionsModel.unwatch('settingBusinessHourGenerator');\r\n\r\n\t\tthis.el.off('.fc'); // unbind nav link handlers\r\n\r\n\t\tif (this.windowResizeProxy) {\r\n\t\t\t$(window).unbind('resize', this.windowResizeProxy);\r\n\t\t\tthis.windowResizeProxy = null;\r\n\t\t}\r\n\r\n\t\tGlobalEmitter.unneeded();\r\n\t},\r\n\r\n\r\n\telementVisible: function() {\r\n\t\treturn this.el.is(':visible');\r\n\t},\r\n\r\n\r\n\t// Render Queue\r\n\t// -----------------------------------------------------------------------------------------------------------------\r\n\r\n\r\n\tbindViewHandlers: function(view) {\r\n\t\tvar _this = this;\r\n\r\n\t\tview.watch('titleForCalendar', [ 'title' ], function(deps) { // TODO: better system\r\n\t\t\tif (view === _this.view) { // hack\r\n\t\t\t\t_this.setToolbarsTitle(deps.title);\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tview.watch('dateProfileForCalendar', [ 'dateProfile' ], function(deps) {\r\n\t\t\tif (view === _this.view) { // hack\r\n\t\t\t\t_this.currentDate = deps.dateProfile.date; // might have been constrained by view dates\r\n\t\t\t\t_this.updateToolbarButtons(deps.dateProfile);\r\n\t\t\t}\r\n\t\t});\r\n\t},\r\n\r\n\r\n\tunbindViewHandlers: function(view) {\r\n\t\tthis.stopListeningTo(view);\r\n\r\n\t\tview.unwatch('titleForCalendar');\r\n\t\tview.unwatch('dateProfileForCalendar');\r\n\t},\r\n\r\n\r\n\t// View Rendering\r\n\t// -----------------------------------------------------------------------------------\r\n\r\n\r\n\t// Renders a view because of a date change, view-type change, or for the first time.\r\n\t// If not given a viewType, keep the current view but render different dates.\r\n\t// Accepts an optional scroll state to restore to.\r\n\trenderView: function(viewType) {\r\n\t\tvar oldView = this.view;\r\n\t\tvar newView;\r\n\r\n\t\tthis.freezeContentHeight();\r\n\r\n\t\tif (oldView && viewType && oldView.type !== viewType) {\r\n\t\t\tthis.clearView();\r\n\t\t}\r\n\r\n\t\t// if viewType changed, or the view was never created, create a fresh view\r\n\t\tif (!this.view && viewType) {\r\n\t\t\tnewView = this.view =\r\n\t\t\t\tthis.viewsByType[viewType] ||\r\n\t\t\t\t(this.viewsByType[viewType] = this.instantiateView(viewType));\r\n\r\n\t\t\tthis.bindViewHandlers(newView);\r\n\r\n\t\t\tnewView.setElement(\r\n\t\t\t\t$(\"<div class='fc-view fc-\" + viewType + \"-view' />\").appendTo(this.contentEl)\r\n\t\t\t);\r\n\r\n\t\t\tthis.toolbarsManager.proxyCall('activateButton', viewType);\r\n\t\t}\r\n\r\n\t\tif (this.view) {\r\n\r\n\t\t\t// prevent unnecessary change firing\r\n\t\t\tif (this.view.get('businessHourGenerator') !== this.businessHourGenerator) {\r\n\t\t\t\tthis.view.set('businessHourGenerator', this.businessHourGenerator);\r\n\t\t\t}\r\n\r\n\t\t\tthis.view.setDate(this.currentDate);\r\n\t\t}\r\n\r\n\t\tthis.thawContentHeight();\r\n\t},\r\n\r\n\r\n\t// Unrenders the current view and reflects this change in the Header.\r\n\t// Unregsiters the `view`, but does not remove from viewByType hash.\r\n\tclearView: function() {\r\n\t\tvar currentView = this.view;\r\n\r\n\t\tthis.toolbarsManager.proxyCall('deactivateButton', currentView.type);\r\n\r\n\t\tthis.unbindViewHandlers(currentView);\r\n\r\n\t\tcurrentView.removeElement();\r\n\r\n\t\tthis.view = null;\r\n\t},\r\n\r\n\r\n\t// Destroys the view, including the view object. Then, re-instantiates it and renders it.\r\n\t// Maintains the same scroll state.\r\n\t// TODO: maintain any other user-manipulated state.\r\n\treinitView: function() {\r\n\t\tvar oldView = this.view;\r\n\t\tvar scroll = oldView.queryScroll(); // wouldn't be so complicated if Calendar owned the scroll\r\n\t\tthis.freezeContentHeight();\r\n\r\n\t\tthis.clearView();\r\n\t\tthis.calcSize();\r\n\t\tthis.renderView(oldView.type); // needs the type to freshly render\r\n\r\n\t\tthis.view.applyScroll(scroll);\r\n\t\tthis.thawContentHeight();\r\n\t},\r\n\r\n\r\n\t// Resizing\r\n\t// -----------------------------------------------------------------------------------\r\n\r\n\r\n\tgetSuggestedViewHeight: function() {\r\n\t\tif (this.suggestedViewHeight === null) {\r\n\t\t\tthis.calcSize();\r\n\t\t}\r\n\t\treturn this.suggestedViewHeight;\r\n\t},\r\n\r\n\r\n\tisHeightAuto: function() {\r\n\t\treturn this.opt('contentHeight') === 'auto' || this.opt('height') === 'auto';\r\n\t},\r\n\r\n\r\n\tupdateViewSize: function(isResize) {\r\n\t\tvar view = this.view;\r\n\t\tvar scroll;\r\n\r\n\t\tif (!this.ignoreUpdateViewSize && view) {\r\n\r\n\t\t\tif (isResize) {\r\n\t\t\t\tthis.calcSize();\r\n\t\t\t\tscroll = view.queryScroll();\r\n\t\t\t}\r\n\r\n\t\t\tthis.ignoreUpdateViewSize++;\r\n\r\n\t\t\tview.updateSize(\r\n\t\t\t\tthis.getSuggestedViewHeight(),\r\n\t\t\t\tthis.isHeightAuto(),\r\n\t\t\t\tisResize\r\n\t\t\t);\r\n\r\n\t\t\tthis.ignoreUpdateViewSize--;\r\n\r\n\t\t\tif (isResize) {\r\n\t\t\t\tview.applyScroll(scroll);\r\n\t\t\t}\r\n\r\n\t\t\treturn true; // signal success\r\n\t\t}\r\n\t},\r\n\r\n\r\n\tcalcSize: function() {\r\n\t\tif (this.elementVisible()) {\r\n\t\t\tthis._calcSize();\r\n\t\t}\r\n\t},\r\n\r\n\r\n\t_calcSize: function() { // assumes elementVisible\r\n\t\tvar contentHeightInput = this.opt('contentHeight');\r\n\t\tvar heightInput = this.opt('height');\r\n\r\n\t\tif (typeof contentHeightInput === 'number') { // exists and not 'auto'\r\n\t\t\tthis.suggestedViewHeight = contentHeightInput;\r\n\t\t}\r\n\t\telse if (typeof contentHeightInput === 'function') { // exists and is a function\r\n\t\t\tthis.suggestedViewHeight = contentHeightInput();\r\n\t\t}\r\n\t\telse if (typeof heightInput === 'number') { // exists and not 'auto'\r\n\t\t\tthis.suggestedViewHeight = heightInput - this.queryToolbarsHeight();\r\n\t\t}\r\n\t\telse if (typeof heightInput === 'function') { // exists and is a function\r\n\t\t\tthis.suggestedViewHeight = heightInput() - this.queryToolbarsHeight();\r\n\t\t}\r\n\t\telse if (heightInput === 'parent') { // set to height of parent element\r\n\t\t\tthis.suggestedViewHeight = this.el.parent().height() - this.queryToolbarsHeight();\r\n\t\t}\r\n\t\telse {\r\n\t\t\tthis.suggestedViewHeight = Math.round(\r\n\t\t\t\tthis.contentEl.width() /\r\n\t\t\t\tMath.max(this.opt('aspectRatio'), .5)\r\n\t\t\t);\r\n\t\t}\r\n\t},\r\n\r\n\r\n\twindowResize: function(ev) {\r\n\t\tif (\r\n\t\t\tev.target === window && // so we don't process jqui \"resize\" events that have bubbled up\r\n\t\t\tthis.view &&\r\n\t\t\tthis.view.isDatesRendered\r\n\t\t) {\r\n\t\t\tif (this.updateViewSize(true)) { // isResize=true, returns true on success\r\n\t\t\t\tthis.publiclyTrigger('windowResize', [ this.view ]);\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\r\n\t/* Height \"Freezing\"\r\n\t-----------------------------------------------------------------------------*/\r\n\r\n\r\n\tfreezeContentHeight: function() {\r\n\t\tif (!(this.freezeContentHeightDepth++)) {\r\n\t\t\tthis.forceFreezeContentHeight();\r\n\t\t}\r\n\t},\r\n\r\n\r\n\tforceFreezeContentHeight: function() {\r\n\t\tthis.contentEl.css({\r\n\t\t\twidth: '100%',\r\n\t\t\theight: this.contentEl.height(),\r\n\t\t\toverflow: 'hidden'\r\n\t\t});\r\n\t},\r\n\r\n\r\n\tthawContentHeight: function() {\r\n\t\tthis.freezeContentHeightDepth--;\r\n\r\n\t\t// always bring back to natural height\r\n\t\tthis.contentEl.css({\r\n\t\t\twidth: '',\r\n\t\t\theight: '',\r\n\t\t\toverflow: ''\r\n\t\t});\r\n\r\n\t\t// but if there are future thaws, re-freeze\r\n\t\tif (this.freezeContentHeightDepth) {\r\n\t\t\tthis.forceFreezeContentHeight();\r\n\t\t}\r\n\t}\r\n\r\n});\r\n\r\n;;\r\n\r\nCalendar.mixin({\r\n\r\n\theader: null,\r\n\tfooter: null,\r\n\ttoolbarsManager: null,\r\n\r\n\r\n\tinitToolbars: function() {\r\n\t\tthis.header = new Toolbar(this, this.computeHeaderOptions());\r\n\t\tthis.footer = new Toolbar(this, this.computeFooterOptions());\r\n\t\tthis.toolbarsManager = new Iterator([ this.header, this.footer ]);\r\n\t},\r\n\r\n\r\n\tcomputeHeaderOptions: function() {\r\n\t\treturn {\r\n\t\t\textraClasses: 'fc-header-toolbar',\r\n\t\t\tlayout: this.opt('header')\r\n\t\t};\r\n\t},\r\n\r\n\r\n\tcomputeFooterOptions: function() {\r\n\t\treturn {\r\n\t\t\textraClasses: 'fc-footer-toolbar',\r\n\t\t\tlayout: this.opt('footer')\r\n\t\t};\r\n\t},\r\n\r\n\r\n\t// can be called repeatedly and Header will rerender\r\n\trenderHeader: function() {\r\n\t\tvar header = this.header;\r\n\r\n\t\theader.setToolbarOptions(this.computeHeaderOptions());\r\n\t\theader.render();\r\n\r\n\t\tif (header.el) {\r\n\t\t\tthis.el.prepend(header.el);\r\n\t\t}\r\n\t},\r\n\r\n\r\n\t// can be called repeatedly and Footer will rerender\r\n\trenderFooter: function() {\r\n\t\tvar footer = this.footer;\r\n\r\n\t\tfooter.setToolbarOptions(this.computeFooterOptions());\r\n\t\tfooter.render();\r\n\r\n\t\tif (footer.el) {\r\n\t\t\tthis.el.append(footer.el);\r\n\t\t}\r\n\t},\r\n\r\n\r\n\tsetToolbarsTitle: function(title) {\r\n\t\tthis.toolbarsManager.proxyCall('updateTitle', title);\r\n\t},\r\n\r\n\r\n\tupdateToolbarButtons: function(dateProfile) {\r\n\t\tvar now = this.getNow();\r\n\t\tvar view = this.view;\r\n\t\tvar todayInfo = view.buildDateProfile(now);\r\n\t\tvar prevInfo = view.buildPrevDateProfile(this.currentDate);\r\n\t\tvar nextInfo = view.buildNextDateProfile(this.currentDate);\r\n\r\n\t\tthis.toolbarsManager.proxyCall(\r\n\t\t\t(todayInfo.isValid && !dateProfile.currentUnzonedRange.containsDate(now)) ?\r\n\t\t\t\t'enableButton' :\r\n\t\t\t\t'disableButton',\r\n\t\t\t'today'\r\n\t\t);\r\n\r\n\t\tthis.toolbarsManager.proxyCall(\r\n\t\t\tprevInfo.isValid ?\r\n\t\t\t\t'enableButton' :\r\n\t\t\t\t'disableButton',\r\n\t\t\t'prev'\r\n\t\t);\r\n\r\n\t\tthis.toolbarsManager.proxyCall(\r\n\t\t\tnextInfo.isValid ?\r\n\t\t\t\t'enableButton' :\r\n\t\t\t\t'disableButton',\r\n\t\t\t'next'\r\n\t\t);\r\n\t},\r\n\r\n\r\n\tqueryToolbarsHeight: function() {\r\n\t\treturn this.toolbarsManager.items.reduce(function(accumulator, toolbar) {\r\n\t\t\tvar toolbarHeight = toolbar.el ? toolbar.el.outerHeight(true) : 0; // includes margin\r\n\t\t\treturn accumulator + toolbarHeight;\r\n\t\t}, 0);\r\n\t}\r\n\r\n});\r\n\r\n;;\r\n\r\n/*\r\ndetermines if eventInstanceGroup is allowed,\r\nin relation to other EVENTS and business hours.\r\n*/\r\nCalendar.prototype.isEventInstanceGroupAllowed = function(eventInstanceGroup) {\r\n\tvar eventDef = eventInstanceGroup.getEventDef();\r\n\tvar eventFootprints = this.eventRangesToEventFootprints(eventInstanceGroup.getAllEventRanges());\r\n\tvar i;\r\n\r\n\tvar peerEventInstances = this.getPeerEventInstances(eventDef);\r\n\tvar peerEventRanges = peerEventInstances.map(eventInstanceToEventRange);\r\n\tvar peerEventFootprints = this.eventRangesToEventFootprints(peerEventRanges);\r\n\r\n\tvar constraintVal = eventDef.getConstraint();\r\n\tvar overlapVal = eventDef.getOverlap();\r\n\r\n\tvar eventAllowFunc = this.opt('eventAllow');\r\n\r\n\tfor (i = 0; i < eventFootprints.length; i++) {\r\n\t\tif (\r\n\t\t\t!this.isFootprintAllowed(\r\n\t\t\t\teventFootprints[i].componentFootprint,\r\n\t\t\t\tpeerEventFootprints,\r\n\t\t\t\tconstraintVal,\r\n\t\t\t\toverlapVal,\r\n\t\t\t\teventFootprints[i].eventInstance\r\n\t\t\t)\r\n\t\t) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\r\n\tif (eventAllowFunc) {\r\n\t\tfor (i = 0; i < eventFootprints.length; i++) {\r\n\t\t\tif (\r\n\t\t\t\teventAllowFunc(\r\n\t\t\t\t\teventFootprints[i].componentFootprint.toLegacy(this),\r\n\t\t\t\t\teventFootprints[i].getEventLegacy()\r\n\t\t\t\t) === false\r\n\t\t\t) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn true;\r\n};\r\n\r\n\r\nCalendar.prototype.getPeerEventInstances = function(eventDef) {\r\n\treturn this.eventManager.getEventInstancesWithoutId(eventDef.id);\r\n};\r\n\r\n\r\nCalendar.prototype.isSelectionFootprintAllowed = function(componentFootprint) {\r\n\tvar peerEventInstances = this.eventManager.getEventInstances();\r\n\tvar peerEventRanges = peerEventInstances.map(eventInstanceToEventRange);\r\n\tvar peerEventFootprints = this.eventRangesToEventFootprints(peerEventRanges);\r\n\r\n\tvar selectAllowFunc;\r\n\r\n\tif (\r\n\t\tthis.isFootprintAllowed(\r\n\t\t\tcomponentFootprint,\r\n\t\t\tpeerEventFootprints,\r\n\t\t\tthis.opt('selectConstraint'),\r\n\t\t\tthis.opt('selectOverlap')\r\n\t\t)\r\n\t) {\r\n\t\tselectAllowFunc = this.opt('selectAllow');\r\n\r\n\t\tif (selectAllowFunc) {\r\n\t\t\treturn selectAllowFunc(componentFootprint.toLegacy(this)) !== false;\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn true;\r\n\t\t}\r\n\t}\r\n\r\n\treturn false;\r\n};\r\n\r\n\r\nCalendar.prototype.isFootprintAllowed = function(\r\n\tcomponentFootprint,\r\n\tpeerEventFootprints,\r\n\tconstraintVal,\r\n\toverlapVal,\r\n\tsubjectEventInstance // optional\r\n) {\r\n\tvar constraintFootprints; // ComponentFootprint[]\r\n\tvar overlapEventFootprints; // EventFootprint[]\r\n\r\n\tif (constraintVal != null) {\r\n\t\tconstraintFootprints = this.constraintValToFootprints(constraintVal, componentFootprint.isAllDay);\r\n\r\n\t\tif (!this.isFootprintWithinConstraints(componentFootprint, constraintFootprints)) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\r\n\toverlapEventFootprints = this.collectOverlapEventFootprints(peerEventFootprints, componentFootprint);\r\n\r\n\tif (overlapVal === false) {\r\n\t\tif (overlapEventFootprints.length) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\telse if (typeof overlapVal === 'function') {\r\n\t\tif (!isOverlapsAllowedByFunc(overlapEventFootprints, overlapVal, subjectEventInstance)) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\r\n\tif (subjectEventInstance) {\r\n\t\tif (!isOverlapEventInstancesAllowed(overlapEventFootprints, subjectEventInstance)) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\r\n\treturn true;\r\n};\r\n\r\n\r\n// Constraint\r\n// ------------------------------------------------------------------------------------------------\r\n\r\n\r\nCalendar.prototype.isFootprintWithinConstraints = function(componentFootprint, constraintFootprints) {\r\n\tvar i;\r\n\r\n\tfor (i = 0; i < constraintFootprints.length; i++) {\r\n\t\tif (this.footprintContainsFootprint(constraintFootprints[i], componentFootprint)) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\t}\r\n\r\n\treturn false;\r\n};\r\n\r\n\r\nCalendar.prototype.constraintValToFootprints = function(constraintVal, isAllDay) {\r\n\tvar eventInstances;\r\n\r\n\tif (constraintVal === 'businessHours') {\r\n\t\treturn this.buildCurrentBusinessFootprints(isAllDay);\r\n\t}\r\n\telse if (typeof constraintVal === 'object') {\r\n\t\teventInstances = this.parseEventDefToInstances(constraintVal); // handles recurring events\r\n\r\n\t\tif (!eventInstances) { // invalid input. fallback to parsing footprint directly\r\n\t\t\treturn this.parseFootprints(constraintVal);\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn this.eventInstancesToFootprints(eventInstances);\r\n\t\t}\r\n\t}\r\n\telse if (constraintVal != null) { // an ID\r\n\t\teventInstances = this.eventManager.getEventInstancesWithId(constraintVal);\r\n\r\n\t\treturn this.eventInstancesToFootprints(eventInstances);\r\n\t}\r\n};\r\n\r\n\r\n// returns ComponentFootprint[]\r\n// uses current view's range\r\nCalendar.prototype.buildCurrentBusinessFootprints = function(isAllDay) {\r\n\tvar view = this.view;\r\n\tvar businessHourGenerator = view.get('businessHourGenerator');\r\n\tvar unzonedRange = view.dateProfile.activeUnzonedRange;\r\n\tvar eventInstanceGroup = businessHourGenerator.buildEventInstanceGroup(isAllDay, unzonedRange);\r\n\r\n\tif (eventInstanceGroup) {\r\n\t\treturn this.eventInstancesToFootprints(eventInstanceGroup.eventInstances);\r\n\t}\r\n\telse {\r\n\t\treturn [];\r\n\t}\r\n};\r\n\r\n\r\n// conversion util\r\nCalendar.prototype.eventInstancesToFootprints = function(eventInstances) {\r\n\tvar eventRanges = eventInstances.map(eventInstanceToEventRange);\r\n\tvar eventFootprints = this.eventRangesToEventFootprints(eventRanges);\r\n\r\n\treturn eventFootprints.map(eventFootprintToComponentFootprint);\r\n};\r\n\r\n\r\n// Overlap\r\n// ------------------------------------------------------------------------------------------------\r\n\r\n\r\nCalendar.prototype.collectOverlapEventFootprints = function(peerEventFootprints, targetFootprint) {\r\n\tvar overlapEventFootprints = [];\r\n\tvar i;\r\n\r\n\tfor (i = 0; i < peerEventFootprints.length; i++) {\r\n\t\tif (\r\n\t\t\tthis.footprintsIntersect(\r\n\t\t\t\ttargetFootprint,\r\n\t\t\t\tpeerEventFootprints[i].componentFootprint\r\n\t\t\t)\r\n\t\t) {\r\n\t\t\toverlapEventFootprints.push(peerEventFootprints[i]);\r\n\t\t}\r\n\t}\r\n\r\n\treturn overlapEventFootprints;\r\n};\r\n\r\n\r\n// optional subjectEventInstance\r\nfunction isOverlapsAllowedByFunc(overlapEventFootprints, overlapFunc, subjectEventInstance) {\r\n\tvar i;\r\n\r\n\tfor (i = 0; i < overlapEventFootprints.length; i++) {\r\n\t\tif (\r\n\t\t\t!overlapFunc(\r\n\t\t\t\toverlapEventFootprints[i].eventInstance.toLegacy(),\r\n\t\t\t\tsubjectEventInstance ? subjectEventInstance.toLegacy() : null\r\n\t\t\t)\r\n\t\t) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\r\n\treturn true;\r\n}\r\n\r\n\r\nfunction isOverlapEventInstancesAllowed(overlapEventFootprints, subjectEventInstance) {\r\n\tvar subjectLegacyInstance = subjectEventInstance.toLegacy();\r\n\tvar i;\r\n\tvar overlapEventInstance;\r\n\tvar overlapEventDef;\r\n\tvar overlapVal;\r\n\r\n\tfor (i = 0; i < overlapEventFootprints.length; i++) {\r\n\t\toverlapEventInstance = overlapEventFootprints[i].eventInstance;\r\n\t\toverlapEventDef = overlapEventInstance.def;\r\n\r\n\t\t// don't need to pass in calendar, because don't want to consider global eventOverlap property,\r\n\t\t// because we already considered that earlier in the process.\r\n\t\toverlapVal = overlapEventDef.getOverlap();\r\n\r\n\t\tif (overlapVal === false) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\telse if (typeof overlapVal === 'function') {\r\n\t\t\tif (\r\n\t\t\t\t!overlapVal(\r\n\t\t\t\t\toverlapEventInstance.toLegacy(),\r\n\t\t\t\t\tsubjectLegacyInstance\r\n\t\t\t\t)\r\n\t\t\t) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn true;\r\n}\r\n\r\n\r\n// Conversion: eventDefs -> eventInstances -> eventRanges -> eventFootprints -> componentFootprints\r\n// ------------------------------------------------------------------------------------------------\r\n// NOTE: this might seem like repetitive code with the Grid class, however, this code is related to\r\n// constraints whereas the Grid code is related to rendering. Each approach might want to convert\r\n// eventRanges -> eventFootprints in a different way. Regardless, there are opportunities to make\r\n// this more DRY.\r\n\r\n\r\n/*\r\nReturns false on invalid input.\r\n*/\r\nCalendar.prototype.parseEventDefToInstances = function(eventInput) {\r\n\tvar eventManager = this.eventManager;\r\n\tvar eventDef = EventDefParser.parse(eventInput, new EventSource(this));\r\n\r\n\tif (!eventDef) { // invalid\r\n\t\treturn false;\r\n\t}\r\n\r\n\treturn eventDef.buildInstances(eventManager.currentPeriod.unzonedRange);\r\n};\r\n\r\n\r\nCalendar.prototype.eventRangesToEventFootprints = function(eventRanges) {\r\n\tvar i;\r\n\tvar eventFootprints = [];\r\n\r\n\tfor (i = 0; i < eventRanges.length; i++) {\r\n\t\teventFootprints.push.apply( // footprints\r\n\t\t\teventFootprints,\r\n\t\t\tthis.eventRangeToEventFootprints(eventRanges[i])\r\n\t\t);\r\n\t}\r\n\r\n\treturn eventFootprints;\r\n};\r\n\r\n\r\nCalendar.prototype.eventRangeToEventFootprints = function(eventRange) {\r\n\treturn [ eventRangeToEventFootprint(eventRange) ];\r\n};\r\n\r\n\r\n/*\r\nParses footprints directly.\r\nVery similar to EventDateProfile::parse :(\r\n*/\r\nCalendar.prototype.parseFootprints = function(rawInput) {\r\n\tvar start, end;\r\n\r\n\tif (rawInput.start) {\r\n\t\tstart = this.moment(rawInput.start);\r\n\r\n\t\tif (!start.isValid()) {\r\n\t\t\tstart = null;\r\n\t\t}\r\n\t}\r\n\r\n\tif (rawInput.end) {\r\n\t\tend = this.moment(rawInput.end);\r\n\r\n\t\tif (!end.isValid()) {\r\n\t\t\tend = null;\r\n\t\t}\r\n\t}\r\n\r\n\treturn [\r\n\t\tnew ComponentFootprint(\r\n\t\t\tnew UnzonedRange(start, end),\r\n\t\t\t(start && !start.hasTime()) || (end && !end.hasTime()) // isAllDay\r\n\t\t)\r\n\t];\r\n};\r\n\r\n\r\n// Footprint Utils\r\n// ----------------------------------------------------------------------------------------\r\n\r\n\r\nCalendar.prototype.footprintContainsFootprint = function(outerFootprint, innerFootprint) {\r\n\treturn outerFootprint.unzonedRange.containsRange(innerFootprint.unzonedRange);\r\n};\r\n\r\n\r\nCalendar.prototype.footprintsIntersect = function(footprint0, footprint1) {\r\n\treturn footprint0.unzonedRange.intersectsWith(footprint1.unzonedRange);\r\n};\r\n\r\n;;\r\n\r\nCalendar.mixin({\r\n\r\n\t// Sources\r\n\t// ------------------------------------------------------------------------------------\r\n\r\n\r\n\tgetEventSources: function() {\r\n\t\treturn this.eventManager.otherSources.slice(); // clone\r\n\t},\r\n\r\n\r\n\tgetEventSourceById: function(id) {\r\n\t\treturn this.eventManager.getSourceById(\r\n\t\t\tEventSource.normalizeId(id)\r\n\t\t);\r\n\t},\r\n\r\n\r\n\taddEventSource: function(sourceInput) {\r\n\t\tvar source = EventSourceParser.parse(sourceInput, this);\r\n\r\n\t\tif (source) {\r\n\t\t\tthis.eventManager.addSource(source);\r\n\t\t}\r\n\t},\r\n\r\n\r\n\tremoveEventSources: function(sourceMultiQuery) {\r\n\t\tvar eventManager = this.eventManager;\r\n\t\tvar sources;\r\n\t\tvar i;\r\n\r\n\t\tif (sourceMultiQuery == null) {\r\n\t\t\tthis.eventManager.removeAllSources();\r\n\t\t}\r\n\t\telse {\r\n\t\t\tsources = eventManager.multiQuerySources(sourceMultiQuery);\r\n\r\n\t\t\teventManager.freeze();\r\n\r\n\t\t\tfor (i = 0; i < sources.length; i++) {\r\n\t\t\t\teventManager.removeSource(sources[i]);\r\n\t\t\t}\r\n\r\n\t\t\teventManager.thaw();\r\n\t\t}\r\n\t},\r\n\r\n\r\n\tremoveEventSource: function(sourceQuery) {\r\n\t\tvar eventManager = this.eventManager;\r\n\t\tvar sources = eventManager.querySources(sourceQuery);\r\n\t\tvar i;\r\n\r\n\t\teventManager.freeze();\r\n\r\n\t\tfor (i = 0; i < sources.length; i++) {\r\n\t\t\teventManager.removeSource(sources[i]);\r\n\t\t}\r\n\r\n\t\teventManager.thaw();\r\n\t},\r\n\r\n\r\n\trefetchEventSources: function(sourceMultiQuery) {\r\n\t\tvar eventManager = this.eventManager;\r\n\t\tvar sources = eventManager.multiQuerySources(sourceMultiQuery);\r\n\t\tvar i;\r\n\r\n\t\teventManager.freeze();\r\n\r\n\t\tfor (i = 0; i < sources.length; i++) {\r\n\t\t\teventManager.refetchSource(sources[i]);\r\n\t\t}\r\n\r\n\t\teventManager.thaw();\r\n\t},\r\n\r\n\r\n\t// Events\r\n\t// ------------------------------------------------------------------------------------\r\n\r\n\r\n\trefetchEvents: function() {\r\n\t\tthis.eventManager.refetchAllSources();\r\n\t},\r\n\r\n\r\n\trenderEvents: function(eventInputs, isSticky) {\r\n\t\tthis.eventManager.freeze();\r\n\r\n\t\tfor (var i = 0; i < eventInputs.length; i++) {\r\n\t\t\tthis.renderEvent(eventInputs[i], isSticky);\r\n\t\t}\r\n\r\n\t\tthis.eventManager.thaw();\r\n\t},\r\n\r\n\r\n\trenderEvent: function(eventInput, isSticky) {\r\n\t\tvar eventManager = this.eventManager;\r\n\t\tvar eventDef = EventDefParser.parse(\r\n\t\t\teventInput,\r\n\t\t\teventInput.source || eventManager.stickySource\r\n\t\t);\r\n\r\n\t\tif (eventDef) {\r\n\t\t\teventManager.addEventDef(eventDef, isSticky);\r\n\t\t}\r\n\t},\r\n\r\n\r\n\t// legacyQuery operates on legacy event instance objects\r\n\tremoveEvents: function(legacyQuery) {\r\n\t\tvar eventManager = this.eventManager;\r\n\t\tvar legacyInstances = [];\r\n\t\tvar idMap = {};\r\n\t\tvar eventDef;\r\n\t\tvar i;\r\n\r\n\t\tif (legacyQuery == null) { // shortcut for removing all\r\n\t\t\teventManager.removeAllEventDefs(true); // persist=true\r\n\t\t}\r\n\t\telse {\r\n\t\t\teventManager.getEventInstances().forEach(function(eventInstance) {\r\n\t\t\t\tlegacyInstances.push(eventInstance.toLegacy());\r\n\t\t\t});\r\n\r\n\t\t\tlegacyInstances = filterLegacyEventInstances(legacyInstances, legacyQuery);\r\n\r\n\t\t\t// compute unique IDs\r\n\t\t\tfor (i = 0; i < legacyInstances.length; i++) {\r\n\t\t\t\teventDef = this.eventManager.getEventDefByUid(legacyInstances[i]._id);\r\n\t\t\t\tidMap[eventDef.id] = true;\r\n\t\t\t}\r\n\r\n\t\t\teventManager.freeze();\r\n\r\n\t\t\tfor (i in idMap) { // reuse `i` as an \"id\"\r\n\t\t\t\teventManager.removeEventDefsById(i, true); // persist=true\r\n\t\t\t}\r\n\r\n\t\t\teventManager.thaw();\r\n\t\t}\r\n\t},\r\n\r\n\r\n\t// legacyQuery operates on legacy event instance objects\r\n\tclientEvents: function(legacyQuery) {\r\n\t\tvar legacyEventInstances = [];\r\n\r\n\t\tthis.eventManager.getEventInstances().forEach(function(eventInstance) {\r\n\t\t\tlegacyEventInstances.push(eventInstance.toLegacy());\r\n\t\t});\r\n\r\n\t\treturn filterLegacyEventInstances(legacyEventInstances, legacyQuery);\r\n\t},\r\n\r\n\r\n\tupdateEvents: function(eventPropsArray) {\r\n\t\tthis.eventManager.freeze();\r\n\r\n\t\tfor (var i = 0; i < eventPropsArray.length; i++) {\r\n\t\t\tthis.updateEvent(eventPropsArray[i]);\r\n\t\t}\r\n\r\n\t\tthis.eventManager.thaw();\r\n\t},\r\n\r\n\r\n\tupdateEvent: function(eventProps) {\r\n\t\tvar eventDef = this.eventManager.getEventDefByUid(eventProps._id);\r\n\t\tvar eventInstance;\r\n\t\tvar eventDefMutation;\r\n\r\n\t\tif (eventDef instanceof SingleEventDef) {\r\n\t\t\teventInstance = eventDef.buildInstance();\r\n\r\n\t\t\teventDefMutation = EventDefMutation.createFromRawProps(\r\n\t\t\t\teventInstance,\r\n\t\t\t\teventProps, // raw props\r\n\t\t\t\tnull // largeUnit -- who uses it?\r\n\t\t\t);\r\n\r\n\t\t\tthis.eventManager.mutateEventsWithId(eventDef.id, eventDefMutation); // will release\r\n\t\t}\r\n\t}\r\n\r\n});\r\n\r\n\r\nfunction filterLegacyEventInstances(legacyEventInstances, legacyQuery) {\r\n\tif (legacyQuery == null) {\r\n\t\treturn legacyEventInstances;\r\n\t}\r\n\telse if ($.isFunction(legacyQuery)) {\r\n\t\treturn legacyEventInstances.filter(legacyQuery);\r\n\t}\r\n\telse { // an event ID\r\n\t\tlegacyQuery += ''; // normalize to string\r\n\r\n\t\treturn legacyEventInstances.filter(function(legacyEventInstance) {\r\n\t\t\t// soft comparison because id not be normalized to string\r\n\t\t\treturn legacyEventInstance.id == legacyQuery ||\r\n\t\t\t\tlegacyEventInstance._id === legacyQuery; // can specify internal id, but must exactly match\r\n\t\t});\r\n\t}\r\n}\r\n\r\n;;\r\n\r\nCalendar.defaults = {\r\n\r\n\ttitleRangeSeparator: ' \\u2013 ', // en dash\r\n\tmonthYearFormat: 'MMMM YYYY', // required for en. other locales rely on datepicker computable option\r\n\r\n\tdefaultTimedEventDuration: '02:00:00',\r\n\tdefaultAllDayEventDuration: { days: 1 },\r\n\tforceEventDuration: false,\r\n\tnextDayThreshold: '09:00:00', // 9am\r\n\r\n\t// display\r\n\tcolumnHeader: true,\r\n\tdefaultView: 'month',\r\n\taspectRatio: 1.35,\r\n\theader: {\r\n\t\tleft: 'title',\r\n\t\tcenter: '',\r\n\t\tright: 'today prev,next'\r\n\t},\r\n\tweekends: true,\r\n\tweekNumbers: false,\r\n\r\n\tweekNumberTitle: 'W',\r\n\tweekNumberCalculation: 'local',\r\n\t\r\n\t//editable: false,\r\n\r\n\t//nowIndicator: false,\r\n\r\n\tscrollTime: '06:00:00',\r\n\tminTime: '00:00:00',\r\n\tmaxTime: '24:00:00',\r\n\tshowNonCurrentDates: true,\r\n\t\r\n\t// event ajax\r\n\tlazyFetching: true,\r\n\tstartParam: 'start',\r\n\tendParam: 'end',\r\n\ttimezoneParam: 'timezone',\r\n\r\n\ttimezone: false,\r\n\r\n\t//allDayDefault: undefined,\r\n\r\n\t// locale\r\n\tisRTL: false,\r\n\tbuttonText: {\r\n\t\tprev: \"prev\",\r\n\t\tnext: \"next\",\r\n\t\tprevYear: \"prev year\",\r\n\t\tnextYear: \"next year\",\r\n\t\tyear: 'year', // TODO: locale files need to specify this\r\n\t\ttoday: 'today',\r\n\t\tmonth: 'month',\r\n\t\tweek: 'week',\r\n\t\tday: 'day'\r\n\t},\r\n\t//buttonIcons: null,\r\n\r\n\tallDayText: 'all-day',\r\n\r\n\t// allows setting a min-height to the event segment to prevent short events overlapping each other\r\n\tagendaEventMinHeight: 0,\r\n\t\r\n\t// jquery-ui theming\r\n\ttheme: false,\r\n\t//themeButtonIcons: null,\r\n\r\n\t//eventResizableFromStart: false,\r\n\tdragOpacity: .75,\r\n\tdragRevertDuration: 500,\r\n\tdragScroll: true,\r\n\t\r\n\t//selectable: false,\r\n\tunselectAuto: true,\r\n\t//selectMinDistance: 0,\r\n\t\r\n\tdropAccept: '*',\r\n\r\n\teventOrder: 'title',\r\n\t//eventRenderWait: null,\r\n\r\n\teventLimit: false,\r\n\teventLimitText: 'more',\r\n\teventLimitClick: 'popover',\r\n\tdayPopoverFormat: 'LL',\r\n\t\r\n\thandleWindowResize: true,\r\n\twindowResizeDelay: 100, // milliseconds before an updateSize happens\r\n\r\n\tlongPressDelay: 1000\r\n\t\r\n};\r\n\r\n\r\nCalendar.englishDefaults = { // used by locale.js\r\n\tdayPopoverFormat: 'dddd, MMMM D'\r\n};\r\n\r\n\r\nCalendar.rtlDefaults = { // right-to-left defaults\r\n\theader: { // TODO: smarter solution (first/center/last ?)\r\n\t\tleft: 'next,prev today',\r\n\t\tcenter: '',\r\n\t\tright: 'title'\r\n\t},\r\n\tbuttonIcons: {\r\n\t\tprev: 'right-single-arrow',\r\n\t\tnext: 'left-single-arrow',\r\n\t\tprevYear: 'right-double-arrow',\r\n\t\tnextYear: 'left-double-arrow'\r\n\t},\r\n\tthemeButtonIcons: {\r\n\t\tprev: 'circle-triangle-e',\r\n\t\tnext: 'circle-triangle-w',\r\n\t\tnextYear: 'seek-prev',\r\n\t\tprevYear: 'seek-next'\r\n\t}\r\n};\r\n\r\n;;\r\n\r\nvar localeOptionHash = FC.locales = {}; // initialize and expose\r\n\r\n\r\n// TODO: document the structure and ordering of a FullCalendar locale file\r\n\r\n\r\n// Initialize jQuery UI datepicker translations while using some of the translations\r\n// Will set this as the default locales for datepicker.\r\nFC.datepickerLocale = function(localeCode, dpLocaleCode, dpOptions) {\r\n\r\n\t// get the FullCalendar internal option hash for this locale. create if necessary\r\n\tvar fcOptions = localeOptionHash[localeCode] || (localeOptionHash[localeCode] = {});\r\n\r\n\t// transfer some simple options from datepicker to fc\r\n\tfcOptions.isRTL = dpOptions.isRTL;\r\n\tfcOptions.weekNumberTitle = dpOptions.weekHeader;\r\n\r\n\t// compute some more complex options from datepicker\r\n\t$.each(dpComputableOptions, function(name, func) {\r\n\t\tfcOptions[name] = func(dpOptions);\r\n\t});\r\n\r\n\t// is jQuery UI Datepicker is on the page?\r\n\tif ($.datepicker) {\r\n\r\n\t\t// Register the locale data.\r\n\t\t// FullCalendar and MomentJS use locale codes like \"pt-br\" but Datepicker\r\n\t\t// does it like \"pt-BR\" or if it doesn't have the locale, maybe just \"pt\".\r\n\t\t// Make an alias so the locale can be referenced either way.\r\n\t\t$.datepicker.regional[dpLocaleCode] =\r\n\t\t\t$.datepicker.regional[localeCode] = // alias\r\n\t\t\t\tdpOptions;\r\n\r\n\t\t// Alias 'en' to the default locale data. Do this every time.\r\n\t\t$.datepicker.regional.en = $.datepicker.regional[''];\r\n\r\n\t\t// Set as Datepicker's global defaults.\r\n\t\t$.datepicker.setDefaults(dpOptions);\r\n\t}\r\n};\r\n\r\n\r\n// Sets FullCalendar-specific translations. Will set the locales as the global default.\r\nFC.locale = function(localeCode, newFcOptions) {\r\n\tvar fcOptions;\r\n\tvar momOptions;\r\n\r\n\t// get the FullCalendar internal option hash for this locale. create if necessary\r\n\tfcOptions = localeOptionHash[localeCode] || (localeOptionHash[localeCode] = {});\r\n\r\n\t// provided new options for this locales? merge them in\r\n\tif (newFcOptions) {\r\n\t\tfcOptions = localeOptionHash[localeCode] = mergeOptions([ fcOptions, newFcOptions ]);\r\n\t}\r\n\r\n\t// compute locale options that weren't defined.\r\n\t// always do this. newFcOptions can be undefined when initializing from i18n file,\r\n\t// so no way to tell if this is an initialization or a default-setting.\r\n\tmomOptions = getMomentLocaleData(localeCode); // will fall back to en\r\n\t$.each(momComputableOptions, function(name, func) {\r\n\t\tif (fcOptions[name] == null) {\r\n\t\t\tfcOptions[name] = func(momOptions, fcOptions);\r\n\t\t}\r\n\t});\r\n\r\n\t// set it as the default locale for FullCalendar\r\n\tCalendar.defaults.locale = localeCode;\r\n};\r\n\r\n\r\n// NOTE: can't guarantee any of these computations will run because not every locale has datepicker\r\n// configs, so make sure there are English fallbacks for these in the defaults file.\r\nvar dpComputableOptions = {\r\n\r\n\tbuttonText: function(dpOptions) {\r\n\t\treturn {\r\n\t\t\t// the translations sometimes wrongly contain HTML entities\r\n\t\t\tprev: stripHtmlEntities(dpOptions.prevText),\r\n\t\t\tnext: stripHtmlEntities(dpOptions.nextText),\r\n\t\t\ttoday: stripHtmlEntities(dpOptions.currentText)\r\n\t\t};\r\n\t},\r\n\r\n\t// Produces format strings like \"MMMM YYYY\" -> \"September 2014\"\r\n\tmonthYearFormat: function(dpOptions) {\r\n\t\treturn dpOptions.showMonthAfterYear ?\r\n\t\t\t'YYYY[' + dpOptions.yearSuffix + '] MMMM' :\r\n\t\t\t'MMMM YYYY[' + dpOptions.yearSuffix + ']';\r\n\t}\r\n\r\n};\r\n\r\nvar momComputableOptions = {\r\n\r\n\t// Produces format strings like \"ddd M/D\" -> \"Fri 9/15\"\r\n\tdayOfMonthFormat: function(momOptions, fcOptions) {\r\n\t\tvar format = momOptions.longDateFormat('l'); // for the format like \"M/D/YYYY\"\r\n\r\n\t\t// strip the year off the edge, as well as other misc non-whitespace chars\r\n\t\tformat = format.replace(/^Y+[^\\w\\s]*|[^\\w\\s]*Y+$/g, '');\r\n\r\n\t\tif (fcOptions.isRTL) {\r\n\t\t\tformat += ' ddd'; // for RTL, add day-of-week to end\r\n\t\t}\r\n\t\telse {\r\n\t\t\tformat = 'ddd ' + format; // for LTR, add day-of-week to beginning\r\n\t\t}\r\n\t\treturn format;\r\n\t},\r\n\r\n\t// Produces format strings like \"h:mma\" -> \"6:00pm\"\r\n\tmediumTimeFormat: function(momOptions) { // can't be called `timeFormat` because collides with option\r\n\t\treturn momOptions.longDateFormat('LT')\r\n\t\t\t.replace(/\\s*a$/i, 'a'); // convert AM/PM/am/pm to lowercase. remove any spaces beforehand\r\n\t},\r\n\r\n\t// Produces format strings like \"h(:mm)a\" -> \"6pm\" / \"6:30pm\"\r\n\tsmallTimeFormat: function(momOptions) {\r\n\t\treturn momOptions.longDateFormat('LT')\r\n\t\t\t.replace(':mm', '(:mm)')\r\n\t\t\t.replace(/(\\Wmm)$/, '($1)') // like above, but for foreign locales\r\n\t\t\t.replace(/\\s*a$/i, 'a'); // convert AM/PM/am/pm to lowercase. remove any spaces beforehand\r\n\t},\r\n\r\n\t// Produces format strings like \"h(:mm)t\" -> \"6p\" / \"6:30p\"\r\n\textraSmallTimeFormat: function(momOptions) {\r\n\t\treturn momOptions.longDateFormat('LT')\r\n\t\t\t.replace(':mm', '(:mm)')\r\n\t\t\t.replace(/(\\Wmm)$/, '($1)') // like above, but for foreign locales\r\n\t\t\t.replace(/\\s*a$/i, 't'); // convert to AM/PM/am/pm to lowercase one-letter. remove any spaces beforehand\r\n\t},\r\n\r\n\t// Produces format strings like \"ha\" / \"H\" -> \"6pm\" / \"18\"\r\n\thourFormat: function(momOptions) {\r\n\t\treturn momOptions.longDateFormat('LT')\r\n\t\t\t.replace(':mm', '')\r\n\t\t\t.replace(/(\\Wmm)$/, '') // like above, but for foreign locales\r\n\t\t\t.replace(/\\s*a$/i, 'a'); // convert AM/PM/am/pm to lowercase. remove any spaces beforehand\r\n\t},\r\n\r\n\t// Produces format strings like \"h:mm\" -> \"6:30\" (with no AM/PM)\r\n\tnoMeridiemTimeFormat: function(momOptions) {\r\n\t\treturn momOptions.longDateFormat('LT')\r\n\t\t\t.replace(/\\s*a$/i, ''); // remove trailing AM/PM\r\n\t}\r\n\r\n};\r\n\r\n\r\n// options that should be computed off live calendar options (considers override options)\r\n// TODO: best place for this? related to locale?\r\n// TODO: flipping text based on isRTL is a bad idea because the CSS `direction` might want to handle it\r\nvar instanceComputableOptions = {\r\n\r\n\t// Produces format strings for results like \"Mo 16\"\r\n\tsmallDayDateFormat: function(options) {\r\n\t\treturn options.isRTL ?\r\n\t\t\t'D dd' :\r\n\t\t\t'dd D';\r\n\t},\r\n\r\n\t// Produces format strings for results like \"Wk 5\"\r\n\tweekFormat: function(options) {\r\n\t\treturn options.isRTL ?\r\n\t\t\t'w[ ' + options.weekNumberTitle + ']' :\r\n\t\t\t'[' + options.weekNumberTitle + ' ]w';\r\n\t},\r\n\r\n\t// Produces format strings for results like \"Wk5\"\r\n\tsmallWeekFormat: function(options) {\r\n\t\treturn options.isRTL ?\r\n\t\t\t'w[' + options.weekNumberTitle + ']' :\r\n\t\t\t'[' + options.weekNumberTitle + ']w';\r\n\t}\r\n\r\n};\r\n\r\n// TODO: make these computable properties in optionsModel\r\nfunction populateInstanceComputableOptions(options) {\r\n\t$.each(instanceComputableOptions, function(name, func) {\r\n\t\tif (options[name] == null) {\r\n\t\t\toptions[name] = func(options);\r\n\t\t}\r\n\t});\r\n}\r\n\r\n\r\n// Returns moment's internal locale data. If doesn't exist, returns English.\r\nfunction getMomentLocaleData(localeCode) {\r\n\treturn moment.localeData(localeCode) || moment.localeData('en');\r\n}\r\n\r\n\r\n// Initialize English by forcing computation of moment-derived options.\r\n// Also, sets it as the default.\r\nFC.locale('en', Calendar.englishDefaults);\r\n\r\n;;\r\n\r\nvar UnzonedRange = FC.UnzonedRange = Class.extend({\r\n\r\n\tstartMs: null, // if null, no start constraint\r\n\tendMs: null, // if null, no end constraint\r\n\r\n\t// TODO: move these into footprint.\r\n\t// Especially, doesn't make sense for null startMs/endMs.\r\n\tisStart: true,\r\n\tisEnd: true,\r\n\r\n\tconstructor: function(startInput, endInput) {\r\n\r\n\t\tif (moment.isMoment(startInput)) {\r\n\t\t\tstartInput = startInput.clone().stripZone();\r\n\t\t}\r\n\r\n\t\tif (moment.isMoment(endInput)) {\r\n\t\t\tendInput = endInput.clone().stripZone();\r\n\t\t}\r\n\r\n\t\tif (startInput) {\r\n\t\t\tthis.startMs = startInput.valueOf();\r\n\t\t}\r\n\r\n\t\tif (endInput) {\r\n\t\t\tthis.endMs = endInput.valueOf();\r\n\t\t}\r\n\t},\r\n\r\n\tintersect: function(otherRange) {\r\n\t\tvar startMs = this.startMs;\r\n\t\tvar endMs = this.endMs;\r\n\t\tvar newRange = null;\r\n\r\n\t\tif (otherRange.startMs !== null) {\r\n\t\t\tif (startMs === null) {\r\n\t\t\t\tstartMs = otherRange.startMs;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tstartMs = Math.max(startMs, otherRange.startMs);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (otherRange.endMs !== null) {\r\n\t\t\tif (endMs === null) {\r\n\t\t\t\tendMs = otherRange.endMs;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tendMs = Math.min(endMs, otherRange.endMs);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (startMs === null || endMs === null || startMs < endMs) {\r\n\t\t\tnewRange = new UnzonedRange(startMs, endMs);\r\n\t\t\tnewRange.isStart = this.isStart && startMs === this.startMs;\r\n\t\t\tnewRange.isEnd = this.isEnd && endMs === this.endMs;\r\n\t\t}\r\n\r\n\t\treturn newRange;\r\n\t},\r\n\r\n\r\n\tintersectsWith: function(otherRange) {\r\n\t\treturn (this.endMs === null || otherRange.startMs === null || this.endMs > otherRange.startMs) &&\r\n\t\t\t(this.startMs === null || otherRange.endMs === null || this.startMs < otherRange.endMs);\r\n\t},\r\n\r\n\r\n\tcontainsRange: function(innerRange) {\r\n\t\treturn (this.startMs === null || (innerRange.startMs !== null && innerRange.startMs >= this.startMs)) &&\r\n\t\t\t(this.endMs === null || (innerRange.endMs !== null && innerRange.endMs <= this.endMs));\r\n\t},\r\n\r\n\r\n\t// `date` can be a moment, a Date, or a millisecond time.\r\n\tcontainsDate: function(date) {\r\n\t\tvar ms = date.valueOf();\r\n\r\n\t\treturn (this.startMs === null || ms >= this.startMs) &&\r\n\t\t\t(this.endMs === null || ms < this.endMs);\r\n\t},\r\n\r\n\r\n\t// If the given date is not within the given range, move it inside.\r\n\t// (If it's past the end, make it one millisecond before the end).\r\n\t// `date` can be a moment, a Date, or a millisecond time.\r\n\t// Returns a MS-time.\r\n\tconstrainDate: function(date) {\r\n\t\tvar ms = date.valueOf();\r\n\r\n\t\tif (this.startMs !== null && ms < this.startMs) {\r\n\t\t\tms = this.startMs;\r\n\t\t}\r\n\r\n\t\tif (this.endMs !== null && ms >= this.endMs) {\r\n\t\t\tms = this.endMs - 1;\r\n\t\t}\r\n\r\n\t\treturn ms;\r\n\t},\r\n\r\n\r\n\tequals: function(otherRange) {\r\n\t\treturn this.startMs === otherRange.startMs && this.endMs === otherRange.endMs;\r\n\t},\r\n\r\n\r\n\tclone: function() {\r\n\t\tvar range = new UnzonedRange(this.startMs, this.endMs);\r\n\r\n\t\trange.isStart = this.isStart;\r\n\t\trange.isEnd = this.isEnd;\r\n\r\n\t\treturn range;\r\n\t},\r\n\r\n\r\n\t// Returns an ambig-zoned moment from startMs.\r\n\t// BEWARE: returned moment is not localized.\r\n\t// Formatting and start-of-week will be default.\r\n\tgetStart: function() {\r\n\t\tif (this.startMs !== null) {\r\n\t\t\treturn FC.moment.utc(this.startMs).stripZone();\r\n\t\t}\r\n\t},\r\n\r\n\t// Returns an ambig-zoned moment from startMs.\r\n\t// BEWARE: returned moment is not localized.\r\n\t// Formatting and start-of-week will be default.\r\n\tgetEnd: function() {\r\n\t\tif (this.endMs !== null) {\r\n\t\t\treturn FC.moment.utc(this.endMs).stripZone();\r\n\t\t}\r\n\t},\r\n\r\n\r\n\tas: function(unit) {\r\n\t\treturn moment.utc(this.endMs).diff(\r\n\t\t\tmoment.utc(this.startMs),\r\n\t\t\tunit,\r\n\t\t\ttrue\r\n\t\t);\r\n\t}\r\n\r\n});\r\n\r\n\r\n/*\r\nSIDEEFFECT: will mutate eventRanges.\r\nWill return a new array result.\r\nOnly works for non-open-ended ranges.\r\n*/\r\nfunction invertUnzonedRanges(ranges, constraintRange) {\r\n\tvar invertedRanges = [];\r\n\tvar startMs = constraintRange.startMs; // the end of the previous range. the start of the new range\r\n\tvar i;\r\n\tvar dateRange;\r\n\r\n\t// ranges need to be in order. required for our date-walking algorithm\r\n\tranges.sort(compareUnzonedRanges);\r\n\r\n\tfor (i = 0; i < ranges.length; i++) {\r\n\t\tdateRange = ranges[i];\r\n\r\n\t\t// add the span of time before the event (if there is any)\r\n\t\tif (dateRange.startMs > startMs) { // compare millisecond time (skip any ambig logic)\r\n\t\t\tinvertedRanges.push(\r\n\t\t\t\tnew UnzonedRange(startMs, dateRange.startMs)\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\tif (dateRange.endMs > startMs) {\r\n\t\t\tstartMs = dateRange.endMs;\r\n\t\t}\r\n\t}\r\n\r\n\t// add the span of time after the last event (if there is any)\r\n\tif (startMs < constraintRange.endMs) { // compare millisecond time (skip any ambig logic)\r\n\t\tinvertedRanges.push(\r\n\t\t\tnew UnzonedRange(startMs, constraintRange.endMs)\r\n\t\t);\r\n\t}\r\n\r\n\treturn invertedRanges;\r\n}\r\n\r\n\r\n/*\r\nOnly works for non-open-ended ranges.\r\n*/\r\nfunction compareUnzonedRanges(range1, range2) {\r\n\treturn range1.startMs - range2.startMs; // earlier ranges go first\r\n}\r\n\r\n;;\r\n\r\n/*\r\nMeant to be immutable\r\n*/\r\nvar ComponentFootprint = FC.ComponentFootprint = Class.extend({\r\n\r\n\tunzonedRange: null,\r\n\tisAllDay: false, // component can choose to ignore this\r\n\r\n\r\n\tconstructor: function(unzonedRange, isAllDay) {\r\n\t\tthis.unzonedRange = unzonedRange;\r\n\t\tthis.isAllDay = isAllDay;\r\n\t},\r\n\r\n\r\n\t/*\r\n\tOnly works for non-open-ended ranges.\r\n\t*/\r\n\ttoLegacy: function(calendar) {\r\n\t\treturn {\r\n\t\t\tstart: calendar.msToMoment(this.unzonedRange.startMs, this.isAllDay),\r\n\t\t\tend: calendar.msToMoment(this.unzonedRange.endMs, this.isAllDay)\r\n\t\t};\r\n\t}\r\n\r\n});\r\n\r\n;;\r\n\r\nvar EventPeriod = Class.extend(EmitterMixin, {\r\n\r\n\tstart: null,\r\n\tend: null,\r\n\ttimezone: null,\r\n\r\n\tunzonedRange: null,\r\n\r\n\trequestsByUid: null,\r\n\tpendingCnt: 0,\r\n\r\n\tfreezeDepth: 0,\r\n\tstuntedReleaseCnt: 0,\r\n\treleaseCnt: 0,\r\n\r\n\teventDefsByUid: null,\r\n\teventDefsById: null,\r\n\teventInstanceGroupsById: null,\r\n\r\n\r\n\tconstructor: function(start, end, timezone) {\r\n\t\tthis.start = start;\r\n\t\tthis.end = end;\r\n\t\tthis.timezone = timezone;\r\n\r\n\t\tthis.unzonedRange = new UnzonedRange(\r\n\t\t\tstart.clone().stripZone(),\r\n\t\t\tend.clone().stripZone()\r\n\t\t);\r\n\r\n\t\tthis.requestsByUid = {};\r\n\t\tthis.eventDefsByUid = {};\r\n\t\tthis.eventDefsById = {};\r\n\t\tthis.eventInstanceGroupsById = {};\r\n\t},\r\n\r\n\r\n\tisWithinRange: function(start, end) {\r\n\t\t// TODO: use a range util function?\r\n\t\treturn !start.isBefore(this.start) && !end.isAfter(this.end);\r\n\t},\r\n\r\n\r\n\t// Requesting and Purging\r\n\t// -----------------------------------------------------------------------------------------------------------------\r\n\r\n\r\n\trequestSources: function(sources) {\r\n\t\tthis.freeze();\r\n\r\n\t\tfor (var i = 0; i < sources.length; i++) {\r\n\t\t\tthis.requestSource(sources[i]);\r\n\t\t}\r\n\r\n\t\tthis.thaw();\r\n\t},\r\n\r\n\r\n\trequestSource: function(source) {\r\n\t\tvar _this = this;\r\n\t\tvar request = { source: source, status: 'pending' };\r\n\r\n\t\tthis.requestsByUid[source.uid] = request;\r\n\t\tthis.pendingCnt += 1;\r\n\r\n\t\tsource.fetch(this.start, this.end, this.timezone).then(function(eventDefs) {\r\n\t\t\tif (request.status !== 'cancelled') {\r\n\t\t\t\trequest.status = 'completed';\r\n\t\t\t\trequest.eventDefs = eventDefs;\r\n\r\n\t\t\t\t_this.addEventDefs(eventDefs);\r\n\t\t\t\t_this.pendingCnt--;\r\n\t\t\t\t_this.tryRelease();\r\n\t\t\t}\r\n\t\t}, function() { // failure\r\n\t\t\tif (request.status !== 'cancelled') {\r\n\t\t\t\trequest.status = 'failed';\r\n\r\n\t\t\t\t_this.pendingCnt--;\r\n\t\t\t\t_this.tryRelease();\r\n\t\t\t}\r\n\t\t});\r\n\t},\r\n\r\n\r\n\tpurgeSource: function(source) {\r\n\t\tvar request = this.requestsByUid[source.uid];\r\n\r\n\t\tif (request) {\r\n\t\t\tdelete this.requestsByUid[source.uid];\r\n\r\n\t\t\tif (request.status === 'pending') {\r\n\t\t\t\trequest.status = 'cancelled';\r\n\t\t\t\tthis.pendingCnt--;\r\n\t\t\t\tthis.tryRelease();\r\n\t\t\t}\r\n\t\t\telse if (request.status === 'completed') {\r\n\t\t\t\trequest.eventDefs.forEach(this.removeEventDef.bind(this));\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\r\n\tpurgeAllSources: function() {\r\n\t\tvar requestsByUid = this.requestsByUid;\r\n\t\tvar uid, request;\r\n\t\tvar completedCnt = 0;\r\n\r\n\t\tfor (uid in requestsByUid) {\r\n\t\t\trequest = requestsByUid[uid];\r\n\r\n\t\t\tif (request.status === 'pending') {\r\n\t\t\t\trequest.status = 'cancelled';\r\n\t\t\t}\r\n\t\t\telse if (request.status === 'completed') {\r\n\t\t\t\tcompletedCnt++;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis.requestsByUid = {};\r\n\t\tthis.pendingCnt = 0;\r\n\r\n\t\tif (completedCnt) {\r\n\t\t\tthis.removeAllEventDefs(); // might release\r\n\t\t}\r\n\t},\r\n\r\n\r\n\t// Event Definitions\r\n\t// -----------------------------------------------------------------------------------------------------------------\r\n\r\n\r\n\tgetEventDefByUid: function(eventDefUid) {\r\n\t\treturn this.eventDefsByUid[eventDefUid];\r\n\t},\r\n\r\n\r\n\tgetEventDefsById: function(eventDefId) {\r\n\t\tvar a = this.eventDefsById[eventDefId];\r\n\r\n\t\tif (a) {\r\n\t\t\treturn a.slice(); // clone\r\n\t\t}\r\n\r\n\t\treturn [];\r\n\t},\r\n\r\n\r\n\taddEventDefs: function(eventDefs) {\r\n\t\tfor (var i = 0; i < eventDefs.length; i++) {\r\n\t\t\tthis.addEventDef(eventDefs[i]);\r\n\t\t}\r\n\t},\r\n\r\n\r\n\taddEventDef: function(eventDef) {\r\n\t\tvar eventDefsById = this.eventDefsById;\r\n\t\tvar eventDefId = eventDef.id;\r\n\t\tvar eventDefs = eventDefsById[eventDefId] || (eventDefsById[eventDefId] = []);\r\n\t\tvar eventInstances = eventDef.buildInstances(this.unzonedRange);\r\n\t\tvar i;\r\n\r\n\t\teventDefs.push(eventDef);\r\n\r\n\t\tthis.eventDefsByUid[eventDef.uid] = eventDef;\r\n\r\n\t\tfor (i = 0; i < eventInstances.length; i++) {\r\n\t\t\tthis.addEventInstance(eventInstances[i], eventDefId);\r\n\t\t}\r\n\t},\r\n\r\n\r\n\tremoveEventDefsById: function(eventDefId) {\r\n\t\tvar _this = this;\r\n\r\n\t\tthis.getEventDefsById(eventDefId).forEach(function(eventDef) {\r\n\t\t\t_this.removeEventDef(eventDef);\r\n\t\t});\r\n\t},\r\n\r\n\r\n\tremoveAllEventDefs: function() {\r\n\t\tvar isEmpty = $.isEmptyObject(this.eventDefsByUid);\r\n\r\n\t\tthis.eventDefsByUid = {};\r\n\t\tthis.eventDefsById = {};\r\n\t\tthis.eventInstanceGroupsById = {};\r\n\r\n\t\tif (!isEmpty) {\r\n\t\t\tthis.tryRelease();\r\n\t\t}\r\n\t},\r\n\r\n\r\n\tremoveEventDef: function(eventDef) {\r\n\t\tvar eventDefsById = this.eventDefsById;\r\n\t\tvar eventDefs = eventDefsById[eventDef.id];\r\n\r\n\t\tdelete this.eventDefsByUid[eventDef.uid];\r\n\r\n\t\tif (eventDefs) {\r\n\t\t\tremoveExact(eventDefs, eventDef);\r\n\r\n\t\t\tif (!eventDefs.length) {\r\n\t\t\t\tdelete eventDefsById[eventDef.id];\r\n\t\t\t}\r\n\r\n\t\t\tthis.removeEventInstancesForDef(eventDef);\r\n\t\t}\r\n\t},\r\n\r\n\r\n\t// Event Instances\r\n\t// -----------------------------------------------------------------------------------------------------------------\r\n\r\n\r\n\tgetEventInstances: function() { // TODO: consider iterator\r\n\t\tvar eventInstanceGroupsById = this.eventInstanceGroupsById;\r\n\t\tvar eventInstances = [];\r\n\t\tvar id;\r\n\r\n\t\tfor (id in eventInstanceGroupsById) {\r\n\t\t\teventInstances.push.apply(eventInstances, // append\r\n\t\t\t\teventInstanceGroupsById[id].eventInstances\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\treturn eventInstances;\r\n\t},\r\n\r\n\r\n\tgetEventInstancesWithId: function(eventDefId) {\r\n\t\tvar eventInstanceGroup = this.eventInstanceGroupsById[eventDefId];\r\n\r\n\t\tif (eventInstanceGroup) {\r\n\t\t\treturn eventInstanceGroup.eventInstances.slice(); // clone\r\n\t\t}\r\n\r\n\t\treturn [];\r\n\t},\r\n\r\n\r\n\tgetEventInstancesWithoutId: function(eventDefId) { // TODO: consider iterator\r\n\t\tvar eventInstanceGroupsById = this.eventInstanceGroupsById;\r\n\t\tvar matchingInstances = [];\r\n\t\tvar id;\r\n\r\n\t\tfor (id in eventInstanceGroupsById) {\r\n\t\t\tif (id !== eventDefId) {\r\n\t\t\t\tmatchingInstances.push.apply(matchingInstances, // append\r\n\t\t\t\t\teventInstanceGroupsById[id].eventInstances\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn matchingInstances;\r\n\t},\r\n\r\n\r\n\taddEventInstance: function(eventInstance, eventDefId) {\r\n\t\tvar eventInstanceGroupsById = this.eventInstanceGroupsById;\r\n\t\tvar eventInstanceGroup = eventInstanceGroupsById[eventDefId] ||\r\n\t\t\t(eventInstanceGroupsById[eventDefId] = new EventInstanceGroup());\r\n\r\n\t\teventInstanceGroup.eventInstances.push(eventInstance);\r\n\r\n\t\tthis.tryRelease();\r\n\t},\r\n\r\n\r\n\tremoveEventInstancesForDef: function(eventDef) {\r\n\t\tvar eventInstanceGroupsById = this.eventInstanceGroupsById;\r\n\t\tvar eventInstanceGroup = eventInstanceGroupsById[eventDef.id];\r\n\t\tvar removeCnt;\r\n\r\n\t\tif (eventInstanceGroup) {\r\n\t\t\tremoveCnt = removeMatching(eventInstanceGroup.eventInstances, function(currentEventInstance) {\r\n\t\t\t\treturn currentEventInstance.def === eventDef;\r\n\t\t\t});\r\n\r\n\t\t\tif (!eventInstanceGroup.eventInstances.length) {\r\n\t\t\t\tdelete eventInstanceGroupsById[eventDef.id];\r\n\t\t\t}\r\n\r\n\t\t\tif (removeCnt) {\r\n\t\t\t\tthis.tryRelease();\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\r\n\t// Releasing and Freezing\r\n\t// -----------------------------------------------------------------------------------------------------------------\r\n\r\n\r\n\ttryRelease: function() {\r\n\t\tif (!this.pendingCnt) {\r\n\t\t\tif (!this.freezeDepth) {\r\n\t\t\t\tthis.release();\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tthis.stuntedReleaseCnt++;\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\r\n\trelease: function() {\r\n\t\tthis.releaseCnt++;\r\n\t\tthis.trigger('release', this.eventInstanceGroupsById);\r\n\t},\r\n\r\n\r\n\twhenReleased: function() {\r\n\t\tvar _this = this;\r\n\r\n\t\tif (this.releaseCnt) {\r\n\t\t\treturn Promise.resolve(this.eventInstanceGroupsById);\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn Promise.construct(function(onResolve) {\r\n\t\t\t\t_this.one('release', onResolve);\r\n\t\t\t});\r\n\t\t}\r\n\t},\r\n\r\n\r\n\tfreeze: function() {\r\n\t\tif (!(this.freezeDepth++)) {\r\n\t\t\tthis.stuntedReleaseCnt = 0;\r\n\t\t}\r\n\t},\r\n\r\n\r\n\tthaw: function() {\r\n\t\tif (!(--this.freezeDepth) && this.stuntedReleaseCnt && !this.pendingCnt) {\r\n\t\t\tthis.release();\r\n\t\t}\r\n\t}\r\n\r\n});\r\n\r\n;;\r\n\r\nvar EventManager = Class.extend(EmitterMixin, ListenerMixin, {\r\n\r\n\tcurrentPeriod: null,\r\n\r\n\tcalendar: null,\r\n\tstickySource: null,\r\n\totherSources: null, // does not include sticky source\r\n\r\n\r\n\tconstructor: function(calendar) {\r\n\t\tthis.calendar = calendar;\r\n\t\tthis.stickySource = new ArrayEventSource(calendar);\r\n\t\tthis.otherSources = [];\r\n\t},\r\n\r\n\r\n\trequestEvents: function(start, end, timezone, force) {\r\n\t\tif (\r\n\t\t\tforce ||\r\n\t\t\t!this.currentPeriod ||\r\n\t\t\t!this.currentPeriod.isWithinRange(start, end) ||\r\n\t\t\ttimezone !== this.currentPeriod.timezone\r\n\t\t) {\r\n\t\t\tthis.setPeriod( // will change this.currentPeriod\r\n\t\t\t\tnew EventPeriod(start, end, timezone)\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\treturn this.currentPeriod.whenReleased();\r\n\t},\r\n\r\n\r\n\t// Source Adding/Removing\r\n\t// -----------------------------------------------------------------------------------------------------------------\r\n\r\n\r\n\taddSource: function(eventSource) {\r\n\t\tthis.otherSources.push(eventSource);\r\n\r\n\t\tif (this.currentPeriod) {\r\n\t\t\tthis.currentPeriod.requestSource(eventSource); // might release\r\n\t\t}\r\n\t},\r\n\r\n\r\n\tremoveSource: function(doomedSource) {\r\n\t\tremoveExact(this.otherSources, doomedSource);\r\n\r\n\t\tif (this.currentPeriod) {\r\n\t\t\tthis.currentPeriod.purgeSource(doomedSource); // might release\r\n\t\t}\r\n\t},\r\n\r\n\r\n\tremoveAllSources: function() {\r\n\t\tthis.otherSources = [];\r\n\r\n\t\tif (this.currentPeriod) {\r\n\t\t\tthis.currentPeriod.purgeAllSources(); // might release\r\n\t\t}\r\n\t},\r\n\r\n\r\n\t// Source Refetching\r\n\t// -----------------------------------------------------------------------------------------------------------------\r\n\r\n\r\n\trefetchSource: function(eventSource) {\r\n\t\tvar currentPeriod = this.currentPeriod;\r\n\r\n\t\tif (currentPeriod) {\r\n\t\t\tcurrentPeriod.freeze();\r\n\t\t\tcurrentPeriod.purgeSource(eventSource);\r\n\t\t\tcurrentPeriod.requestSource(eventSource);\r\n\t\t\tcurrentPeriod.thaw();\r\n\t\t}\r\n\t},\r\n\r\n\r\n\trefetchAllSources: function() {\r\n\t\tvar currentPeriod = this.currentPeriod;\r\n\r\n\t\tif (currentPeriod) {\r\n\t\t\tcurrentPeriod.freeze();\r\n\t\t\tcurrentPeriod.purgeAllSources();\r\n\t\t\tcurrentPeriod.requestSources(this.getSources());\r\n\t\t\tcurrentPeriod.thaw();\r\n\t\t}\r\n\t},\r\n\r\n\r\n\t// Source Querying\r\n\t// -----------------------------------------------------------------------------------------------------------------\r\n\r\n\r\n\tgetSources: function() {\r\n\t\treturn [ this.stickySource ].concat(this.otherSources);\r\n\t},\r\n\r\n\r\n\t// like querySources, but accepts multple match criteria (like multiple IDs)\r\n\tmultiQuerySources: function(matchInputs) {\r\n\r\n\t\t// coerce into an array\r\n\t\tif (!matchInputs) {\r\n\t\t\tmatchInputs = [];\r\n\t\t}\r\n\t\telse if (!$.isArray(matchInputs)) {\r\n\t\t\tmatchInputs = [ matchInputs ];\r\n\t\t}\r\n\r\n\t\tvar matchingSources = [];\r\n\t\tvar i;\r\n\r\n\t\t// resolve raw inputs to real event source objects\r\n\t\tfor (i = 0; i < matchInputs.length; i++) {\r\n\t\t\tmatchingSources.push.apply( // append\r\n\t\t\t\tmatchingSources,\r\n\t\t\t\tthis.querySources(matchInputs[i])\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\treturn matchingSources;\r\n\t},\r\n\r\n\r\n\t// matchInput can either by a real event source object, an ID, or the function/URL for the source.\r\n\t// returns an array of matching source objects.\r\n\tquerySources: function(matchInput) {\r\n\t\tvar sources = this.otherSources;\r\n\t\tvar i, source;\r\n\r\n\t\t// given a proper event source object\r\n\t\tfor (i = 0; i < sources.length; i++) {\r\n\t\t\tsource = sources[i];\r\n\r\n\t\t\tif (source === matchInput) {\r\n\t\t\t\treturn [ source ];\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// an ID match\r\n\t\tsource = this.getSourceById(EventSource.normalizeId(matchInput));\r\n\t\tif (source) {\r\n\t\t\treturn [ source ];\r\n\t\t}\r\n\r\n\t\t// parse as an event source\r\n\t\tmatchInput = EventSourceParser.parse(matchInput, this.calendar);\r\n\t\tif (matchInput) {\r\n\r\n\t\t\treturn $.grep(sources, function(source) {\r\n\t\t\t\treturn isSourcesEquivalent(matchInput, source);\r\n\t\t\t});\r\n\t\t}\r\n\t},\r\n\r\n\r\n\t/*\r\n\tID assumed to already be normalized\r\n\t*/\r\n\tgetSourceById: function(id) {\r\n\t\treturn $.grep(this.otherSources, function(source) {\r\n\t\t\treturn source.id && source.id === id;\r\n\t\t})[0];\r\n\t},\r\n\r\n\r\n\t// Event-Period\r\n\t// -----------------------------------------------------------------------------------------------------------------\r\n\r\n\r\n\tsetPeriod: function(eventPeriod) {\r\n\t\tif (this.currentPeriod) {\r\n\t\t\tthis.unbindPeriod(this.currentPeriod);\r\n\t\t\tthis.currentPeriod = null;\r\n\t\t}\r\n\r\n\t\tthis.currentPeriod = eventPeriod;\r\n\t\tthis.bindPeriod(eventPeriod);\r\n\r\n\t\teventPeriod.requestSources(this.getSources());\r\n\t},\r\n\r\n\r\n\tbindPeriod: function(eventPeriod) {\r\n\t\tthis.listenTo(eventPeriod, 'release', function(eventsPayload) {\r\n\t\t\tthis.trigger('release', eventsPayload);\r\n\t\t});\r\n\t},\r\n\r\n\r\n\tunbindPeriod: function(eventPeriod) {\r\n\t\tthis.stopListeningTo(eventPeriod);\r\n\t},\r\n\r\n\r\n\t// Event Getting/Adding/Removing\r\n\t// -----------------------------------------------------------------------------------------------------------------\r\n\r\n\r\n\tgetEventDefByUid: function(uid) {\r\n\t\tif (this.currentPeriod) {\r\n\t\t\treturn this.currentPeriod.getEventDefByUid(uid);\r\n\t\t}\r\n\t},\r\n\r\n\r\n\taddEventDef: function(eventDef, isSticky) {\r\n\t\tif (isSticky) {\r\n\t\t\tthis.stickySource.addEventDef(eventDef);\r\n\t\t}\r\n\r\n\t\tif (this.currentPeriod) {\r\n\t\t\tthis.currentPeriod.addEventDef(eventDef); // might release\r\n\t\t}\r\n\t},\r\n\r\n\r\n\tremoveEventDefsById: function(eventId) {\r\n\t\tthis.getSources().forEach(function(eventSource) {\r\n\t\t\teventSource.removeEventDefsById(eventId);\r\n\t\t});\r\n\r\n\t\tif (this.currentPeriod) {\r\n\t\t\tthis.currentPeriod.removeEventDefsById(eventId); // might release\r\n\t\t}\r\n\t},\r\n\r\n\r\n\tremoveAllEventDefs: function() {\r\n\t\tthis.getSources().forEach(function(eventSource) {\r\n\t\t\teventSource.removeAllEventDefs();\r\n\t\t});\r\n\r\n\t\tif (this.currentPeriod) {\r\n\t\t\tthis.currentPeriod.removeAllEventDefs();\r\n\t\t}\r\n\t},\r\n\r\n\r\n\t// Event Mutating\r\n\t// -----------------------------------------------------------------------------------------------------------------\r\n\r\n\r\n\t/*\r\n\tReturns an undo function.\r\n\t*/\r\n\tmutateEventsWithId: function(eventDefId, eventDefMutation) {\r\n\t\tvar currentPeriod = this.currentPeriod;\r\n\t\tvar eventDefs;\r\n\t\tvar undoFuncs = [];\r\n\r\n\t\tif (currentPeriod) {\r\n\r\n\t\t\tcurrentPeriod.freeze();\r\n\r\n\t\t\teventDefs = currentPeriod.getEventDefsById(eventDefId);\r\n\t\t\teventDefs.forEach(function(eventDef) {\r\n\t\t\t\t// add/remove esp because id might change\r\n\t\t\t\tcurrentPeriod.removeEventDef(eventDef);\r\n\t\t\t\tundoFuncs.push(eventDefMutation.mutateSingle(eventDef));\r\n\t\t\t\tcurrentPeriod.addEventDef(eventDef);\r\n\t\t\t});\r\n\r\n\t\t\tcurrentPeriod.thaw();\r\n\r\n\t\t\treturn function() {\r\n\t\t\t\tcurrentPeriod.freeze();\r\n\r\n\t\t\t\tfor (var i = 0; i < eventDefs.length; i++) {\r\n\t\t\t\t\tcurrentPeriod.removeEventDef(eventDefs[i]);\r\n\t\t\t\t\tundoFuncs[i]();\r\n\t\t\t\t\tcurrentPeriod.addEventDef(eventDefs[i]);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tcurrentPeriod.thaw();\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\treturn function() { };\r\n\t},\r\n\r\n\r\n\t/*\r\n\tcopies and then mutates\r\n\t*/\r\n\tbuildMutatedEventInstanceGroup: function(eventDefId, eventDefMutation) {\r\n\t\tvar eventDefs = this.getEventDefsById(eventDefId);\r\n\t\tvar i;\r\n\t\tvar defCopy;\r\n\t\tvar allInstances = [];\r\n\r\n\t\tfor (i = 0; i < eventDefs.length; i++) {\r\n\t\t\tdefCopy = eventDefs[i].clone();\r\n\r\n\t\t\tif (defCopy instanceof SingleEventDef) {\r\n\t\t\t\teventDefMutation.mutateSingle(defCopy);\r\n\r\n\t\t\t\tallInstances.push.apply(allInstances, // append\r\n\t\t\t\t\tdefCopy.buildInstances()\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn new EventInstanceGroup(allInstances);\r\n\t},\r\n\r\n\r\n\t// Freezing\r\n\t// -----------------------------------------------------------------------------------------------------------------\r\n\r\n\r\n\tfreeze: function() {\r\n\t\tif (this.currentPeriod) {\r\n\t\t\tthis.currentPeriod.freeze();\r\n\t\t}\r\n\t},\r\n\r\n\r\n\tthaw: function() {\r\n\t\tif (this.currentPeriod) {\r\n\t\t\tthis.currentPeriod.thaw();\r\n\t\t}\r\n\t}\r\n\r\n});\r\n\r\n\r\n// Methods that straight-up query the current EventPeriod for an array of results.\r\n[\r\n\t'getEventDefsById',\r\n\t'getEventInstances',\r\n\t'getEventInstancesWithId',\r\n\t'getEventInstancesWithoutId'\r\n].forEach(function(methodName) {\r\n\r\n\tEventManager.prototype[methodName] = function() {\r\n\t\tvar currentPeriod = this.currentPeriod;\r\n\r\n\t\tif (currentPeriod) {\r\n\t\t\treturn currentPeriod[methodName].apply(currentPeriod, arguments);\r\n\t\t}\r\n\r\n\t\treturn [];\r\n\t};\r\n});\r\n\r\n\r\nfunction isSourcesEquivalent(source0, source1) {\r\n\treturn source0.getPrimitive() == source1.getPrimitive();\r\n}\r\n\r\n;;\r\n\r\nvar BUSINESS_HOUR_EVENT_DEFAULTS = {\r\n\tstart: '09:00',\r\n\tend: '17:00',\r\n\tdow: [ 1, 2, 3, 4, 5 ], // monday - friday\r\n\trendering: 'inverse-background'\r\n\t// classNames are defined in businessHoursSegClasses\r\n};\r\n\r\n\r\nvar BusinessHourGenerator = FC.BusinessHourGenerator = Class.extend({\r\n\r\n\trawComplexDef: null,\r\n\tcalendar: null, // for anonymous EventSource\r\n\r\n\r\n\tconstructor: function(rawComplexDef, calendar) {\r\n\t\tthis.rawComplexDef = rawComplexDef;\r\n\t\tthis.calendar = calendar;\r\n\t},\r\n\r\n\r\n\tbuildEventInstanceGroup: function(isAllDay, unzonedRange) {\r\n\t\tvar eventDefs = this.buildEventDefs(isAllDay);\r\n\t\tvar eventInstanceGroup;\r\n\r\n\t\tif (eventDefs.length) {\r\n\t\t\teventInstanceGroup = new EventInstanceGroup(\r\n\t\t\t\teventDefsToEventInstances(eventDefs, unzonedRange)\r\n\t\t\t);\r\n\r\n\t\t\t// so that inverse-background rendering can happen even when no eventRanges in view\r\n\t\t\teventInstanceGroup.explicitEventDef = eventDefs[0];\r\n\r\n\t\t\treturn eventInstanceGroup;\r\n\t\t}\r\n\t},\r\n\r\n\r\n\tbuildEventDefs: function(isAllDay) {\r\n\t\tvar rawComplexDef = this.rawComplexDef;\r\n\t\tvar rawDefs = [];\r\n\t\tvar requireDow = false;\r\n\t\tvar i;\r\n\t\tvar defs = [];\r\n\r\n\t\tif (rawComplexDef === true) {\r\n\t\t\trawDefs = [ {} ]; // will get BUSINESS_HOUR_EVENT_DEFAULTS verbatim\r\n\t\t}\r\n\t\telse if ($.isPlainObject(rawComplexDef)) {\r\n\t\t\trawDefs = [ rawComplexDef ];\r\n\t\t}\r\n\t\telse if ($.isArray(rawComplexDef)) {\r\n\t\t\trawDefs = rawComplexDef;\r\n\t\t\trequireDow = true; // every sub-definition NEEDS a day-of-week\r\n\t\t}\r\n\r\n\t\tfor (i = 0; i < rawDefs.length; i++) {\r\n\t\t\tif (!requireDow || rawDefs[i].dow) {\r\n\t\t\t\tdefs.push(\r\n\t\t\t\t\tthis.buildEventDef(isAllDay, rawDefs[i])\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn defs;\r\n\t},\r\n\r\n\r\n\tbuildEventDef: function(isAllDay, rawDef) {\r\n\t\tvar fullRawDef = $.extend({}, BUSINESS_HOUR_EVENT_DEFAULTS, rawDef);\r\n\r\n\t\tif (isAllDay) {\r\n\t\t\tfullRawDef.start = null;\r\n\t\t\tfullRawDef.end = null;\r\n\t\t}\r\n\r\n\t\treturn RecurringEventDef.parse(\r\n\t\t\tfullRawDef,\r\n\t\t\tnew EventSource(this.calendar) // dummy source\r\n\t\t);\r\n\t}\r\n\r\n});\r\n\r\n;;\r\n\r\nvar EventDefParser = {\r\n\r\n\tparse: function(eventInput, source) {\r\n\t\tif (\r\n\t\t\tisTimeString(eventInput.start) || moment.isDuration(eventInput.start) ||\r\n\t\t\tisTimeString(eventInput.end) || moment.isDuration(eventInput.end)\r\n\t\t) {\r\n\t\t\treturn RecurringEventDef.parse(eventInput, source);\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn SingleEventDef.parse(eventInput, source);\r\n\t\t}\r\n\t}\r\n\r\n};\r\n\r\n;;\r\n\r\nvar EventDef = FC.EventDef = Class.extend(ParsableModelMixin, {\r\n\r\n\tsource: null, // required\r\n\r\n\tid: null, // normalized supplied ID\r\n\trawId: null, // unnormalized supplied ID\r\n\tuid: null, // internal ID. new ID for every definition\r\n\r\n\t// NOTE: eventOrder sorting relies on these\r\n\ttitle: null,\r\n\turl: null,\r\n\trendering: null,\r\n\tconstraint: null,\r\n\toverlap: null,\r\n\teditable: null,\r\n\tstartEditable: null,\r\n\tdurationEditable: null,\r\n\tcolor: null,\r\n\tbackgroundColor: null,\r\n\tborderColor: null,\r\n\ttextColor: null,\r\n\r\n\tclassName: null, // an array. TODO: rename to className*s* (API breakage)\r\n\tmiscProps: null,\r\n\r\n\r\n\tconstructor: function(source) {\r\n\t\tthis.source = source;\r\n\t\tthis.className = [];\r\n\t\tthis.miscProps = {};\r\n\t},\r\n\r\n\r\n\tisAllDay: function() {\r\n\t\t// subclasses must implement\r\n\t},\r\n\r\n\r\n\tbuildInstances: function(unzonedRange) {\r\n\t\t// subclasses must implement\r\n\t},\r\n\r\n\r\n\tclone: function() {\r\n\t\tvar copy = new this.constructor(this.source);\r\n\r\n\t\tcopy.id = this.id;\r\n\t\tcopy.rawId = this.rawId;\r\n\t\tcopy.uid = this.uid; // not really unique anymore :(\r\n\r\n\t\tEventDef.copyVerbatimStandardProps(this, copy);\r\n\r\n\t\tcopy.className = this.className.slice(); // copy\r\n\t\tcopy.miscProps = $.extend({}, this.miscProps);\r\n\r\n\t\treturn copy;\r\n\t},\r\n\r\n\r\n\thasInverseRendering: function() {\r\n\t\treturn this.getRendering() === 'inverse-background';\r\n\t},\r\n\r\n\r\n\thasBgRendering: function() {\r\n\t\tvar rendering = this.getRendering();\r\n\r\n\t\treturn rendering === 'inverse-background' || rendering === 'background';\r\n\t},\r\n\r\n\r\n\tgetRendering: function() {\r\n\t\tif (this.rendering != null) {\r\n\t\t\treturn this.rendering;\r\n\t\t}\r\n\r\n\t\treturn this.source.rendering;\r\n\t},\r\n\r\n\r\n\tgetConstraint: function() {\r\n\t\tif (this.constraint != null) {\r\n\t\t\treturn this.constraint;\r\n\t\t}\r\n\r\n\t\tif (this.source.constraint != null) {\r\n\t\t\treturn this.source.constraint;\r\n\t\t}\r\n\r\n\t\treturn this.source.calendar.opt('eventConstraint'); // what about View option?\r\n\t},\r\n\r\n\r\n\tgetOverlap: function() {\r\n\t\tif (this.overlap != null) {\r\n\t\t\treturn this.overlap;\r\n\t\t}\r\n\r\n\t\tif (this.source.overlap != null) {\r\n\t\t\treturn this.source.overlap;\r\n\t\t}\r\n\r\n\t\treturn this.source.calendar.opt('eventOverlap'); // what about View option?\r\n\t},\r\n\r\n\r\n\tisStartExplicitlyEditable: function() {\r\n\t\tif (this.startEditable !== null) {\r\n\t\t\treturn this.startEditable;\r\n\t\t}\r\n\r\n\t\treturn this.source.startEditable;\r\n\t},\r\n\r\n\r\n\tisDurationExplicitlyEditable: function() {\r\n\t\tif (this.durationEditable !== null) {\r\n\t\t\treturn this.durationEditable;\r\n\t\t}\r\n\r\n\t\treturn this.source.durationEditable;\r\n\t},\r\n\r\n\r\n\tisExplicitlyEditable: function() {\r\n\t\tif (this.editable !== null) {\r\n\t\t\treturn this.editable;\r\n\t\t}\r\n\r\n\t\treturn this.source.editable;\r\n\t},\r\n\r\n\r\n\ttoLegacy: function() {\r\n\t\tvar obj = $.extend({}, this.miscProps);\r\n\r\n\t\tobj._id = this.uid;\r\n\t\tobj.source = this.source;\r\n\t\tobj.className = this.className.slice(); // copy\r\n\t\tobj.allDay = this.isAllDay();\r\n\r\n\t\tif (this.rawId != null) {\r\n\t\t\tobj.id = this.rawId;\r\n\t\t}\r\n\r\n\t\tEventDef.copyVerbatimStandardProps(this, obj);\r\n\r\n\t\treturn obj;\r\n\t},\r\n\r\n\r\n\tapplyManualStandardProps: function(rawProps) {\r\n\r\n\t\tif (rawProps.id != null) {\r\n\t\t\tthis.id = EventDef.normalizeId((this.rawId = rawProps.id));\r\n\t\t}\r\n\t\telse {\r\n\t\t\tthis.id = EventDef.generateId();\r\n\t\t}\r\n\r\n\t\tif (rawProps._id != null) { // accept this prop, even tho somewhat internal\r\n\t\t\tthis.uid = String(rawProps._id);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tthis.uid = EventDef.generateId();\r\n\t\t}\r\n\r\n\t\t// TODO: converge with EventSource\r\n\t\tif ($.isArray(rawProps.className)) {\r\n\t\t\tthis.className = rawProps.className;\r\n\t\t}\r\n\t\tif (typeof rawProps.className === 'string') {\r\n\t\t\tthis.className = rawProps.className.split(/\\s+/);\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\t},\r\n\r\n\r\n\tapplyMiscProps: function(rawProps) {\r\n\t\t$.extend(this.miscProps, rawProps);\r\n\t}\r\n\r\n});\r\n\r\n// finish initializing the mixin\r\nEventDef.defineStandardProps = ParsableModelMixin_defineStandardProps;\r\nEventDef.copyVerbatimStandardProps = ParsableModelMixin_copyVerbatimStandardProps;\r\n\r\n\r\n// IDs\r\n// ---------------------------------------------------------------------------------------------------------------------\r\n// TODO: converge with EventSource\r\n\r\n\r\nEventDef.uuid = 0;\r\n\r\n\r\nEventDef.normalizeId = function(id) {\r\n\treturn String(id);\r\n};\r\n\r\n\r\nEventDef.generateId = function() {\r\n\treturn '_fc' + (EventDef.uuid++);\r\n};\r\n\r\n\r\n// Parsing\r\n// ---------------------------------------------------------------------------------------------------------------------\r\n\r\n\r\nEventDef.defineStandardProps({\r\n\t// not automatically assigned (`false`)\r\n\t_id: false,\r\n\tid: false,\r\n\tclassName: false,\r\n\tsource: false, // will ignored\r\n\r\n\t// automatically assigned (`true`)\r\n\ttitle: true,\r\n\turl: true,\r\n\trendering: true,\r\n\tconstraint: true,\r\n\toverlap: true,\r\n\teditable: true,\r\n\tstartEditable: true,\r\n\tdurationEditable: true,\r\n\tcolor: true,\r\n\tbackgroundColor: true,\r\n\tborderColor: true,\r\n\ttextColor: true\r\n});\r\n\r\n\r\nEventDef.parse = function(rawInput, source) {\r\n\tvar def = new this(source);\r\n\tvar calendarTransform = source.calendar.opt('eventDataTransform');\r\n\tvar sourceTransform = source.eventDataTransform;\r\n\r\n\tif (calendarTransform) {\r\n\t\trawInput = calendarTransform(rawInput);\r\n\t}\r\n\tif (sourceTransform) {\r\n\t\trawInput = sourceTransform(rawInput);\r\n\t}\r\n\r\n\tif (def.applyProps(rawInput)) {\r\n\t\treturn def;\r\n\t}\r\n\r\n\treturn false;\r\n};\r\n\r\n;;\r\n\r\nvar SingleEventDef = EventDef.extend({\r\n\r\n\tdateProfile: null,\r\n\r\n\r\n\t/*\r\n\tWill receive start/end params, but will be ignored.\r\n\t*/\r\n\tbuildInstances: function() {\r\n\t\treturn [ this.buildInstance() ];\r\n\t},\r\n\r\n\r\n\tbuildInstance: function() {\r\n\t\treturn new EventInstance(\r\n\t\t\tthis, // definition\r\n\t\t\tthis.dateProfile\r\n\t\t);\r\n\t},\r\n\r\n\r\n\tisAllDay: function() {\r\n\t\treturn this.dateProfile.isAllDay();\r\n\t},\r\n\r\n\r\n\tclone: function() {\r\n\t\tvar def = EventDef.prototype.clone.call(this);\r\n\r\n\t\tdef.dateProfile = this.dateProfile;\r\n\r\n\t\treturn def;\r\n\t},\r\n\r\n\r\n\trezone: function() {\r\n\t\tvar calendar = this.source.calendar;\r\n\t\tvar dateProfile = this.dateProfile;\r\n\r\n\t\tthis.dateProfile = new EventDateProfile(\r\n\t\t\tcalendar.moment(dateProfile.start),\r\n\t\t\tdateProfile.end ? calendar.moment(dateProfile.end) : null,\r\n\t\t\tcalendar\r\n\t\t);\r\n\t},\r\n\r\n\r\n\t/*\r\n\tNOTE: if super-method fails, should still attempt to apply\r\n\t*/\r\n\tapplyManualStandardProps: function(rawProps) {\r\n\t\tvar superSuccess = EventDef.prototype.applyManualStandardProps.apply(this, arguments);\r\n\t\tvar dateProfile = EventDateProfile.parse(rawProps, this.source); // returns null on failure\r\n\r\n\t\tif (dateProfile) {\r\n\t\t\tthis.dateProfile = dateProfile;\r\n\r\n\t\t\t// make sure `date` shows up in the legacy event objects as-is\r\n\t\t\tif (rawProps.date != null) {\r\n\t\t\t\tthis.miscProps.date = rawProps.date;\r\n\t\t\t}\r\n\r\n\t\t\treturn superSuccess;\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\r\n});\r\n\r\n\r\n// Parsing\r\n// ---------------------------------------------------------------------------------------------------------------------\r\n\r\n\r\nSingleEventDef.defineStandardProps({ // false = manually process\r\n\tstart: false,\r\n\tdate: false, // alias for 'start'\r\n\tend: false,\r\n\tallDay: false\r\n});\r\n\r\n;;\r\n\r\nvar RecurringEventDef = EventDef.extend({\r\n\r\n\tstartTime: null, // duration\r\n\tendTime: null, // duration, or null\r\n\tdowHash: null, // object hash, or null\r\n\r\n\r\n\tisAllDay: function() {\r\n\t\treturn !this.startTime && !this.endTime;\r\n\t},\r\n\r\n\r\n\tbuildInstances: function(unzonedRange) {\r\n\t\tvar calendar = this.source.calendar;\r\n\t\tvar unzonedDate = unzonedRange.getStart();\r\n\t\tvar unzonedEnd = unzonedRange.getEnd();\r\n\t\tvar zonedDayStart;\r\n\t\tvar instanceStart, instanceEnd;\r\n\t\tvar instances = [];\r\n\r\n\t\twhile (unzonedDate.isBefore(unzonedEnd)) {\r\n\r\n\t\t\t// if everyday, or this particular day-of-week\r\n\t\t\tif (!this.dowHash || this.dowHash[unzonedDate.day()]) {\r\n\r\n\t\t\t\tzonedDayStart = calendar.applyTimezone(unzonedDate);\r\n\t\t\t\tinstanceStart = zonedDayStart.clone();\r\n\t\t\t\tinstanceEnd = null;\r\n\r\n\t\t\t\tif (this.startTime) {\r\n\t\t\t\t\tinstanceStart.time(this.startTime);\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tinstanceStart.stripTime();\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (this.endTime) {\r\n\t\t\t\t\tinstanceEnd = zonedDayStart.clone().time(this.endTime);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tinstances.push(\r\n\t\t\t\t\tnew EventInstance(\r\n\t\t\t\t\t\tthis, // definition\r\n\t\t\t\t\t\tnew EventDateProfile(instanceStart, instanceEnd, calendar)\r\n\t\t\t\t\t)\r\n\t\t\t\t);\r\n\t\t\t}\r\n\r\n\t\t\tunzonedDate.add(1, 'days');\r\n\t\t}\r\n\r\n\t\treturn instances;\r\n\t},\r\n\r\n\r\n\tsetDow: function(dowNumbers) {\r\n\r\n\t\tif (!this.dowHash) {\r\n\t\t\tthis.dowHash = {};\r\n\t\t}\r\n\r\n\t\tfor (var i = 0; i < dowNumbers.length; i++) {\r\n\t\t\tthis.dowHash[dowNumbers[i]] = true;\r\n\t\t}\r\n\t},\r\n\r\n\r\n\tclone: function() {\r\n\t\tvar def = EventDef.prototype.clone.call(this);\r\n\r\n\t\tif (def.startTime) {\r\n\t\t\tdef.startTime = moment.duration(this.startTime);\r\n\t\t}\r\n\r\n\t\tif (def.endTime) {\r\n\t\t\tdef.endTime = moment.duration(this.endTime);\r\n\t\t}\r\n\r\n\t\tif (this.dowHash) {\r\n\t\t\tdef.dowHash = $.extend({}, this.dowHash);\r\n\t\t}\r\n\r\n\t\treturn def;\r\n\t},\r\n\r\n\r\n\t/*\r\n\tNOTE: if super-method fails, should still attempt to apply\r\n\t*/\r\n\tapplyProps: function(rawProps) {\r\n\t\tvar superSuccess = EventDef.prototype.applyProps.apply(this, arguments);\r\n\r\n\t\tif (rawProps.start) {\r\n\t\t\tthis.startTime = moment.duration(rawProps.start);\r\n\t\t}\r\n\r\n\t\tif (rawProps.end) {\r\n\t\t\tthis.endTime = moment.duration(rawProps.end);\r\n\t\t}\r\n\r\n\t\tif (rawProps.dow) {\r\n\t\t\tthis.setDow(rawProps.dow);\r\n\t\t}\r\n\r\n\t\treturn superSuccess;\r\n\t}\r\n\r\n});\r\n\r\n\r\n// Parsing\r\n// ---------------------------------------------------------------------------------------------------------------------\r\n\r\n\r\nRecurringEventDef.defineStandardProps({ // false = manually process\r\n\tstart: false,\r\n\tend: false,\r\n\tdow: false\r\n});\r\n\r\n;;\r\n\r\nvar EventInstance = Class.extend({\r\n\r\n\tdef: null, // EventDef\r\n\tdateProfile: null, // EventDateProfile\r\n\r\n\r\n\tconstructor: function(def, dateProfile) {\r\n\t\tthis.def = def;\r\n\t\tthis.dateProfile = dateProfile;\r\n\t},\r\n\r\n\r\n\ttoLegacy: function() {\r\n\t\tvar dateProfile = this.dateProfile;\r\n\t\tvar obj = this.def.toLegacy();\r\n\r\n\t\tobj.start = dateProfile.start.clone();\r\n\t\tobj.end = dateProfile.end ? dateProfile.end.clone() : null;\r\n\r\n\t\treturn obj;\r\n\t}\r\n\r\n});\r\n\r\n;;\r\n\r\n/*\r\nIt's expected that there will be at least one EventInstance,\r\nOR that an explicitEventDef is assigned.\r\n*/\r\nvar EventInstanceGroup = FC.EventInstanceGroup = Class.extend({\r\n\r\n\teventInstances: null,\r\n\texplicitEventDef: null, // optional\r\n\r\n\r\n\tconstructor: function(eventInstances) {\r\n\t\tthis.eventInstances = eventInstances || [];\r\n\t},\r\n\r\n\r\n\tgetAllEventRanges: function(constraintRange) {\r\n\t\tif (constraintRange) {\r\n\t\t\treturn this.sliceNormalRenderRanges(constraintRange);\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn this.eventInstances.map(eventInstanceToEventRange);\r\n\t\t}\r\n\t},\r\n\r\n\r\n\tsliceRenderRanges: function(constraintRange) {\r\n\t\tif (this.isInverse()) {\r\n\t\t\treturn this.sliceInverseRenderRanges(constraintRange);\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn this.sliceNormalRenderRanges(constraintRange);\r\n\t\t}\r\n\t},\r\n\r\n\r\n\tsliceNormalRenderRanges: function(constraintRange) {\r\n\t\tvar eventInstances = this.eventInstances;\r\n\t\tvar i, eventInstance;\r\n\t\tvar slicedRange;\r\n\t\tvar slicedEventRanges = [];\r\n\r\n\t\tfor (i = 0; i < eventInstances.length; i++) {\r\n\t\t\teventInstance = eventInstances[i];\r\n\r\n\t\t\tslicedRange = eventInstance.dateProfile.unzonedRange.intersect(constraintRange);\r\n\r\n\t\t\tif (slicedRange) {\r\n\t\t\t\tslicedEventRanges.push(\r\n\t\t\t\t\tnew EventRange(\r\n\t\t\t\t\t\tslicedRange,\r\n\t\t\t\t\t\teventInstance.def,\r\n\t\t\t\t\t\teventInstance\r\n\t\t\t\t\t)\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn slicedEventRanges;\r\n\t},\r\n\r\n\r\n\tsliceInverseRenderRanges: function(constraintRange) {\r\n\t\tvar unzonedRanges = this.eventInstances.map(eventInstanceToUnzonedRange);\r\n\t\tvar ownerDef = this.getEventDef();\r\n\r\n\t\tunzonedRanges = invertUnzonedRanges(unzonedRanges, constraintRange);\r\n\r\n\t\treturn unzonedRanges.map(function(unzonedRange) {\r\n\t\t\treturn new EventRange(unzonedRange, ownerDef); // don't give an EventInstance\r\n\t\t});\r\n\t},\r\n\r\n\r\n\tisInverse: function() {\r\n\t\treturn this.getEventDef().hasInverseRendering();\r\n\t},\r\n\r\n\r\n\tgetEventDef: function() {\r\n\t\treturn this.explicitEventDef || this.eventInstances[0].def;\r\n\t}\r\n\r\n});\r\n\r\n;;\r\n\r\n/*\r\nMeant to be immutable\r\n*/\r\nvar EventDateProfile = Class.extend({\r\n\r\n\tstart: null,\r\n\tend: null,\r\n\tunzonedRange: null,\r\n\r\n\r\n\tconstructor: function(start, end, calendar) {\r\n\t\tthis.start = start;\r\n\t\tthis.end = end || null;\r\n\t\tthis.unzonedRange = this.buildUnzonedRange(calendar);\r\n\t},\r\n\r\n\r\n\tisAllDay: function() { // why recompute this every time?\r\n\t\treturn !(this.start.hasTime() || (this.end && this.end.hasTime()));\r\n\t},\r\n\r\n\r\n\t/*\r\n\tNeeds a Calendar object\r\n\t*/\r\n\tbuildUnzonedRange: function(calendar) {\r\n\t\tvar startMs = this.start.clone().stripZone().valueOf();\r\n\t\tvar endMs = this.getEnd(calendar).stripZone().valueOf();\r\n\r\n\t\treturn new UnzonedRange(startMs, endMs);\r\n\t},\r\n\r\n\r\n\t/*\r\n\tNeeds a Calendar object\r\n\t*/\r\n\tgetEnd: function(calendar) {\r\n\t\treturn this.end ?\r\n\t\t\tthis.end.clone() :\r\n\t\t\t// derive the end from the start and allDay. compute allDay if necessary\r\n\t\t\tcalendar.getDefaultEventEnd(\r\n\t\t\t\tthis.isAllDay(),\r\n\t\t\t\tthis.start\r\n\t\t\t);\r\n\t}\r\n\r\n});\r\n\r\n\r\nEventDateProfile.isStandardProp = function(propName) {\r\n\treturn propName === 'start' || propName === 'date' || propName === 'end' || propName === 'allDay';\r\n};\r\n\r\n\r\n/*\r\nNeeds an EventSource object\r\n*/\r\nEventDateProfile.parse = function(rawProps, source) {\r\n\tvar startInput = rawProps.start || rawProps.date;\r\n\tvar endInput = rawProps.end;\r\n\r\n\tif (!startInput) {\r\n\t\treturn false;\r\n\t}\r\n\r\n\tvar calendar = source.calendar;\r\n\tvar start = calendar.moment(startInput);\r\n\tvar end = endInput ? calendar.moment(endInput) : null;\r\n\tvar forcedAllDay = rawProps.allDay;\r\n\tvar forceEventDuration = calendar.opt('forceEventDuration');\r\n\r\n\tif (!start.isValid()) {\r\n\t\treturn false;\r\n\t}\r\n\r\n\tif (end && (!end.isValid() || !end.isAfter(start))) {\r\n\t\tend = null;\r\n\t}\r\n\r\n\tif (forcedAllDay == null) {\r\n\t\tforcedAllDay = source.allDayDefault;\r\n\t\tif (forcedAllDay == null) {\r\n\t\t\tforcedAllDay = calendar.opt('allDayDefault');\r\n\t\t}\r\n\t}\r\n\r\n\tif (forcedAllDay === true) {\r\n\t\tstart.stripTime();\r\n\t\tif (end) {\r\n\t\t\tend.stripTime();\r\n\t\t}\r\n\t}\r\n\telse if (forcedAllDay === false) {\r\n\t\tif (!start.hasTime()) {\r\n\t\t\tstart.time(0);\r\n\t\t}\r\n\t\tif (end && !end.hasTime()) {\r\n\t\t\tend.time(0);\r\n\t\t}\r\n\t}\r\n\r\n\tif (!end && forceEventDuration) {\r\n\t\tend = calendar.getDefaultEventEnd(!start.hasTime(), start);\r\n\t}\r\n\r\n\treturn new EventDateProfile(start, end, calendar);\r\n};\r\n\r\n;;\r\n\r\nvar EventRange = Class.extend({\r\n\r\n\tunzonedRange: null,\r\n\teventDef: null,\r\n\teventInstance: null, // optional\r\n\r\n\r\n\tconstructor: function(unzonedRange, eventDef, eventInstance) {\r\n\t\tthis.unzonedRange = unzonedRange;\r\n\t\tthis.eventDef = eventDef;\r\n\r\n\t\tif (eventInstance) {\r\n\t\t\tthis.eventInstance = eventInstance;\r\n\t\t}\r\n\t}\r\n\r\n});\r\n\r\n;;\r\n\r\nvar EventFootprint = FC.EventFootprint = Class.extend({\r\n\r\n\tcomponentFootprint: null,\r\n\teventDef: null,\r\n\teventInstance: null, // optional\r\n\r\n\r\n\tconstructor: function(componentFootprint, eventDef, eventInstance) {\r\n\t\tthis.componentFootprint = componentFootprint;\r\n\t\tthis.eventDef = eventDef;\r\n\r\n\t\tif (eventInstance) {\r\n\t\t\tthis.eventInstance = eventInstance;\r\n\t\t}\r\n\t},\r\n\r\n\r\n\tgetEventLegacy: function() {\r\n\t\treturn (this.eventInstance || this.eventDef).toLegacy();\r\n\t}\r\n\r\n});\r\n\r\n;;\r\n\r\nvar EventDefMutation = FC.EventDefMutation = Class.extend({\r\n\r\n\t// won't ever be empty. will be null instead.\r\n\t// callers should use setDateMutation for setting.\r\n\tdateMutation: null,\r\n\r\n\t// hacks to get updateEvent/createFromRawProps to work.\r\n\t// not undo-able and not considered in isEmpty.\r\n\teventDefId: null, // standard manual props\r\n\tclassName: null, // \"\r\n\tverbatimStandardProps: null,\r\n\tmiscProps: null,\r\n\r\n\r\n\t/*\r\n\teventDef assumed to be a SingleEventDef.\r\n\treturns an undo function.\r\n\t*/\r\n\tmutateSingle: function(eventDef) {\r\n\t\tvar origDateProfile;\r\n\r\n\t\tif (this.dateMutation) {\r\n\t\t\torigDateProfile = eventDef.dateProfile;\r\n\r\n\t\t\teventDef.dateProfile = this.dateMutation.buildNewDateProfile(\r\n\t\t\t\torigDateProfile,\r\n\t\t\t\teventDef.source.calendar\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\t// can't undo\r\n\t\t// TODO: more DRY with EventDef::applyManualStandardProps\r\n\t\tif (this.eventDefId != null) {\r\n\t\t\teventDef.id = EventDef.normalizeId((eventDef.rawId = this.eventDefId));\r\n\t\t}\r\n\r\n\t\t// can't undo\r\n\t\t// TODO: more DRY with EventDef::applyManualStandardProps\r\n\t\tif (this.className) {\r\n\t\t\teventDef.className = this.className;\r\n\t\t}\r\n\r\n\t\t// can't undo\r\n\t\tif (this.verbatimStandardProps) {\r\n\t\t\tSingleEventDef.copyVerbatimStandardProps(\r\n\t\t\t\tthis.verbatimStandardProps, // src\r\n\t\t\t\teventDef // dest\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\t// can't undo\r\n\t\tif (this.miscProps) {\r\n\t\t\teventDef.applyMiscProps(this.miscProps);\r\n\t\t}\r\n\r\n\t\tif (origDateProfile) {\r\n\t\t\treturn function() {\r\n\t\t\t\teventDef.dateProfile = origDateProfile;\r\n\t\t\t};\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn function() { };\r\n\t\t}\r\n\t},\r\n\r\n\r\n\tsetDateMutation: function(dateMutation) {\r\n\t\tif (dateMutation && !dateMutation.isEmpty()) {\r\n\t\t\tthis.dateMutation = dateMutation;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tthis.dateMutation = null;\r\n\t\t}\r\n\t},\r\n\r\n\r\n\tisEmpty: function() {\r\n\t\treturn !this.dateMutation;\r\n\t}\r\n\r\n});\r\n\r\n\r\nEventDefMutation.createFromRawProps = function(eventInstance, rawProps, largeUnit) {\r\n\tvar eventDef = eventInstance.def;\r\n\tvar dateProps = {};\r\n\tvar standardProps = {};\r\n\tvar miscProps = {};\r\n\tvar verbatimStandardProps = {};\r\n\tvar eventDefId = null;\r\n\tvar className = null;\r\n\tvar propName;\r\n\tvar dateProfile;\r\n\tvar dateMutation;\r\n\tvar defMutation;\r\n\r\n\tfor (propName in rawProps) {\r\n\t\tif (EventDateProfile.isStandardProp(propName)) {\r\n\t\t\tdateProps[propName] = rawProps[propName];\r\n\t\t}\r\n\t\telse if (eventDef.isStandardProp(propName)) {\r\n\t\t\tstandardProps[propName] = rawProps[propName];\r\n\t\t}\r\n\t\telse if (eventDef.miscProps[propName] !== rawProps[propName]) { // only if changed\r\n\t\t\tmiscProps[propName] = rawProps[propName];\r\n\t\t}\r\n\t}\r\n\r\n\tdateProfile = EventDateProfile.parse(dateProps, eventDef.source);\r\n\r\n\tif (dateProfile) { // no failure?\r\n\t\tdateMutation = EventDefDateMutation.createFromDiff(\r\n\t\t\teventInstance.dateProfile,\r\n\t\t\tdateProfile,\r\n\t\t\tlargeUnit\r\n\t\t);\r\n\t}\r\n\r\n\tif (standardProps.id !== eventDef.id) {\r\n\t\teventDefId = standardProps.id; // only apply if there's a change\r\n\t}\r\n\r\n\tif (!isArraysEqual(standardProps.className, eventDef.className)) {\r\n\t\tclassName = standardProps.className; // only apply if there's a change\r\n\t}\r\n\r\n\tEventDef.copyVerbatimStandardProps(\r\n\t\tstandardProps, // src\r\n\t\tverbatimStandardProps // dest\r\n\t);\r\n\r\n\tdefMutation = new EventDefMutation();\r\n\tdefMutation.eventDefId = eventDefId;\r\n\tdefMutation.className = className;\r\n\tdefMutation.verbatimStandardProps = verbatimStandardProps;\r\n\tdefMutation.miscProps = miscProps;\r\n\r\n\tif (dateMutation) {\r\n\t\tdefMutation.dateMutation = dateMutation;\r\n\t}\r\n\r\n\treturn defMutation;\r\n};\r\n\r\n;;\r\n\r\nvar EventDefDateMutation = Class.extend({\r\n\r\n\tclearEnd: false,\r\n\tforceTimed: false,\r\n\tforceAllDay: false,\r\n\r\n\t// Durations. if 0-ms duration, will be null instead.\r\n\t// Callers should not set this directly.\r\n\tdateDelta: null,\r\n\tstartDelta: null,\r\n\tendDelta: null,\r\n\r\n\r\n\t/*\r\n\treturns an undo function.\r\n\t*/\r\n\tbuildNewDateProfile: function(eventDateProfile, calendar) {\r\n\t\tvar start = eventDateProfile.start.clone();\r\n\t\tvar end = null;\r\n\t\tvar shouldRezone = false;\r\n\r\n\t\tif (eventDateProfile.end && !this.clearEnd) {\r\n\t\t\tend = eventDateProfile.end.clone();\r\n\t\t}\r\n\t\t// if there will be an end-date mutation, guarantee an end,\r\n\t\t// ambigously-zoned according to the original allDay\r\n\t\telse if (this.endDelta && !end) {\r\n\t\t\tend = calendar.getDefaultEventEnd(eventDateProfile.isAllDay(), start);\r\n\t\t}\r\n\r\n\t\tif (this.forceTimed) {\r\n\t\t\tshouldRezone = true;\r\n\r\n\t\t\tif (!start.hasTime()) {\r\n\t\t\t\tstart.time(0);\r\n\t\t\t}\r\n\r\n\t\t\tif (end && !end.hasTime()) {\r\n\t\t\t\tend.time(0);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if (this.forceAllDay) {\r\n\r\n\t\t\tif (start.hasTime()) {\r\n\t\t\t\tstart.stripTime();\r\n\t\t\t}\r\n\r\n\t\t\tif (end && end.hasTime()) {\r\n\t\t\t\tend.stripTime();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (this.dateDelta) {\r\n\t\t\tshouldRezone = true;\r\n\r\n\t\t\tstart.add(this.dateDelta);\r\n\r\n\t\t\tif (end) {\r\n\t\t\t\tend.add(this.dateDelta);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// do this before adding startDelta to start, so we can work off of start\r\n\t\tif (this.endDelta) {\r\n\t\t\tshouldRezone = true;\r\n\r\n\t\t\tend.add(this.endDelta);\r\n\t\t}\r\n\r\n\t\tif (this.startDelta) {\r\n\t\t\tshouldRezone = true;\r\n\r\n\t\t\tstart.add(this.startDelta);\r\n\t\t}\r\n\r\n\t\tif (shouldRezone) {\r\n\t\t\tstart = calendar.applyTimezone(start);\r\n\r\n\t\t\tif (end) {\r\n\t\t\t\tend = calendar.applyTimezone(end);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// TODO: okay to access calendar option?\r\n\t\tif (!end && calendar.opt('forceEventDuration')) {\r\n\t\t\tend = calendar.getDefaultEventEnd(eventDateProfile.isAllDay(), start);\r\n\t\t}\r\n\r\n\t\treturn new EventDateProfile(start, end, calendar);\r\n\t},\r\n\r\n\r\n\tsetDateDelta: function(dateDelta) {\r\n\t\tif (dateDelta && dateDelta.valueOf()) {\r\n\t\t\tthis.dateDelta = dateDelta;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tthis.dateDelta = null;\r\n\t\t}\r\n\t},\r\n\r\n\r\n\tsetStartDelta: function(startDelta) {\r\n\t\tif (startDelta && startDelta.valueOf()) {\r\n\t\t\tthis.startDelta = startDelta;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tthis.startDelta = null;\r\n\t\t}\r\n\t},\r\n\r\n\r\n\tsetEndDelta: function(endDelta) {\r\n\t\tif (endDelta && endDelta.valueOf()) {\r\n\t\t\tthis.endDelta = endDelta;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tthis.endDelta = null;\r\n\t\t}\r\n\t},\r\n\r\n\r\n\tisEmpty: function() {\r\n\t\treturn !this.clearEnd && !this.forceTimed && !this.forceAllDay &&\r\n\t\t\t!this.dateDelta && !this.startDelta && !this.endDelta;\r\n\t}\r\n\r\n});\r\n\r\n\r\nEventDefDateMutation.createFromDiff = function(dateProfile0, dateProfile1, largeUnit) {\r\n\tvar clearEnd = dateProfile0.end && !dateProfile1.end;\r\n\tvar forceTimed = dateProfile0.isAllDay() && !dateProfile1.isAllDay();\r\n\tvar forceAllDay = !dateProfile0.isAllDay() && dateProfile1.isAllDay();\r\n\tvar dateDelta;\r\n\tvar endDiff;\r\n\tvar endDelta;\r\n\tvar mutation;\r\n\r\n\t// subtracts the dates in the appropriate way, returning a duration\r\n\tfunction subtractDates(date1, date0) { // date1 - date0\r\n\t\tif (largeUnit) {\r\n\t\t\treturn diffByUnit(date1, date0, largeUnit); // poorly named\r\n\t\t}\r\n\t\telse if (dateProfile1.isAllDay()) {\r\n\t\t\treturn diffDay(date1, date0); // poorly named\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn diffDayTime(date1, date0); // poorly named\r\n\t\t}\r\n\t}\r\n\r\n\tdateDelta = subtractDates(dateProfile1.start, dateProfile0.start);\r\n\r\n\tif (dateProfile1.end) {\r\n\t\t// use unzonedRanges because dateProfile0.end might be null\r\n\t\tendDiff = subtractDates(\r\n\t\t\tdateProfile1.unzonedRange.getEnd(),\r\n\t\t\tdateProfile0.unzonedRange.getEnd()\r\n\t\t);\r\n\t\tendDelta = endDiff.subtract(dateDelta);\r\n\t}\r\n\r\n\tmutation = new EventDefDateMutation();\r\n\tmutation.clearEnd = clearEnd;\r\n\tmutation.forceTimed = forceTimed;\r\n\tmutation.forceAllDay = forceAllDay;\r\n\tmutation.setDateDelta(dateDelta);\r\n\tmutation.setEndDelta(endDelta);\r\n\r\n\treturn mutation;\r\n};\r\n\r\n;;\r\n\r\nfunction eventDefsToEventInstances(eventDefs, unzonedRange) {\r\n\tvar eventInstances = [];\r\n\tvar i;\r\n\r\n\tfor (i = 0; i < eventDefs.length; i++) {\r\n\t\teventInstances.push.apply(eventInstances, // append\r\n\t\t\teventDefs[i].buildInstances(unzonedRange)\r\n\t\t);\r\n\t}\r\n\r\n\treturn eventInstances;\r\n}\r\n\r\n\r\nfunction eventInstanceToEventRange(eventInstance) {\r\n\treturn new EventRange(\r\n\t\teventInstance.dateProfile.unzonedRange,\r\n\t\teventInstance.def,\r\n\t\teventInstance\r\n\t);\r\n}\r\n\r\n\r\nfunction eventRangeToEventFootprint(eventRange) {\r\n\treturn new EventFootprint(\r\n\t\tnew ComponentFootprint(\r\n\t\t\teventRange.unzonedRange,\r\n\t\t\teventRange.eventDef.isAllDay()\r\n\t\t),\r\n\t\teventRange.eventDef,\r\n\t\teventRange.eventInstance // might not exist\r\n\t);\r\n}\r\n\r\n\r\nfunction eventInstanceToUnzonedRange(eventInstance) {\r\n\treturn eventInstance.dateProfile.unzonedRange;\r\n}\r\n\r\n\r\nfunction eventFootprintToComponentFootprint(eventFootprint) {\r\n\treturn eventFootprint.componentFootprint;\r\n}\r\n\r\n;;\r\n\r\nvar EventSource = Class.extend(ParsableModelMixin, {\r\n\r\n\tcalendar: null,\r\n\r\n\tid: null, // can stay null\r\n\tuid: null,\r\n\tcolor: null,\r\n\tbackgroundColor: null,\r\n\tborderColor: null,\r\n\ttextColor: null,\r\n\tclassName: null, // array\r\n\teditable: null,\r\n\tstartEditable: null,\r\n\tdurationEditable: null,\r\n\trendering: null,\r\n\toverlap: null,\r\n\tconstraint: null,\r\n\tallDayDefault: null,\r\n\teventDataTransform: null, // optional function\r\n\r\n\r\n\t// can we do away with calendar? at least for the abstract?\r\n\t// useful for buildEventDef\r\n\tconstructor: function(calendar) {\r\n\t\tthis.calendar = calendar;\r\n\t\tthis.className = [];\r\n\t\tthis.uid = String(EventSource.uuid++);\r\n\t},\r\n\r\n\r\n\tfetch: function(start, end, timezone) {\r\n\t\t// subclasses must implement. must return a promise.\r\n\t},\r\n\r\n\r\n\tremoveEventDefsById: function(eventDefId) {\r\n\t\t// optional for subclasses to implement\r\n\t},\r\n\r\n\r\n\tremoveAllEventDefs: function() {\r\n\t\t// optional for subclasses to implement\r\n\t},\r\n\r\n\r\n\t/*\r\n\tFor compairing/matching\r\n\t*/\r\n\tgetPrimitive: function(otherSource) {\r\n\t\t// subclasses must implement\r\n\t},\r\n\r\n\r\n\tparseEventDefs: function(rawEventDefs) {\r\n\t\tvar i;\r\n\t\tvar eventDef;\r\n\t\tvar eventDefs = [];\r\n\r\n\t\tfor (i = 0; i < rawEventDefs.length; i++) {\r\n\t\t\teventDef = EventDefParser.parse(\r\n\t\t\t\trawEventDefs[i],\r\n\t\t\t\tthis // source\r\n\t\t\t);\r\n\r\n\t\t\tif (eventDef) {\r\n\t\t\t\teventDefs.push(eventDef);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn eventDefs;\r\n\t},\r\n\r\n\r\n\tapplyManualStandardProps: function(rawProps) {\r\n\r\n\t\tif (rawProps.id != null) {\r\n\t\t\tthis.id = EventSource.normalizeId(rawProps.id);\r\n\t\t}\r\n\r\n\t\t// TODO: converge with EventDef\r\n\t\tif ($.isArray(rawProps.className)) {\r\n\t\t\tthis.className = rawProps.className;\r\n\t\t}\r\n\t\telse if (typeof rawProps.className === 'string') {\r\n\t\t\tthis.className = rawProps.className.split(/\\s+/);\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n});\r\n\r\n\r\n// finish initializing the mixin\r\nEventSource.defineStandardProps = ParsableModelMixin_defineStandardProps;\r\n\r\n\r\n// IDs\r\n// ---------------------------------------------------------------------------------------------------------------------\r\n// TODO: converge with EventDef\r\n\r\n\r\nEventSource.uuid = 0;\r\n\r\n\r\nEventSource.normalizeId = function(id) {\r\n\tif (id) {\r\n\t\treturn String(id);\r\n\t}\r\n\r\n\treturn null;\r\n};\r\n\r\n\r\n// Parsing\r\n// ---------------------------------------------------------------------------------------------------------------------\r\n\r\n\r\nEventSource.defineStandardProps({\r\n\t// manually process...\r\n\tid: false,\r\n\tclassName: false,\r\n\r\n\t// automatically transfer...\r\n\tcolor: true,\r\n\tbackgroundColor: true,\r\n\tborderColor: true,\r\n\ttextColor: true,\r\n\teditable: true,\r\n\tstartEditable: true,\r\n\tdurationEditable: true,\r\n\trendering: true,\r\n\toverlap: true,\r\n\tconstraint: true,\r\n\tallDayDefault: true,\r\n\teventDataTransform: true\r\n});\r\n\r\n\r\n/*\r\nrawInput can be any data type!\r\n*/\r\nEventSource.parse = function(rawInput, calendar) {\r\n\tvar source = new this(calendar);\r\n\r\n\tif (typeof rawInput === 'object') {\r\n\t\tif (source.applyProps(rawInput)) {\r\n\t\t\treturn source;\r\n\t\t}\r\n\t}\r\n\r\n\treturn false;\r\n};\r\n\r\n\r\nFC.EventSource = EventSource;\r\n\r\n;;\r\n\r\nvar EventSourceParser = {\r\n\r\n\tsourceClasses: [],\r\n\r\n\r\n\tregisterClass: function(EventSourceClass) {\r\n\t\tthis.sourceClasses.unshift(EventSourceClass); // give highest priority\r\n\t},\r\n\r\n\r\n\tparse: function(rawInput, calendar) {\r\n\t\tvar sourceClasses = this.sourceClasses;\r\n\t\tvar i;\r\n\t\tvar eventSource;\r\n\r\n\t\tfor (i = 0; i < sourceClasses.length; i++) {\r\n\t\t\teventSource = sourceClasses[i].parse(rawInput, calendar);\r\n\r\n\t\t\tif (eventSource) {\r\n\t\t\t\treturn eventSource;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n};\r\n\r\n\r\nFC.EventSourceParser = EventSourceParser;\r\n\r\n;;\r\n\r\nvar ArrayEventSource = EventSource.extend({\r\n\r\n\trawEventDefs: null, // unparsed\r\n\teventDefs: null,\r\n\tcurrentTimezone: null,\r\n\r\n\r\n\tconstructor: function(calendar) {\r\n\t\tEventSource.apply(this, arguments); // super-constructor\r\n\t\tthis.eventDefs = []; // for if setRawEventDefs is never called\r\n\t},\r\n\r\n\r\n\tsetRawEventDefs: function(rawEventDefs) {\r\n\t\tthis.rawEventDefs = rawEventDefs;\r\n\t\tthis.eventDefs = this.parseEventDefs(rawEventDefs);\r\n\t},\r\n\r\n\r\n\tfetch: function(start, end, timezone) {\r\n\t\tvar eventDefs = this.eventDefs;\r\n\t\tvar i;\r\n\r\n\t\tif (\r\n\t\t\tthis.currentTimezone !== null &&\r\n\t\t\tthis.currentTimezone !== timezone\r\n\t\t) {\r\n\t\t\tfor (i = 0; i < eventDefs.length; i++) {\r\n\t\t\t\tif (eventDefs[i] instanceof SingleEventDef) {\r\n\t\t\t\t\teventDefs[i].rezone();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis.currentTimezone = timezone;\r\n\r\n\t\treturn Promise.resolve(eventDefs);\r\n\t},\r\n\r\n\r\n\taddEventDef: function(eventDef) {\r\n\t\tthis.eventDefs.push(eventDef);\r\n\t},\r\n\r\n\r\n\t/*\r\n\teventDefId already normalized to a string\r\n\t*/\r\n\tremoveEventDefsById: function(eventDefId) {\r\n\t\treturn removeMatching(this.eventDefs, function(eventDef) {\r\n\t\t\treturn eventDef.id === eventDefId;\r\n\t\t});\r\n\t},\r\n\r\n\r\n\tremoveAllEventDefs: function() {\r\n\t\tthis.eventDefs = [];\r\n\t},\r\n\r\n\r\n\tgetPrimitive: function() {\r\n\t\treturn this.rawEventDefs;\r\n\t},\r\n\r\n\r\n\tapplyManualStandardProps: function(rawProps) {\r\n\t\tvar superSuccess = EventSource.prototype.applyManualStandardProps.apply(this, arguments);\r\n\r\n\t\tthis.setRawEventDefs(rawProps.events);\r\n\r\n\t\treturn superSuccess;\r\n\t}\r\n\r\n});\r\n\r\n\r\nArrayEventSource.defineStandardProps({\r\n\tevents: false // don't automatically transfer\r\n});\r\n\r\n\r\nArrayEventSource.parse = function(rawInput, calendar) {\r\n\tvar rawProps;\r\n\r\n\t// normalize raw input\r\n\tif ($.isArray(rawInput.events)) { // extended form\r\n\t\trawProps = rawInput;\r\n\t}\r\n\telse if ($.isArray(rawInput)) { // short form\r\n\t\trawProps = { events: rawInput };\r\n\t}\r\n\r\n\tif (rawProps) {\r\n\t\treturn EventSource.parse.call(this, rawProps, calendar);\r\n\t}\r\n\r\n\treturn false;\r\n};\r\n\r\n\r\nEventSourceParser.registerClass(ArrayEventSource);\r\n\r\nFC.ArrayEventSource = ArrayEventSource;\r\n\r\n;;\r\n\r\nvar FuncEventSource = EventSource.extend({\r\n\r\n\tfunc: null,\r\n\r\n\r\n\tfetch: function(start, end, timezone) {\r\n\t\tvar _this = this;\r\n\r\n\t\tthis.calendar.pushLoading();\r\n\r\n\t\treturn Promise.construct(function(onResolve) {\r\n\t\t\t_this.func.call(\r\n\t\t\t\t_this.calendar,\r\n\t\t\t\tstart.clone(),\r\n\t\t\t\tend.clone(),\r\n\t\t\t\ttimezone,\r\n\t\t\t\tfunction(rawEventDefs) {\r\n\t\t\t\t\t_this.calendar.popLoading();\r\n\r\n\t\t\t\t\tonResolve(_this.parseEventDefs(rawEventDefs));\r\n\t\t\t\t}\r\n\t\t\t);\r\n\t\t});\r\n\t},\r\n\r\n\r\n\tgetPrimitive: function() {\r\n\t\treturn this.func;\r\n\t},\r\n\r\n\r\n\tapplyManualStandardProps: function(rawProps) {\r\n\t\tvar superSuccess = EventSource.prototype.applyManualStandardProps.apply(this, arguments);\r\n\r\n\t\tthis.func = rawProps.events;\r\n\r\n\t\treturn superSuccess;\r\n\t}\r\n\r\n});\r\n\r\n\r\nFuncEventSource.defineStandardProps({\r\n\tevents: false // don't automatically transfer\r\n});\r\n\r\n\r\nFuncEventSource.parse = function(rawInput, calendar) {\r\n\tvar rawProps;\r\n\r\n\t// normalize raw input\r\n\tif ($.isFunction(rawInput.events)) { // extended form\r\n\t\trawProps = rawInput;\r\n\t}\r\n\telse if ($.isFunction(rawInput)) { // short form\r\n\t\trawProps = { events: rawInput };\r\n\t}\r\n\r\n\tif (rawProps) {\r\n\t\treturn EventSource.parse.call(this, rawProps, calendar);\r\n\t}\r\n\r\n\treturn false;\r\n};\r\n\r\n\r\nEventSourceParser.registerClass(FuncEventSource);\r\n\r\nFC.FuncEventSource = FuncEventSource;\r\n\r\n;;\r\n\r\nvar JsonFeedEventSource = EventSource.extend({\r\n\r\n\t// these props must all be manually set before calling fetch\r\n\turl: null,\r\n\tstartParam: null,\r\n\tendParam: null,\r\n\ttimezoneParam: null,\r\n\tajaxSettings: null, // does not include url\r\n\r\n\r\n\tfetch: function(start, end, timezone) {\r\n\t\tvar _this = this;\r\n\t\tvar ajaxSettings = this.ajaxSettings;\r\n\t\tvar onSuccess = ajaxSettings.success;\r\n\t\tvar onError = ajaxSettings.error;\r\n\t\tvar requestParams = this.buildRequestParams(start, end, timezone);\r\n\r\n\t\t// todo: eventually handle the promise's then,\r\n\t\t// don't intercept success/error\r\n\t\t// tho will be a breaking API change\r\n\r\n\t\tthis.calendar.pushLoading();\r\n\r\n\t\treturn Promise.construct(function(onResolve, onReject) {\r\n\t\t\t$.ajax($.extend(\r\n\t\t\t\t{}, // destination\r\n\t\t\t\tJsonFeedEventSource.AJAX_DEFAULTS,\r\n\t\t\t\tajaxSettings,\r\n\t\t\t\t{\r\n\t\t\t\t\turl: _this.url,\r\n\t\t\t\t\tdata: requestParams,\r\n\t\t\t\t\tsuccess: function(rawEventDefs) {\r\n\t\t\t\t\t\tvar callbackRes;\r\n\r\n\t\t\t\t\t\t_this.calendar.popLoading();\r\n\r\n\t\t\t\t\t\tif (rawEventDefs) {\r\n\t\t\t\t\t\t\tcallbackRes = applyAll(onSuccess, this, arguments); // redirect `this`\r\n\r\n\t\t\t\t\t\t\tif ($.isArray(callbackRes)) {\r\n\t\t\t\t\t\t\t\trawEventDefs = callbackRes;\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tonResolve(_this.parseEventDefs(rawEventDefs));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\tonReject();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t},\r\n\t\t\t\t\terror: function() {\r\n\t\t\t\t\t\t_this.calendar.popLoading();\r\n\r\n\t\t\t\t\t\tapplyAll(onError, this, arguments); // redirect `this`\r\n\t\t\t\t\t\tonReject();\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t));\r\n\t\t});\r\n\t},\r\n\r\n\r\n\tbuildRequestParams: function(start, end, timezone) {\r\n\t\tvar calendar = this.calendar;\r\n\t\tvar ajaxSettings = this.ajaxSettings;\r\n\t\tvar startParam, endParam, timezoneParam;\r\n\t\tvar customRequestParams;\r\n\t\tvar params = {};\r\n\r\n\t\tstartParam = this.startParam;\r\n\t\tif (startParam == null) {\r\n\t\t\tstartParam = calendar.opt('startParam');\r\n\t\t}\r\n\r\n\t\tendParam = this.endParam;\r\n\t\tif (endParam == null) {\r\n\t\t\tendParam = calendar.opt('endParam');\r\n\t\t}\r\n\r\n\t\ttimezoneParam = this.timezoneParam;\r\n\t\tif (timezoneParam == null) {\r\n\t\t\ttimezoneParam = calendar.opt('timezoneParam');\r\n\t\t}\r\n\r\n\t\t// retrieve any outbound GET/POST $.ajax data from the options\r\n\t\tif ($.isFunction(ajaxSettings.data)) {\r\n\t\t\t// supplied as a function that returns a key/value object\r\n\t\t\tcustomRequestParams = ajaxSettings.data();\r\n\t\t}\r\n\t\telse {\r\n\t\t\t// probably supplied as a straight key/value object\r\n\t\t\tcustomRequestParams = ajaxSettings.data || {};\r\n\t\t}\r\n\r\n\t\t$.extend(params, customRequestParams);\r\n\r\n\t\tparams[startParam] = start.format();\r\n\t\tparams[endParam] = end.format();\r\n\r\n\t\tif (timezone && timezone !== 'local') {\r\n\t\t\tparams[timezoneParam] = timezone;\r\n\t\t}\r\n\r\n\t\treturn params;\r\n\t},\r\n\r\n\r\n\tgetPrimitive: function() {\r\n\t\treturn this.url;\r\n\t},\r\n\r\n\r\n\tapplyMiscProps: function(rawProps) {\r\n\t\tEventSource.prototype.applyMiscProps.apply(this, arguments);\r\n\r\n\t\tthis.ajaxSettings = rawProps;\r\n\t}\r\n\r\n});\r\n\r\n\r\nJsonFeedEventSource.AJAX_DEFAULTS = {\r\n\tdataType: 'json',\r\n\tcache: false\r\n};\r\n\r\n\r\nJsonFeedEventSource.defineStandardProps({\r\n\t// automatically transfer (true)...\r\n\turl: true,\r\n\tstartParam: true,\r\n\tendParam: true,\r\n\ttimezoneParam: true\r\n});\r\n\r\n\r\nJsonFeedEventSource.parse = function(rawInput, calendar) {\r\n\tvar rawProps;\r\n\r\n\t// normalize raw input\r\n\tif (typeof rawInput.url === 'string') { // extended form\r\n\t\trawProps = rawInput;\r\n\t}\r\n\telse if (typeof rawInput === 'string') { // short form\r\n\t\trawProps = { url: rawInput };\r\n\t}\r\n\r\n\tif (rawProps) {\r\n\t\treturn EventSource.parse.call(this, rawProps, calendar);\r\n\t}\r\n\r\n\treturn false;\r\n};\r\n\r\n\r\nEventSourceParser.registerClass(JsonFeedEventSource);\r\n\r\nFC.JsonFeedEventSource = JsonFeedEventSource;\r\n\r\n;;\r\n\r\nvar ThemeRegistry = FC.ThemeRegistry = {\r\n\r\n\tthemeClassHash: {},\r\n\r\n\r\n\tregister: function(themeName, themeClass) {\r\n\t\tthis.themeClassHash[themeName] = themeClass;\r\n\t},\r\n\r\n\r\n\tgetThemeClass: function(themeSetting) {\r\n\t\tif (!themeSetting) {\r\n\t\t\treturn StandardTheme;\r\n\t\t}\r\n\t\telse if (themeSetting === true) {\r\n\t\t\treturn JqueryUiTheme;\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn this.themeClassHash[themeSetting];\r\n\t\t}\r\n\t}\r\n\r\n};\r\n\r\n;;\r\n\r\nvar Theme = FC.Theme = Class.extend({\r\n\r\n\tclasses: {},\r\n\ticonClasses: {},\r\n\tbaseIconClass: '',\r\n\ticonOverrideOption: null,\r\n\ticonOverrideCustomButtonOption: null,\r\n\ticonOverridePrefix: '',\r\n\r\n\r\n\tconstructor: function(optionsModel) {\r\n\t\tthis.optionsModel = optionsModel;\r\n\t\tthis.processIconOverride();\r\n\t},\r\n\r\n\r\n\tprocessIconOverride: function() {\r\n\t\tif (this.iconOverrideOption) {\r\n\t\t\tthis.setIconOverride(\r\n\t\t\t\tthis.optionsModel.get(this.iconOverrideOption)\r\n\t\t\t);\r\n\t\t}\r\n\t},\r\n\r\n\r\n\tsetIconOverride: function(iconOverrideHash) {\r\n\t\tvar iconClassesCopy;\r\n\t\tvar buttonName;\r\n\r\n\t\tif ($.isPlainObject(iconOverrideHash)) {\r\n\t\t\ticonClassesCopy = $.extend({}, this.iconClasses);\r\n\r\n\t\t\tfor (buttonName in iconOverrideHash) {\r\n\t\t\t\ticonClassesCopy[buttonName] = this.applyIconOverridePrefix(\r\n\t\t\t\t\ticonOverrideHash[buttonName]\r\n\t\t\t\t);\r\n\t\t\t}\r\n\r\n\t\t\tthis.iconClasses = iconClassesCopy;\r\n\t\t}\r\n\t\telse if (iconOverrideHash === false) {\r\n\t\t\tthis.iconClasses = {};\r\n\t\t}\r\n\t},\r\n\r\n\r\n\tapplyIconOverridePrefix: function(className) {\r\n\t\tvar prefix = this.iconOverridePrefix;\r\n\r\n\t\tif (prefix && className.indexOf(prefix) !== 0) { // if not already present\r\n\t\t\tclassName = prefix + className;\r\n\t\t}\r\n\r\n\t\treturn className;\r\n\t},\r\n\r\n\r\n\tgetClass: function(key) {\r\n\t\treturn this.classes[key] || '';\r\n\t},\r\n\r\n\r\n\tgetIconClass: function(buttonName) {\r\n\t\tvar className = this.iconClasses[buttonName];\r\n\r\n\t\tif (className) {\r\n\t\t\treturn this.baseIconClass + ' ' + className;\r\n\t\t}\r\n\r\n\t\treturn '';\r\n\t},\r\n\r\n\r\n\tgetCustomButtonIconClass: function(customButtonProps) {\r\n\t\tvar className;\r\n\r\n\t\tif (this.iconOverrideCustomButtonOption) {\r\n\t\t\tclassName = customButtonProps[this.iconOverrideCustomButtonOption];\r\n\r\n\t\t\tif (className) {\r\n\t\t\t\treturn this.baseIconClass + ' ' + this.applyIconOverridePrefix(className);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn '';\r\n\t}\r\n\r\n});\r\n\r\n;;\r\n\r\nvar StandardTheme = Theme.extend({\r\n\r\n\tclasses: {\r\n\t\twidget: 'fc-unthemed',\r\n\t\twidgetHeader: 'fc-widget-header',\r\n\t\twidgetContent: 'fc-widget-content',\r\n\r\n\t\tbuttonGroup: 'fc-button-group',\r\n\t\tbutton: 'fc-button',\r\n\t\tcornerLeft: 'fc-corner-left',\r\n\t\tcornerRight: 'fc-corner-right',\r\n\t\tstateDefault: 'fc-state-default',\r\n\t\tstateActive: 'fc-state-active',\r\n\t\tstateDisabled: 'fc-state-disabled',\r\n\t\tstateHover: 'fc-state-hover',\r\n\t\tstateDown: 'fc-state-down',\r\n\r\n\t\tpopoverHeader: 'fc-widget-header',\r\n\t\tpopoverContent: 'fc-widget-content',\r\n\r\n\t\t// day grid\r\n\t\theaderRow: 'fc-widget-header',\r\n\t\tdayRow: 'fc-widget-content',\r\n\r\n\t\t// list view\r\n\t\tlistView: 'fc-widget-content'\r\n\t},\r\n\r\n\tbaseIconClass: 'fc-icon',\r\n\ticonClasses: {\r\n\t\tclose: 'fc-icon-x',\r\n\t\tprev: 'fc-icon-left-single-arrow',\r\n\t\tnext: 'fc-icon-right-single-arrow',\r\n\t\tprevYear: 'fc-icon-left-double-arrow',\r\n\t\tnextYear: 'fc-icon-right-double-arrow'\r\n\t},\r\n\r\n\ticonOverrideOption: 'buttonIcons',\r\n\ticonOverrideCustomButtonOption: 'icon',\r\n\ticonOverridePrefix: 'fc-icon-'\r\n\r\n});\r\n\r\nThemeRegistry.register('standard', StandardTheme);\r\n\r\n;;\r\n\r\nvar JqueryUiTheme = Theme.extend({\r\n\r\n\tclasses: {\r\n\t\twidget: 'ui-widget',\r\n\t\twidgetHeader: 'ui-widget-header',\r\n\t\twidgetContent: 'ui-widget-content',\r\n\r\n\t\tbuttonGroup: 'fc-button-group',\r\n\t\tbutton: 'ui-button',\r\n\t\tcornerLeft: 'ui-corner-left',\r\n\t\tcornerRight: 'ui-corner-right',\r\n\t\tstateDefault: 'ui-state-default',\r\n\t\tstateActive: 'ui-state-active',\r\n\t\tstateDisabled: 'ui-state-disabled',\r\n\t\tstateHover: 'ui-state-hover',\r\n\t\tstateDown: 'ui-state-down',\r\n\r\n\t\ttoday: 'ui-state-highlight',\r\n\r\n\t\tpopoverHeader: 'ui-widget-header',\r\n\t\tpopoverContent: 'ui-widget-content',\r\n\r\n\t\t// day grid\r\n\t\theaderRow: 'ui-widget-header',\r\n\t\tdayRow: 'ui-widget-content',\r\n\r\n\t\t// list view\r\n\t\tlistView: 'ui-widget-content'\r\n\t},\r\n\r\n\tbaseIconClass: 'ui-icon',\r\n\ticonClasses: {\r\n\t\tclose: 'ui-icon-closethick',\r\n\t\tprev: 'ui-icon-circle-triangle-w',\r\n\t\tnext: 'ui-icon-circle-triangle-e',\r\n\t\tprevYear: 'ui-icon-seek-prev',\r\n\t\tnextYear: 'ui-icon-seek-next'\r\n\t},\r\n\r\n\ticonOverrideOption: 'themeButtonIcons',\r\n\ticonOverrideCustomButtonOption: 'themeIcon',\r\n\ticonOverridePrefix: 'ui-icon-'\r\n\r\n});\r\n\r\nThemeRegistry.register('jquery-ui', JqueryUiTheme);\r\n\r\n;;\r\n\r\nvar BootstrapTheme = Theme.extend({\r\n\r\n\tclasses: {\r\n\t\twidget: 'fc-bootstrap3',\r\n\r\n\t\ttableGrid: 'table-bordered', // avoid `table` class b/c don't want margins. only border color\r\n\t\ttableList: 'table table-striped', // `table` class creates bottom margin but who cares\r\n\r\n\t\tbuttonGroup: 'btn-group',\r\n\t\tbutton: 'btn btn-default',\r\n\t\tstateActive: 'active',\r\n\t\tstateDisabled: 'disabled',\r\n\r\n\t\ttoday: 'alert alert-info', // the plain `info` class requires `.table`, too much to ask\r\n\r\n\t\tpopover: 'panel panel-default',\r\n\t\tpopoverHeader: 'panel-heading',\r\n\t\tpopoverContent: 'panel-body',\r\n\r\n\t\t// day grid\r\n\t\theaderRow: 'panel-default', // avoid `panel` class b/c don't want margins/radius. only border color\r\n\t\tdayRow: 'panel-default', // \"\r\n\r\n\t\t// list view\r\n\t\tlistView: 'panel panel-default'\r\n\t},\r\n\r\n\tbaseIconClass: 'glyphicon',\r\n\ticonClasses: {\r\n\t\tclose: 'glyphicon-remove',\r\n\t\tprev: 'glyphicon-chevron-left',\r\n\t\tnext: 'glyphicon-chevron-right',\r\n\t\tprevYear: 'glyphicon-backward',\r\n\t\tnextYear: 'glyphicon-forward'\r\n\t},\r\n\r\n\ticonOverrideOption: 'bootstrapGlyphicons',\r\n\ticonOverrideCustomButtonOption: 'bootstrapGlyphicon',\r\n\ticonOverridePrefix: 'glyphicon-'\r\n\r\n});\r\n\r\nThemeRegistry.register('bootstrap3', BootstrapTheme);\r\n\r\n;;\r\n\r\nvar DayGridFillRenderer = FillRenderer.extend({\r\n\r\n\tfillSegTag: 'td', // override the default tag name\r\n\r\n\r\n\tattachSegEls: function(type, segs) {\r\n\t\tvar nodes = [];\r\n\t\tvar i, seg;\r\n\t\tvar skeletonEl;\r\n\r\n\t\tfor (i = 0; i < segs.length; i++) {\r\n\t\t\tseg = segs[i];\r\n\t\t\tskeletonEl = this.renderFillRow(type, seg);\r\n\t\t\tthis.component.rowEls.eq(seg.row).append(skeletonEl);\r\n\t\t\tnodes.push(skeletonEl[0]);\r\n\t\t}\r\n\r\n\t\treturn nodes;\r\n\t},\r\n\r\n\r\n\t// Generates the HTML needed for one row of a fill. Requires the seg's el to be rendered.\r\n\trenderFillRow: function(type, seg) {\r\n\t\tvar colCnt = this.component.colCnt;\r\n\t\tvar startCol = seg.leftCol;\r\n\t\tvar endCol = seg.rightCol + 1;\r\n\t\tvar className;\r\n\t\tvar skeletonEl;\r\n\t\tvar trEl;\r\n\r\n\t\tif (type === 'businessHours') {\r\n\t\t\tclassName = 'bgevent';\r\n\t\t}\r\n\t\telse {\r\n\t\t\tclassName = type.toLowerCase();\r\n\t\t}\r\n\r\n\t\tskeletonEl = $(\r\n\t\t\t'<div class=\"fc-' + className + '-skeleton\">' +\r\n\t\t\t\t'<table><tr/></table>' +\r\n\t\t\t'</div>'\r\n\t\t);\r\n\t\ttrEl = skeletonEl.find('tr');\r\n\r\n\t\tif (startCol > 0) {\r\n\t\t\ttrEl.append('<td colspan=\"' + startCol + '\"/>');\r\n\t\t}\r\n\r\n\t\ttrEl.append(\r\n\t\t\tseg.el.attr('colspan', endCol - startCol)\r\n\t\t);\r\n\r\n\t\tif (endCol < colCnt) {\r\n\t\t\ttrEl.append('<td colspan=\"' + (colCnt - endCol) + '\"/>');\r\n\t\t}\r\n\r\n\t\tthis.component.bookendCells(trEl);\r\n\r\n\t\treturn skeletonEl;\r\n\t}\r\n});\r\n\r\n;;\r\n\r\n/* Event-rendering methods for the DayGrid class\r\n----------------------------------------------------------------------------------------------------------------------*/\r\n\r\nvar DayGridEventRenderer = EventRenderer.extend({\r\n\r\n\tdayGrid: null,\r\n\trowStructs: null, // an array of objects, each holding information about a row's foreground event-rendering\r\n\r\n\r\n\tconstructor: function(dayGrid) {\r\n\t\tEventRenderer.apply(this, arguments);\r\n\r\n\t\tthis.dayGrid = dayGrid;\r\n\t},\r\n\r\n\r\n\trenderBgRanges: function(eventRanges) {\r\n\t\t// don't render timed background events\r\n\t\teventRanges = $.grep(eventRanges, function(eventRange) {\r\n\t\t\treturn eventRange.eventDef.isAllDay();\r\n\t\t});\r\n\r\n\t\tEventRenderer.prototype.renderBgRanges.call(this, eventRanges);\r\n\t},\r\n\r\n\r\n\t// Renders the given foreground event segments onto the grid\r\n\trenderFgSegs: function(segs) {\r\n\t\tvar rowStructs = this.rowStructs = this.renderSegRows(segs);\r\n\r\n\t\t// append to each row's content skeleton\r\n\t\tthis.dayGrid.rowEls.each(function(i, rowNode) {\r\n\t\t\t$(rowNode).find('.fc-content-skeleton > table').append(\r\n\t\t\t\trowStructs[i].tbodyEl\r\n\t\t\t);\r\n\t\t});\r\n\t},\r\n\r\n\r\n\t// Unrenders all currently rendered foreground event segments\r\n\tunrenderFgSegs: function() {\r\n\t\tvar rowStructs = this.rowStructs || [];\r\n\t\tvar rowStruct;\r\n\r\n\t\twhile ((rowStruct = rowStructs.pop())) {\r\n\t\t\trowStruct.tbodyEl.remove();\r\n\t\t}\r\n\r\n\t\tthis.rowStructs = null;\r\n\t},\r\n\r\n\r\n\t// Uses the given events array to generate <tbody> elements that should be appended to each row's content skeleton.\r\n\t// Returns an array of rowStruct objects (see the bottom of `renderSegRow`).\r\n\t// PRECONDITION: each segment shoud already have a rendered and assigned `.el`\r\n\trenderSegRows: function(segs) {\r\n\t\tvar rowStructs = [];\r\n\t\tvar segRows;\r\n\t\tvar row;\r\n\r\n\t\tsegRows = this.groupSegRows(segs); // group into nested arrays\r\n\r\n\t\t// iterate each row of segment groupings\r\n\t\tfor (row = 0; row < segRows.length; row++) {\r\n\t\t\trowStructs.push(\r\n\t\t\t\tthis.renderSegRow(row, segRows[row])\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\treturn rowStructs;\r\n\t},\r\n\r\n\r\n\t// Given a row # and an array of segments all in the same row, render a <tbody> element, a skeleton that contains\r\n\t// the segments. Returns object with a bunch of internal data about how the render was calculated.\r\n\t// NOTE: modifies rowSegs\r\n\trenderSegRow: function(row, rowSegs) {\r\n\t\tvar colCnt = this.dayGrid.colCnt;\r\n\t\tvar segLevels = this.buildSegLevels(rowSegs); // group into sub-arrays of levels\r\n\t\tvar levelCnt = Math.max(1, segLevels.length); // ensure at least one level\r\n\t\tvar tbody = $('<tbody/>');\r\n\t\tvar segMatrix = []; // lookup for which segments are rendered into which level+col cells\r\n\t\tvar cellMatrix = []; // lookup for all <td> elements of the level+col matrix\r\n\t\tvar loneCellMatrix = []; // lookup for <td> elements that only take up a single column\r\n\t\tvar i, levelSegs;\r\n\t\tvar col;\r\n\t\tvar tr;\r\n\t\tvar j, seg;\r\n\t\tvar td;\r\n\r\n\t\t// populates empty cells from the current column (`col`) to `endCol`\r\n\t\tfunction emptyCellsUntil(endCol) {\r\n\t\t\twhile (col < endCol) {\r\n\t\t\t\t// try to grab a cell from the level above and extend its rowspan. otherwise, create a fresh cell\r\n\t\t\t\ttd = (loneCellMatrix[i - 1] || [])[col];\r\n\t\t\t\tif (td) {\r\n\t\t\t\t\ttd.attr(\r\n\t\t\t\t\t\t'rowspan',\r\n\t\t\t\t\t\tparseInt(td.attr('rowspan') || 1, 10) + 1\r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\ttd = $('<td/>');\r\n\t\t\t\t\ttr.append(td);\r\n\t\t\t\t}\r\n\t\t\t\tcellMatrix[i][col] = td;\r\n\t\t\t\tloneCellMatrix[i][col] = td;\r\n\t\t\t\tcol++;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfor (i = 0; i < levelCnt; i++) { // iterate through all levels\r\n\t\t\tlevelSegs = segLevels[i];\r\n\t\t\tcol = 0;\r\n\t\t\ttr = $('<tr/>');\r\n\r\n\t\t\tsegMatrix.push([]);\r\n\t\t\tcellMatrix.push([]);\r\n\t\t\tloneCellMatrix.push([]);\r\n\r\n\t\t\t// levelCnt might be 1 even though there are no actual levels. protect against this.\r\n\t\t\t// this single empty row is useful for styling.\r\n\t\t\tif (levelSegs) {\r\n\t\t\t\tfor (j = 0; j < levelSegs.length; j++) { // iterate through segments in level\r\n\t\t\t\t\tseg = levelSegs[j];\r\n\r\n\t\t\t\t\temptyCellsUntil(seg.leftCol);\r\n\r\n\t\t\t\t\t// create a container that occupies or more columns. append the event element.\r\n\t\t\t\t\ttd = $('<td class=\"fc-event-container\"/>').append(seg.el);\r\n\t\t\t\t\tif (seg.leftCol != seg.rightCol) {\r\n\t\t\t\t\t\ttd.attr('colspan', seg.rightCol - seg.leftCol + 1);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse { // a single-column segment\r\n\t\t\t\t\t\tloneCellMatrix[i][col] = td;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\twhile (col <= seg.rightCol) {\r\n\t\t\t\t\t\tcellMatrix[i][col] = td;\r\n\t\t\t\t\t\tsegMatrix[i][col] = seg;\r\n\t\t\t\t\t\tcol++;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\ttr.append(td);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\temptyCellsUntil(colCnt); // finish off the row\r\n\t\t\tthis.dayGrid.bookendCells(tr);\r\n\t\t\ttbody.append(tr);\r\n\t\t}\r\n\r\n\t\treturn { // a \"rowStruct\"\r\n\t\t\trow: row, // the row number\r\n\t\t\ttbodyEl: tbody,\r\n\t\t\tcellMatrix: cellMatrix,\r\n\t\t\tsegMatrix: segMatrix,\r\n\t\t\tsegLevels: segLevels,\r\n\t\t\tsegs: rowSegs\r\n\t\t};\r\n\t},\r\n\r\n\r\n\t// Stacks a flat array of segments, which are all assumed to be in the same row, into subarrays of vertical levels.\r\n\t// NOTE: modifies segs\r\n\tbuildSegLevels: function(segs) {\r\n\t\tvar levels = [];\r\n\t\tvar i, seg;\r\n\t\tvar j;\r\n\r\n\t\t// Give preference to elements with certain criteria, so they have\r\n\t\t// a chance to be closer to the top.\r\n\t\tthis.sortEventSegs(segs);\r\n\r\n\t\tfor (i = 0; i < segs.length; i++) {\r\n\t\t\tseg = segs[i];\r\n\r\n\t\t\t// loop through levels, starting with the topmost, until the segment doesn't collide with other segments\r\n\t\t\tfor (j = 0; j < levels.length; j++) {\r\n\t\t\t\tif (!isDaySegCollision(seg, levels[j])) {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// `j` now holds the desired subrow index\r\n\t\t\tseg.level = j;\r\n\r\n\t\t\t// create new level array if needed and append segment\r\n\t\t\t(levels[j] || (levels[j] = [])).push(seg);\r\n\t\t}\r\n\r\n\t\t// order segments left-to-right. very important if calendar is RTL\r\n\t\tfor (j = 0; j < levels.length; j++) {\r\n\t\t\tlevels[j].sort(compareDaySegCols);\r\n\t\t}\r\n\r\n\t\treturn levels;\r\n\t},\r\n\r\n\r\n\t// Given a flat array of segments, return an array of sub-arrays, grouped by each segment's row\r\n\tgroupSegRows: function(segs) {\r\n\t\tvar segRows = [];\r\n\t\tvar i;\r\n\r\n\t\tfor (i = 0; i < this.dayGrid.rowCnt; i++) {\r\n\t\t\tsegRows.push([]);\r\n\t\t}\r\n\r\n\t\tfor (i = 0; i < segs.length; i++) {\r\n\t\t\tsegRows[segs[i].row].push(segs[i]);\r\n\t\t}\r\n\r\n\t\treturn segRows;\r\n\t},\r\n\r\n\r\n\t// Computes a default event time formatting string if `timeFormat` is not explicitly defined\r\n\tcomputeEventTimeFormat: function() {\r\n\t\treturn this.opt('extraSmallTimeFormat'); // like \"6p\" or \"6:30p\"\r\n\t},\r\n\r\n\r\n\t// Computes a default `displayEventEnd` value if one is not expliclty defined\r\n\tcomputeDisplayEventEnd: function() {\r\n\t\treturn this.dayGrid.colCnt === 1; // we'll likely have space if there's only one day\r\n\t},\r\n\r\n\r\n\t// Builds the HTML to be used for the default element for an individual segment\r\n\tfgSegHtml: function(seg, disableResizing) {\r\n\t\tvar view = this.view;\r\n\t\tvar eventDef = seg.footprint.eventDef;\r\n\t\tvar isAllDay = seg.footprint.componentFootprint.isAllDay;\r\n\t\tvar isDraggable = view.isEventDefDraggable(eventDef);\r\n\t\tvar isResizableFromStart = !disableResizing && isAllDay &&\r\n\t\t\tseg.isStart && view.isEventDefResizableFromStart(eventDef);\r\n\t\tvar isResizableFromEnd = !disableResizing && isAllDay &&\r\n\t\t\tseg.isEnd && view.isEventDefResizableFromEnd(eventDef);\r\n\t\tvar classes = this.getSegClasses(seg, isDraggable, isResizableFromStart || isResizableFromEnd);\r\n\t\tvar skinCss = cssToStr(this.getSkinCss(eventDef));\r\n\t\tvar timeHtml = '';\r\n\t\tvar timeText;\r\n\t\tvar titleHtml;\r\n\r\n\t\tclasses.unshift('fc-day-grid-event', 'fc-h-event');\r\n\r\n\t\t// Only display a timed events time if it is the starting segment\r\n\t\tif (seg.isStart) {\r\n\t\t\ttimeText = this.getTimeText(seg.footprint);\r\n\t\t\tif (timeText) {\r\n\t\t\t\ttimeHtml = '<span class=\"fc-time\">' + htmlEscape(timeText) + '</span>';\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\ttitleHtml =\r\n\t\t\t'<span class=\"fc-title\">' +\r\n\t\t\t\t(htmlEscape(eventDef.title || '') || '&nbsp;') + // we always want one line of height\r\n\t\t\t'</span>';\r\n\r\n\t\treturn '<a class=\"' + classes.join(' ') + '\"' +\r\n\t\t\t\t(eventDef.url ?\r\n\t\t\t\t\t' href=\"' + htmlEscape(eventDef.url) + '\"' :\r\n\t\t\t\t\t''\r\n\t\t\t\t\t) +\r\n\t\t\t\t(skinCss ?\r\n\t\t\t\t\t' style=\"' + skinCss + '\"' :\r\n\t\t\t\t\t''\r\n\t\t\t\t\t) +\r\n\t\t\t'>' +\r\n\t\t\t\t'<div class=\"fc-content\">' +\r\n\t\t\t\t\t(this.isRTL ?\r\n\t\t\t\t\t\ttitleHtml + ' ' + timeHtml : // put a natural space in between\r\n\t\t\t\t\t\ttimeHtml + ' ' + titleHtml   //\r\n\t\t\t\t\t\t) +\r\n\t\t\t\t'</div>' +\r\n\t\t\t\t(isResizableFromStart ?\r\n\t\t\t\t\t'<div class=\"fc-resizer fc-start-resizer\" />' :\r\n\t\t\t\t\t''\r\n\t\t\t\t\t) +\r\n\t\t\t\t(isResizableFromEnd ?\r\n\t\t\t\t\t'<div class=\"fc-resizer fc-end-resizer\" />' :\r\n\t\t\t\t\t''\r\n\t\t\t\t\t) +\r\n\t\t\t'</a>';\r\n\t}\r\n\r\n});\r\n\r\n\r\n// Computes whether two segments' columns collide. They are assumed to be in the same row.\r\nfunction isDaySegCollision(seg, otherSegs) {\r\n\tvar i, otherSeg;\r\n\r\n\tfor (i = 0; i < otherSegs.length; i++) {\r\n\t\totherSeg = otherSegs[i];\r\n\r\n\t\tif (\r\n\t\t\totherSeg.leftCol <= seg.rightCol &&\r\n\t\t\totherSeg.rightCol >= seg.leftCol\r\n\t\t) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\t}\r\n\r\n\treturn false;\r\n}\r\n\r\n\r\n// A cmp function for determining the leftmost event\r\nfunction compareDaySegCols(a, b) {\r\n\treturn a.leftCol - b.leftCol;\r\n}\r\n\r\n;;\r\n\r\nvar DayGridHelperRenderer = HelperRenderer.extend({\r\n\r\n\r\n\t// Renders a mock \"helper\" event. `sourceSeg` is the associated internal segment object. It can be null.\r\n\trenderSegs: function(segs, sourceSeg) {\r\n\t\tvar helperNodes = [];\r\n\t\tvar rowStructs;\r\n\r\n\t\t// TODO: not good to call eventRenderer this way\r\n\t\trowStructs = this.eventRenderer.renderSegRows(segs);\r\n\r\n\t\t// inject each new event skeleton into each associated row\r\n\t\tthis.component.rowEls.each(function(row, rowNode) {\r\n\t\t\tvar rowEl = $(rowNode); // the .fc-row\r\n\t\t\tvar skeletonEl = $('<div class=\"fc-helper-skeleton\"><table/></div>'); // will be absolutely positioned\r\n\t\t\tvar skeletonTopEl;\r\n\t\t\tvar skeletonTop;\r\n\r\n\t\t\t// If there is an original segment, match the top position. Otherwise, put it at the row's top level\r\n\t\t\tif (sourceSeg && sourceSeg.row === row) {\r\n\t\t\t\tskeletonTop = sourceSeg.el.position().top;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tskeletonTopEl = rowEl.find('.fc-content-skeleton tbody');\r\n\t\t\t\tif (!skeletonTopEl.length) { // when no events\r\n\t\t\t\t\tskeletonTopEl = rowEl.find('.fc-content-skeleton table');\r\n\t\t\t\t}\r\n\r\n\t\t\t\tskeletonTop = skeletonTopEl.position().top;\r\n\t\t\t}\r\n\r\n\t\t\tskeletonEl.css('top', skeletonTop)\r\n\t\t\t\t.find('table')\r\n\t\t\t\t\t.append(rowStructs[row].tbodyEl);\r\n\r\n\t\t\trowEl.append(skeletonEl);\r\n\t\t\thelperNodes.push(skeletonEl[0]);\r\n\t\t});\r\n\r\n\t\treturn $(helperNodes); // must return the elements rendered\r\n\t}\r\n\r\n});\r\n\r\n;;\r\n\r\n/* A component that renders a grid of whole-days that runs horizontally. There can be multiple rows, one per week.\r\n----------------------------------------------------------------------------------------------------------------------*/\r\n\r\nvar DayGrid = FC.DayGrid = InteractiveDateComponent.extend(StandardInteractionsMixin, DayTableMixin, {\r\n\r\n\teventRendererClass: DayGridEventRenderer,\r\n\tbusinessHourRendererClass: BusinessHourRenderer,\r\n\thelperRendererClass: DayGridHelperRenderer,\r\n\tfillRendererClass: DayGridFillRenderer,\r\n\r\n\tview: null, // TODO: make more general and/or remove\r\n\thelperRenderer: null,\r\n\r\n\tcellWeekNumbersVisible: false, // display week numbers in day cell?\r\n\r\n\tbottomCoordPadding: 0, // hack for extending the hit area for the last row of the coordinate grid\r\n\r\n\theadContainerEl: null, // div that hold's the date header\r\n\trowEls: null, // set of fake row elements\r\n\tcellEls: null, // set of whole-day elements comprising the row's background\r\n\r\n\trowCoordCache: null,\r\n\tcolCoordCache: null,\r\n\r\n\t// isRigid determines whether the individual rows should ignore the contents and be a constant height.\r\n\t// Relies on the view's colCnt and rowCnt. In the future, this component should probably be self-sufficient.\r\n\tisRigid: false,\r\n\r\n\thasAllDayBusinessHours: true,\r\n\r\n\r\n\tconstructor: function(view) {\r\n\t\tthis.view = view; // do first, for opt calls during initialization\r\n\r\n\t\tInteractiveDateComponent.call(this);\r\n\t},\r\n\r\n\r\n\t// Slices up the given span (unzoned start/end with other misc data) into an array of segments\r\n\tcomponentFootprintToSegs: function(componentFootprint) {\r\n\t\tvar segs = this.sliceRangeByRow(componentFootprint.unzonedRange);\r\n\t\tvar i, seg;\r\n\r\n\t\tfor (i = 0; i < segs.length; i++) {\r\n\t\t\tseg = segs[i];\r\n\r\n\t\t\tif (this.isRTL) {\r\n\t\t\t\tseg.leftCol = this.daysPerRow - 1 - seg.lastRowDayIndex;\r\n\t\t\t\tseg.rightCol = this.daysPerRow - 1 - seg.firstRowDayIndex;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tseg.leftCol = seg.firstRowDayIndex;\r\n\t\t\t\tseg.rightCol = seg.lastRowDayIndex;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn segs;\r\n\t},\r\n\r\n\r\n\t/* Date Rendering\r\n\t------------------------------------------------------------------------------------------------------------------*/\r\n\r\n\r\n\trenderDates: function(dateProfile) {\r\n\t\tthis.dateProfile = dateProfile;\r\n\t\tthis.updateDayTable();\r\n\t\tthis.renderGrid();\r\n\t},\r\n\r\n\r\n\tunrenderDates: function() {\r\n\t\tthis.removeSegPopover();\r\n\t},\r\n\r\n\r\n\t// Renders the rows and columns into the component's `this.el`, which should already be assigned.\r\n\trenderGrid: function() {\r\n\t\tvar view = this.view;\r\n\t\tvar rowCnt = this.rowCnt;\r\n\t\tvar colCnt = this.colCnt;\r\n\t\tvar html = '';\r\n\t\tvar row;\r\n\t\tvar col;\r\n\r\n\t\tif (this.headContainerEl) {\r\n\t\t\tthis.headContainerEl.html(this.renderHeadHtml());\r\n\t\t}\r\n\r\n\t\tfor (row = 0; row < rowCnt; row++) {\r\n\t\t\thtml += this.renderDayRowHtml(row, this.isRigid);\r\n\t\t}\r\n\t\tthis.el.html(html);\r\n\r\n\t\tthis.rowEls = this.el.find('.fc-row');\r\n\t\tthis.cellEls = this.el.find('.fc-day, .fc-disabled-day');\r\n\r\n\t\tthis.rowCoordCache = new CoordCache({\r\n\t\t\tels: this.rowEls,\r\n\t\t\tisVertical: true\r\n\t\t});\r\n\t\tthis.colCoordCache = new CoordCache({\r\n\t\t\tels: this.cellEls.slice(0, this.colCnt), // only the first row\r\n\t\t\tisHorizontal: true\r\n\t\t});\r\n\r\n\t\t// trigger dayRender with each cell's element\r\n\t\tfor (row = 0; row < rowCnt; row++) {\r\n\t\t\tfor (col = 0; col < colCnt; col++) {\r\n\t\t\t\tthis.publiclyTrigger('dayRender', {\r\n\t\t\t\t\tcontext: view,\r\n\t\t\t\t\targs: [\r\n\t\t\t\t\t\tthis.getCellDate(row, col),\r\n\t\t\t\t\t\tthis.getCellEl(row, col),\r\n\t\t\t\t\t\tview\r\n\t\t\t\t\t]\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\r\n\t// Generates the HTML for a single row, which is a div that wraps a table.\r\n\t// `row` is the row number.\r\n\trenderDayRowHtml: function(row, isRigid) {\r\n\t\tvar theme = this.view.calendar.theme;\r\n\t\tvar classes = [ 'fc-row', 'fc-week', theme.getClass('dayRow') ];\r\n\r\n\t\tif (isRigid) {\r\n\t\t\tclasses.push('fc-rigid');\r\n\t\t}\r\n\r\n\t\treturn '' +\r\n\t\t\t'<div class=\"' + classes.join(' ') + '\">' +\r\n\t\t\t\t'<div class=\"fc-bg\">' +\r\n\t\t\t\t\t'<table class=\"' + theme.getClass('tableGrid') + '\">' +\r\n\t\t\t\t\t\tthis.renderBgTrHtml(row) +\r\n\t\t\t\t\t'</table>' +\r\n\t\t\t\t'</div>' +\r\n\t\t\t\t'<div class=\"fc-content-skeleton\">' +\r\n\t\t\t\t\t'<table>' +\r\n\t\t\t\t\t\t(this.getIsNumbersVisible() ?\r\n\t\t\t\t\t\t\t'<thead>' +\r\n\t\t\t\t\t\t\t\tthis.renderNumberTrHtml(row) +\r\n\t\t\t\t\t\t\t'</thead>' :\r\n\t\t\t\t\t\t\t''\r\n\t\t\t\t\t\t\t) +\r\n\t\t\t\t\t'</table>' +\r\n\t\t\t\t'</div>' +\r\n\t\t\t'</div>';\r\n\t},\r\n\r\n\r\n\tgetIsNumbersVisible: function() {\r\n\t\treturn this.getIsDayNumbersVisible() || this.cellWeekNumbersVisible;\r\n\t},\r\n\r\n\r\n\tgetIsDayNumbersVisible: function() {\r\n\t\treturn this.rowCnt > 1;\r\n\t},\r\n\r\n\r\n\t/* Grid Number Rendering\r\n\t------------------------------------------------------------------------------------------------------------------*/\r\n\r\n\r\n\trenderNumberTrHtml: function(row) {\r\n\t\treturn '' +\r\n\t\t\t'<tr>' +\r\n\t\t\t\t(this.isRTL ? '' : this.renderNumberIntroHtml(row)) +\r\n\t\t\t\tthis.renderNumberCellsHtml(row) +\r\n\t\t\t\t(this.isRTL ? this.renderNumberIntroHtml(row) : '') +\r\n\t\t\t'</tr>';\r\n\t},\r\n\r\n\r\n\trenderNumberIntroHtml: function(row) {\r\n\t\treturn this.renderIntroHtml();\r\n\t},\r\n\r\n\r\n\trenderNumberCellsHtml: function(row) {\r\n\t\tvar htmls = [];\r\n\t\tvar col, date;\r\n\r\n\t\tfor (col = 0; col < this.colCnt; col++) {\r\n\t\t\tdate = this.getCellDate(row, col);\r\n\t\t\thtmls.push(this.renderNumberCellHtml(date));\r\n\t\t}\r\n\r\n\t\treturn htmls.join('');\r\n\t},\r\n\r\n\r\n\t// Generates the HTML for the <td>s of the \"number\" row in the DayGrid's content skeleton.\r\n\t// The number row will only exist if either day numbers or week numbers are turned on.\r\n\trenderNumberCellHtml: function(date) {\r\n\t\tvar view = this.view;\r\n\t\tvar html = '';\r\n\t\tvar isDateValid = this.dateProfile.activeUnzonedRange.containsDate(date); // TODO: called too frequently. cache somehow.\r\n\t\tvar isDayNumberVisible = this.getIsDayNumbersVisible() && isDateValid;\r\n\t\tvar classes;\r\n\t\tvar weekCalcFirstDoW;\r\n\r\n\t\tif (!isDayNumberVisible && !this.cellWeekNumbersVisible) {\r\n\t\t\t// no numbers in day cell (week number must be along the side)\r\n\t\t\treturn '<td/>'; //  will create an empty space above events :(\r\n\t\t}\r\n\r\n\t\tclasses = this.getDayClasses(date);\r\n\t\tclasses.unshift('fc-day-top');\r\n\r\n\t\tif (this.cellWeekNumbersVisible) {\r\n\t\t\t// To determine the day of week number change under ISO, we cannot\r\n\t\t\t// rely on moment.js methods such as firstDayOfWeek() or weekday(),\r\n\t\t\t// because they rely on the locale's dow (possibly overridden by\r\n\t\t\t// our firstDay option), which may not be Monday. We cannot change\r\n\t\t\t// dow, because that would affect the calendar start day as well.\r\n\t\t\tif (date._locale._fullCalendar_weekCalc === 'ISO') {\r\n\t\t\t\tweekCalcFirstDoW = 1;  // Monday by ISO 8601 definition\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tweekCalcFirstDoW = date._locale.firstDayOfWeek();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\thtml += '<td class=\"' + classes.join(' ') + '\"' +\r\n\t\t\t(isDateValid ?\r\n\t\t\t\t' data-date=\"' + date.format() + '\"' :\r\n\t\t\t\t''\r\n\t\t\t\t) +\r\n\t\t\t'>';\r\n\r\n\t\tif (this.cellWeekNumbersVisible && (date.day() == weekCalcFirstDoW)) {\r\n\t\t\thtml += view.buildGotoAnchorHtml(\r\n\t\t\t\t{ date: date, type: 'week' },\r\n\t\t\t\t{ 'class': 'fc-week-number' },\r\n\t\t\t\tdate.format('w') // inner HTML\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\tif (isDayNumberVisible) {\r\n\t\t\thtml += view.buildGotoAnchorHtml(\r\n\t\t\t\tdate,\r\n\t\t\t\t{ 'class': 'fc-day-number' },\r\n\t\t\t\tdate.date() // inner HTML\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\thtml += '</td>';\r\n\r\n\t\treturn html;\r\n\t},\r\n\r\n\r\n\t/* Hit System\r\n\t------------------------------------------------------------------------------------------------------------------*/\r\n\r\n\r\n\tprepareHits: function() {\r\n\t\tthis.colCoordCache.build();\r\n\t\tthis.rowCoordCache.build();\r\n\t\tthis.rowCoordCache.bottoms[this.rowCnt - 1] += this.bottomCoordPadding; // hack\r\n\t},\r\n\r\n\r\n\treleaseHits: function() {\r\n\t\tthis.colCoordCache.clear();\r\n\t\tthis.rowCoordCache.clear();\r\n\t},\r\n\r\n\r\n\tqueryHit: function(leftOffset, topOffset) {\r\n\t\tif (this.colCoordCache.isLeftInBounds(leftOffset) && this.rowCoordCache.isTopInBounds(topOffset)) {\r\n\t\t\tvar col = this.colCoordCache.getHorizontalIndex(leftOffset);\r\n\t\t\tvar row = this.rowCoordCache.getVerticalIndex(topOffset);\r\n\r\n\t\t\tif (row != null && col != null) {\r\n\t\t\t\treturn this.getCellHit(row, col);\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\r\n\tgetHitFootprint: function(hit) {\r\n\t\tvar range = this.getCellRange(hit.row, hit.col);\r\n\r\n\t\treturn new ComponentFootprint(\r\n\t\t\tnew UnzonedRange(range.start, range.end),\r\n\t\t\ttrue // all-day?\r\n\t\t);\r\n\t},\r\n\r\n\r\n\tgetHitEl: function(hit) {\r\n\t\treturn this.getCellEl(hit.row, hit.col);\r\n\t},\r\n\r\n\r\n\t/* Cell System\r\n\t------------------------------------------------------------------------------------------------------------------*/\r\n\t// FYI: the first column is the leftmost column, regardless of date\r\n\r\n\r\n\tgetCellHit: function(row, col) {\r\n\t\treturn {\r\n\t\t\trow: row,\r\n\t\t\tcol: col,\r\n\t\t\tcomponent: this, // needed unfortunately :(\r\n\t\t\tleft: this.colCoordCache.getLeftOffset(col),\r\n\t\t\tright: this.colCoordCache.getRightOffset(col),\r\n\t\t\ttop: this.rowCoordCache.getTopOffset(row),\r\n\t\t\tbottom: this.rowCoordCache.getBottomOffset(row)\r\n\t\t};\r\n\t},\r\n\r\n\r\n\tgetCellEl: function(row, col) {\r\n\t\treturn this.cellEls.eq(row * this.colCnt + col);\r\n\t},\r\n\r\n\r\n\t/* Event Rendering\r\n\t------------------------------------------------------------------------------------------------------------------*/\r\n\r\n\r\n\t// Unrenders all events currently rendered on the grid\r\n\tunrenderEvents: function() {\r\n\t\tthis.removeSegPopover(); // removes the \"more..\" events popover\r\n\r\n\t\tInteractiveDateComponent.prototype.unrenderEvents.apply(this, arguments);\r\n\t},\r\n\r\n\r\n\t// Retrieves all rendered segment objects currently rendered on the grid\r\n\tgetOwnEventSegs: function() {\r\n\t\treturn InteractiveDateComponent.prototype.getOwnEventSegs.apply(this, arguments) // get the segments from the super-method\r\n\t\t\t.concat(this.popoverSegs || []); // append the segments from the \"more...\" popover\r\n\t},\r\n\r\n\r\n\t/* Event Drag Visualization\r\n\t------------------------------------------------------------------------------------------------------------------*/\r\n\r\n\r\n\t// Renders a visual indication of an event or external element being dragged.\r\n\t// `eventLocation` has zoned start and end (optional)\r\n\trenderDrag: function(eventFootprints, seg, isTouch) {\r\n\t\tvar i;\r\n\r\n\t\tfor (i = 0; i < eventFootprints.length; i++) {\r\n\t\t\tthis.renderHighlight(eventFootprints[i].componentFootprint);\r\n\t\t}\r\n\r\n\t\t// render drags from OTHER components as helpers\r\n\t\tif (eventFootprints.length && seg && seg.component !== this) {\r\n\t\t\tthis.helperRenderer.renderEventDraggingFootprints(eventFootprints, seg, isTouch);\r\n\r\n\t\t\treturn true; // signal helpers rendered\r\n\t\t}\r\n\t},\r\n\r\n\r\n\t// Unrenders any visual indication of a hovering event\r\n\tunrenderDrag: function(seg) {\r\n\t\tthis.unrenderHighlight();\r\n\t\tthis.helperRenderer.unrender();\r\n\t},\r\n\r\n\r\n\t/* Event Resize Visualization\r\n\t------------------------------------------------------------------------------------------------------------------*/\r\n\r\n\r\n\t// Renders a visual indication of an event being resized\r\n\trenderEventResize: function(eventFootprints, seg, isTouch) {\r\n\t\tvar i;\r\n\r\n\t\tfor (i = 0; i < eventFootprints.length; i++) {\r\n\t\t\tthis.renderHighlight(eventFootprints[i].componentFootprint);\r\n\t\t}\r\n\r\n\t\tthis.helperRenderer.renderEventResizingFootprints(eventFootprints, seg, isTouch);\r\n\t},\r\n\r\n\r\n\t// Unrenders a visual indication of an event being resized\r\n\tunrenderEventResize: function(seg) {\r\n\t\tthis.unrenderHighlight();\r\n\t\tthis.helperRenderer.unrender();\r\n\t}\r\n\r\n});\r\n\r\n;;\r\n\r\n/* Methods relate to limiting the number events for a given day on a DayGrid\r\n----------------------------------------------------------------------------------------------------------------------*/\r\n// NOTE: all the segs being passed around in here are foreground segs\r\n\r\nDayGrid.mixin({\r\n\r\n\tsegPopover: null, // the Popover that holds events that can't fit in a cell. null when not visible\r\n\tpopoverSegs: null, // an array of segment objects that the segPopover holds. null when not visible\r\n\r\n\r\n\tremoveSegPopover: function() {\r\n\t\tif (this.segPopover) {\r\n\t\t\tthis.segPopover.hide(); // in handler, will call segPopover's removeElement\r\n\t\t}\r\n\t},\r\n\r\n\r\n\t// Limits the number of \"levels\" (vertically stacking layers of events) for each row of the grid.\r\n\t// `levelLimit` can be false (don't limit), a number, or true (should be computed).\r\n\tlimitRows: function(levelLimit) {\r\n\t\tvar rowStructs = this.eventRenderer.rowStructs || [];\r\n\t\tvar row; // row #\r\n\t\tvar rowLevelLimit;\r\n\r\n\t\tfor (row = 0; row < rowStructs.length; row++) {\r\n\t\t\tthis.unlimitRow(row);\r\n\r\n\t\t\tif (!levelLimit) {\r\n\t\t\t\trowLevelLimit = false;\r\n\t\t\t}\r\n\t\t\telse if (typeof levelLimit === 'number') {\r\n\t\t\t\trowLevelLimit = levelLimit;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\trowLevelLimit = this.computeRowLevelLimit(row);\r\n\t\t\t}\r\n\r\n\t\t\tif (rowLevelLimit !== false) {\r\n\t\t\t\tthis.limitRow(row, rowLevelLimit);\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\r\n\t// Computes the number of levels a row will accomodate without going outside its bounds.\r\n\t// Assumes the row is \"rigid\" (maintains a constant height regardless of what is inside).\r\n\t// `row` is the row number.\r\n\tcomputeRowLevelLimit: function(row) {\r\n\t\tvar rowEl = this.rowEls.eq(row); // the containing \"fake\" row div\r\n\t\tvar rowHeight = rowEl.height(); // TODO: cache somehow?\r\n\t\tvar trEls = this.eventRenderer.rowStructs[row].tbodyEl.children();\r\n\t\tvar i, trEl;\r\n\t\tvar trHeight;\r\n\r\n\t\tfunction iterInnerHeights(i, childNode) {\r\n\t\t\ttrHeight = Math.max(trHeight, $(childNode).outerHeight());\r\n\t\t}\r\n\r\n\t\t// Reveal one level <tr> at a time and stop when we find one out of bounds\r\n\t\tfor (i = 0; i < trEls.length; i++) {\r\n\t\t\ttrEl = trEls.eq(i).removeClass('fc-limited'); // reset to original state (reveal)\r\n\r\n\t\t\t// with rowspans>1 and IE8, trEl.outerHeight() would return the height of the largest cell,\r\n\t\t\t// so instead, find the tallest inner content element.\r\n\t\t\ttrHeight = 0;\r\n\t\t\ttrEl.find('> td > :first-child').each(iterInnerHeights);\r\n\r\n\t\t\tif (trEl.position().top + trHeight > rowHeight) {\r\n\t\t\t\treturn i;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn false; // should not limit at all\r\n\t},\r\n\r\n\r\n\t// Limits the given grid row to the maximum number of levels and injects \"more\" links if necessary.\r\n\t// `row` is the row number.\r\n\t// `levelLimit` is a number for the maximum (inclusive) number of levels allowed.\r\n\tlimitRow: function(row, levelLimit) {\r\n\t\tvar _this = this;\r\n\t\tvar rowStruct = this.eventRenderer.rowStructs[row];\r\n\t\tvar moreNodes = []; // array of \"more\" <a> links and <td> DOM nodes\r\n\t\tvar col = 0; // col #, left-to-right (not chronologically)\r\n\t\tvar levelSegs; // array of segment objects in the last allowable level, ordered left-to-right\r\n\t\tvar cellMatrix; // a matrix (by level, then column) of all <td> jQuery elements in the row\r\n\t\tvar limitedNodes; // array of temporarily hidden level <tr> and segment <td> DOM nodes\r\n\t\tvar i, seg;\r\n\t\tvar segsBelow; // array of segment objects below `seg` in the current `col`\r\n\t\tvar totalSegsBelow; // total number of segments below `seg` in any of the columns `seg` occupies\r\n\t\tvar colSegsBelow; // array of segment arrays, below seg, one for each column (offset from segs's first column)\r\n\t\tvar td, rowspan;\r\n\t\tvar segMoreNodes; // array of \"more\" <td> cells that will stand-in for the current seg's cell\r\n\t\tvar j;\r\n\t\tvar moreTd, moreWrap, moreLink;\r\n\r\n\t\t// Iterates through empty level cells and places \"more\" links inside if need be\r\n\t\tfunction emptyCellsUntil(endCol) { // goes from current `col` to `endCol`\r\n\t\t\twhile (col < endCol) {\r\n\t\t\t\tsegsBelow = _this.getCellSegs(row, col, levelLimit);\r\n\t\t\t\tif (segsBelow.length) {\r\n\t\t\t\t\ttd = cellMatrix[levelLimit - 1][col];\r\n\t\t\t\t\tmoreLink = _this.renderMoreLink(row, col, segsBelow);\r\n\t\t\t\t\tmoreWrap = $('<div/>').append(moreLink);\r\n\t\t\t\t\ttd.append(moreWrap);\r\n\t\t\t\t\tmoreNodes.push(moreWrap[0]);\r\n\t\t\t\t}\r\n\t\t\t\tcol++;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (levelLimit && levelLimit < rowStruct.segLevels.length) { // is it actually over the limit?\r\n\t\t\tlevelSegs = rowStruct.segLevels[levelLimit - 1];\r\n\t\t\tcellMatrix = rowStruct.cellMatrix;\r\n\r\n\t\t\tlimitedNodes = rowStruct.tbodyEl.children().slice(levelLimit) // get level <tr> elements past the limit\r\n\t\t\t\t.addClass('fc-limited').get(); // hide elements and get a simple DOM-nodes array\r\n\r\n\t\t\t// iterate though segments in the last allowable level\r\n\t\t\tfor (i = 0; i < levelSegs.length; i++) {\r\n\t\t\t\tseg = levelSegs[i];\r\n\t\t\t\temptyCellsUntil(seg.leftCol); // process empty cells before the segment\r\n\r\n\t\t\t\t// determine *all* segments below `seg` that occupy the same columns\r\n\t\t\t\tcolSegsBelow = [];\r\n\t\t\t\ttotalSegsBelow = 0;\r\n\t\t\t\twhile (col <= seg.rightCol) {\r\n\t\t\t\t\tsegsBelow = this.getCellSegs(row, col, levelLimit);\r\n\t\t\t\t\tcolSegsBelow.push(segsBelow);\r\n\t\t\t\t\ttotalSegsBelow += segsBelow.length;\r\n\t\t\t\t\tcol++;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (totalSegsBelow) { // do we need to replace this segment with one or many \"more\" links?\r\n\t\t\t\t\ttd = cellMatrix[levelLimit - 1][seg.leftCol]; // the segment's parent cell\r\n\t\t\t\t\trowspan = td.attr('rowspan') || 1;\r\n\t\t\t\t\tsegMoreNodes = [];\r\n\r\n\t\t\t\t\t// make a replacement <td> for each column the segment occupies. will be one for each colspan\r\n\t\t\t\t\tfor (j = 0; j < colSegsBelow.length; j++) {\r\n\t\t\t\t\t\tmoreTd = $('<td class=\"fc-more-cell\"/>').attr('rowspan', rowspan);\r\n\t\t\t\t\t\tsegsBelow = colSegsBelow[j];\r\n\t\t\t\t\t\tmoreLink = this.renderMoreLink(\r\n\t\t\t\t\t\t\trow,\r\n\t\t\t\t\t\t\tseg.leftCol + j,\r\n\t\t\t\t\t\t\t[ seg ].concat(segsBelow) // count seg as hidden too\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\t\tmoreWrap = $('<div/>').append(moreLink);\r\n\t\t\t\t\t\tmoreTd.append(moreWrap);\r\n\t\t\t\t\t\tsegMoreNodes.push(moreTd[0]);\r\n\t\t\t\t\t\tmoreNodes.push(moreTd[0]);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\ttd.addClass('fc-limited').after($(segMoreNodes)); // hide original <td> and inject replacements\r\n\t\t\t\t\tlimitedNodes.push(td[0]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\temptyCellsUntil(this.colCnt); // finish off the level\r\n\t\t\trowStruct.moreEls = $(moreNodes); // for easy undoing later\r\n\t\t\trowStruct.limitedEls = $(limitedNodes); // for easy undoing later\r\n\t\t}\r\n\t},\r\n\r\n\r\n\t// Reveals all levels and removes all \"more\"-related elements for a grid's row.\r\n\t// `row` is a row number.\r\n\tunlimitRow: function(row) {\r\n\t\tvar rowStruct = this.eventRenderer.rowStructs[row];\r\n\r\n\t\tif (rowStruct.moreEls) {\r\n\t\t\trowStruct.moreEls.remove();\r\n\t\t\trowStruct.moreEls = null;\r\n\t\t}\r\n\r\n\t\tif (rowStruct.limitedEls) {\r\n\t\t\trowStruct.limitedEls.removeClass('fc-limited');\r\n\t\t\trowStruct.limitedEls = null;\r\n\t\t}\r\n\t},\r\n\r\n\r\n\t// Renders an <a> element that represents hidden event element for a cell.\r\n\t// Responsible for attaching click handler as well.\r\n\trenderMoreLink: function(row, col, hiddenSegs) {\r\n\t\tvar _this = this;\r\n\t\tvar view = this.view;\r\n\r\n\t\treturn $('<a class=\"fc-more\"/>')\r\n\t\t\t.text(\r\n\t\t\t\tthis.getMoreLinkText(hiddenSegs.length)\r\n\t\t\t)\r\n\t\t\t.on('click', function(ev) {\r\n\t\t\t\tvar clickOption = _this.opt('eventLimitClick');\r\n\t\t\t\tvar date = _this.getCellDate(row, col);\r\n\t\t\t\tvar moreEl = $(this);\r\n\t\t\t\tvar dayEl = _this.getCellEl(row, col);\r\n\t\t\t\tvar allSegs = _this.getCellSegs(row, col);\r\n\r\n\t\t\t\t// rescope the segments to be within the cell's date\r\n\t\t\t\tvar reslicedAllSegs = _this.resliceDaySegs(allSegs, date);\r\n\t\t\t\tvar reslicedHiddenSegs = _this.resliceDaySegs(hiddenSegs, date);\r\n\r\n\t\t\t\tif (typeof clickOption === 'function') {\r\n\t\t\t\t\t// the returned value can be an atomic option\r\n\t\t\t\t\tclickOption = _this.publiclyTrigger('eventLimitClick', {\r\n\t\t\t\t\t\tcontext: view,\r\n\t\t\t\t\t\targs: [\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tdate: date.clone(),\r\n\t\t\t\t\t\t\t\tdayEl: dayEl,\r\n\t\t\t\t\t\t\t\tmoreEl: moreEl,\r\n\t\t\t\t\t\t\t\tsegs: reslicedAllSegs,\r\n\t\t\t\t\t\t\t\thiddenSegs: reslicedHiddenSegs\r\n\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\tev,\r\n\t\t\t\t\t\t\tview\r\n\t\t\t\t\t\t]\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (clickOption === 'popover') {\r\n\t\t\t\t\t_this.showSegPopover(row, col, moreEl, reslicedAllSegs);\r\n\t\t\t\t}\r\n\t\t\t\telse if (typeof clickOption === 'string') { // a view name\r\n\t\t\t\t\tview.calendar.zoomTo(date, clickOption);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t},\r\n\r\n\r\n\t// Reveals the popover that displays all events within a cell\r\n\tshowSegPopover: function(row, col, moreLink, segs) {\r\n\t\tvar _this = this;\r\n\t\tvar view = this.view;\r\n\t\tvar moreWrap = moreLink.parent(); // the <div> wrapper around the <a>\r\n\t\tvar topEl; // the element we want to match the top coordinate of\r\n\t\tvar options;\r\n\r\n\t\tif (this.rowCnt == 1) {\r\n\t\t\ttopEl = view.el; // will cause the popover to cover any sort of header\r\n\t\t}\r\n\t\telse {\r\n\t\t\ttopEl = this.rowEls.eq(row); // will align with top of row\r\n\t\t}\r\n\r\n\t\toptions = {\r\n\t\t\tclassName: 'fc-more-popover ' + view.calendar.theme.getClass('popover'),\r\n\t\t\tcontent: this.renderSegPopoverContent(row, col, segs),\r\n\t\t\tparentEl: view.el, // attach to root of view. guarantees outside of scrollbars.\r\n\t\t\ttop: topEl.offset().top,\r\n\t\t\tautoHide: true, // when the user clicks elsewhere, hide the popover\r\n\t\t\tviewportConstrain: this.opt('popoverViewportConstrain'),\r\n\t\t\thide: function() {\r\n\t\t\t\t// kill everything when the popover is hidden\r\n\t\t\t\t// notify events to be removed\r\n\t\t\t\tif (_this.popoverSegs) {\r\n\t\t\t\t\t_this.triggerBeforeEventSegsDestroyed(_this.popoverSegs);\r\n\t\t\t\t}\r\n\t\t\t\t_this.segPopover.removeElement();\r\n\t\t\t\t_this.segPopover = null;\r\n\t\t\t\t_this.popoverSegs = null;\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\t// Determine horizontal coordinate.\r\n\t\t// We use the moreWrap instead of the <td> to avoid border confusion.\r\n\t\tif (this.isRTL) {\r\n\t\t\toptions.right = moreWrap.offset().left + moreWrap.outerWidth() + 1; // +1 to be over cell border\r\n\t\t}\r\n\t\telse {\r\n\t\t\toptions.left = moreWrap.offset().left - 1; // -1 to be over cell border\r\n\t\t}\r\n\r\n\t\tthis.segPopover = new Popover(options);\r\n\t\tthis.segPopover.show();\r\n\r\n\t\t// the popover doesn't live within the grid's container element, and thus won't get the event\r\n\t\t// delegated-handlers for free. attach event-related handlers to the popover.\r\n\t\tthis.bindAllSegHandlersToEl(this.segPopover.el);\r\n\r\n\t\tthis.triggerAfterEventSegsRendered(segs);\r\n\t},\r\n\r\n\r\n\t// Builds the inner DOM contents of the segment popover\r\n\trenderSegPopoverContent: function(row, col, segs) {\r\n\t\tvar view = this.view;\r\n\t\tvar theme = view.calendar.theme;\r\n\t\tvar title = this.getCellDate(row, col).format(this.opt('dayPopoverFormat'));\r\n\t\tvar content = $(\r\n\t\t\t'<div class=\"fc-header ' + theme.getClass('popoverHeader') + '\">' +\r\n\t\t\t\t'<span class=\"fc-close ' + theme.getIconClass('close') + '\"></span>' +\r\n\t\t\t\t'<span class=\"fc-title\">' +\r\n\t\t\t\t\thtmlEscape(title) +\r\n\t\t\t\t'</span>' +\r\n\t\t\t\t'<div class=\"fc-clear\"/>' +\r\n\t\t\t'</div>' +\r\n\t\t\t'<div class=\"fc-body ' + theme.getClass('popoverContent') + '\">' +\r\n\t\t\t\t'<div class=\"fc-event-container\"></div>' +\r\n\t\t\t'</div>'\r\n\t\t);\r\n\t\tvar segContainer = content.find('.fc-event-container');\r\n\t\tvar i;\r\n\r\n\t\t// render each seg's `el` and only return the visible segs\r\n\t\tsegs = this.eventRenderer.renderFgSegEls(segs, true); // disableResizing=true\r\n\t\tthis.popoverSegs = segs;\r\n\r\n\t\tfor (i = 0; i < segs.length; i++) {\r\n\r\n\t\t\t// because segments in the popover are not part of a grid coordinate system, provide a hint to any\r\n\t\t\t// grids that want to do drag-n-drop about which cell it came from\r\n\t\t\tthis.hitsNeeded();\r\n\t\t\tsegs[i].hit = this.getCellHit(row, col);\r\n\t\t\tthis.hitsNotNeeded();\r\n\r\n\t\t\tsegContainer.append(segs[i].el);\r\n\t\t}\r\n\r\n\t\treturn content;\r\n\t},\r\n\r\n\r\n\t// Given the events within an array of segment objects, reslice them to be in a single day\r\n\tresliceDaySegs: function(segs, dayDate) {\r\n\t\tvar dayStart = dayDate.clone();\r\n\t\tvar dayEnd = dayStart.clone().add(1, 'days');\r\n\t\tvar dayRange = new UnzonedRange(dayStart, dayEnd);\r\n\t\tvar newSegs = [];\r\n\t\tvar i, seg;\r\n\t\tvar slicedRange;\r\n\r\n\t\tfor (i = 0; i < segs.length; i++) {\r\n\t\t\tseg = segs[i];\r\n\t\t\tslicedRange = seg.footprint.componentFootprint.unzonedRange.intersect(dayRange);\r\n\r\n\t\t\tif (slicedRange) {\r\n\t\t\t\tnewSegs.push(\r\n\t\t\t\t\t$.extend({}, seg, {\r\n\t\t\t\t\t\tfootprint: new EventFootprint(\r\n\t\t\t\t\t\t\tnew ComponentFootprint(\r\n\t\t\t\t\t\t\t\tslicedRange,\r\n\t\t\t\t\t\t\t\tseg.footprint.componentFootprint.isAllDay\r\n\t\t\t\t\t\t\t),\r\n\t\t\t\t\t\t\tseg.footprint.eventDef,\r\n\t\t\t\t\t\t\tseg.footprint.eventInstance\r\n\t\t\t\t\t\t),\r\n\t\t\t\t\t\tisStart: seg.isStart && slicedRange.isStart,\r\n\t\t\t\t\t\tisEnd: seg.isEnd && slicedRange.isEnd\r\n\t\t\t\t\t})\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// force an order because eventsToSegs doesn't guarantee one\r\n\t\t// TODO: research if still needed\r\n\t\tthis.eventRenderer.sortEventSegs(newSegs);\r\n\r\n\t\treturn newSegs;\r\n\t},\r\n\r\n\r\n\t// Generates the text that should be inside a \"more\" link, given the number of events it represents\r\n\tgetMoreLinkText: function(num) {\r\n\t\tvar opt = this.opt('eventLimitText');\r\n\r\n\t\tif (typeof opt === 'function') {\r\n\t\t\treturn opt(num);\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn '+' + num + ' ' + opt;\r\n\t\t}\r\n\t},\r\n\r\n\r\n\t// Returns segments within a given cell.\r\n\t// If `startLevel` is specified, returns only events including and below that level. Otherwise returns all segs.\r\n\tgetCellSegs: function(row, col, startLevel) {\r\n\t\tvar segMatrix = this.eventRenderer.rowStructs[row].segMatrix;\r\n\t\tvar level = startLevel || 0;\r\n\t\tvar segs = [];\r\n\t\tvar seg;\r\n\r\n\t\twhile (level < segMatrix.length) {\r\n\t\t\tseg = segMatrix[level][col];\r\n\t\t\tif (seg) {\r\n\t\t\t\tsegs.push(seg);\r\n\t\t\t}\r\n\t\t\tlevel++;\r\n\t\t}\r\n\r\n\t\treturn segs;\r\n\t}\r\n\r\n});\r\n\r\n;;\r\n\r\n/* An abstract class for the \"basic\" views, as well as month view. Renders one or more rows of day cells.\r\n----------------------------------------------------------------------------------------------------------------------*/\r\n// It is a manager for a DayGrid subcomponent, which does most of the heavy lifting.\r\n// It is responsible for managing width/height.\r\n\r\nvar BasicView = FC.BasicView = View.extend({\r\n\r\n\tscroller: null,\r\n\r\n\tdayGridClass: DayGrid, // class the dayGrid will be instantiated from (overridable by subclasses)\r\n\tdayGrid: null, // the main subcomponent that does most of the heavy lifting\r\n\r\n\tweekNumberWidth: null, // width of all the week-number cells running down the side\r\n\r\n\r\n\tconstructor: function() {\r\n\t\tView.apply(this, arguments);\r\n\r\n\t\tthis.dayGrid = this.instantiateDayGrid();\r\n\t\tthis.dayGrid.isRigid = this.hasRigidRows();\r\n\r\n\t\tif (this.opt('weekNumbers')) {\r\n\t\t\tif (this.opt('weekNumbersWithinDays')) {\r\n\t\t\t\tthis.dayGrid.cellWeekNumbersVisible = true;\r\n\t\t\t\tthis.dayGrid.colWeekNumbersVisible = false;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tthis.dayGrid.cellWeekNumbersVisible = false;\r\n\t\t\t\tthis.dayGrid.colWeekNumbersVisible = true;\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\tthis.addChild(this.dayGrid);\r\n\r\n\t\tthis.scroller = new Scroller({\r\n\t\t\toverflowX: 'hidden',\r\n\t\t\toverflowY: 'auto'\r\n\t\t});\r\n\t},\r\n\r\n\r\n\t// Generates the DayGrid object this view needs. Draws from this.dayGridClass\r\n\tinstantiateDayGrid: function() {\r\n\t\t// generate a subclass on the fly with BasicView-specific behavior\r\n\t\t// TODO: cache this subclass\r\n\t\tvar subclass = this.dayGridClass.extend(basicDayGridMethods);\r\n\r\n\t\treturn new subclass(this);\r\n\t},\r\n\r\n\r\n\t// Computes the date range that will be rendered.\r\n\tbuildRenderRange: function(currentUnzonedRange, currentRangeUnit, isRangeAllDay) {\r\n\t\tvar renderUnzonedRange = View.prototype.buildRenderRange.apply(this, arguments); // an UnzonedRange\r\n\t\tvar start = this.calendar.msToUtcMoment(renderUnzonedRange.startMs, isRangeAllDay);\r\n\t\tvar end = this.calendar.msToUtcMoment(renderUnzonedRange.endMs, isRangeAllDay);\r\n\r\n\t\t// year and month views should be aligned with weeks. this is already done for week\r\n\t\tif (/^(year|month)$/.test(currentRangeUnit)) {\r\n\t\t\tstart.startOf('week');\r\n\r\n\t\t\t// make end-of-week if not already\r\n\t\t\tif (end.weekday()) {\r\n\t\t\t\tend.add(1, 'week').startOf('week'); // exclusively move backwards\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn new UnzonedRange(start, end);\r\n\t},\r\n\r\n\r\n\texecuteDateRender: function(dateProfile) {\r\n\t\tthis.dayGrid.breakOnWeeks = /year|month|week/.test(dateProfile.currentRangeUnit);\r\n\r\n\t\tView.prototype.executeDateRender.apply(this, arguments);\r\n\t},\r\n\r\n\r\n\trenderSkeleton: function() {\r\n\t\tvar dayGridContainerEl;\r\n\t\tvar dayGridEl;\r\n\r\n\t\tthis.el.addClass('fc-basic-view').html(this.renderSkeletonHtml());\r\n\r\n\t\tthis.scroller.render();\r\n\r\n\t\tdayGridContainerEl = this.scroller.el.addClass('fc-day-grid-container');\r\n\t\tdayGridEl = $('<div class=\"fc-day-grid\" />').appendTo(dayGridContainerEl);\r\n\r\n\t\tthis.el.find('.fc-body > tr > td').append(dayGridContainerEl);\r\n\r\n\t\tthis.dayGrid.headContainerEl = this.el.find('.fc-head-container');\r\n\t\tthis.dayGrid.setElement(dayGridEl);\r\n\t},\r\n\r\n\r\n\tunrenderSkeleton: function() {\r\n\t\tthis.dayGrid.removeElement();\r\n\t\tthis.scroller.destroy();\r\n\t},\r\n\r\n\r\n\t// Builds the HTML skeleton for the view.\r\n\t// The day-grid component will render inside of a container defined by this HTML.\r\n\trenderSkeletonHtml: function() {\r\n\t\tvar theme = this.calendar.theme;\r\n\r\n\t\treturn '' +\r\n\t\t\t'<table class=\"' + theme.getClass('tableGrid') + '\">' +\r\n\t\t\t\t(this.opt('columnHeader') ?\r\n\t\t\t\t\t'<thead class=\"fc-head\">' +\r\n\t\t\t\t\t\t'<tr>' +\r\n\t\t\t\t\t\t\t'<td class=\"fc-head-container ' + theme.getClass('widgetHeader') + '\">&nbsp;</td>' +\r\n\t\t\t\t\t\t'</tr>' +\r\n\t\t\t\t\t'</thead>' :\r\n\t\t\t\t\t''\r\n\t\t\t\t\t) +\r\n\t\t\t\t'<tbody class=\"fc-body\">' +\r\n\t\t\t\t\t'<tr>' +\r\n\t\t\t\t\t\t'<td class=\"' + theme.getClass('widgetContent') + '\"></td>' +\r\n\t\t\t\t\t'</tr>' +\r\n\t\t\t\t'</tbody>' +\r\n\t\t\t'</table>';\r\n\t},\r\n\r\n\r\n\t// Generates an HTML attribute string for setting the width of the week number column, if it is known\r\n\tweekNumberStyleAttr: function() {\r\n\t\tif (this.weekNumberWidth !== null) {\r\n\t\t\treturn 'style=\"width:' + this.weekNumberWidth + 'px\"';\r\n\t\t}\r\n\t\treturn '';\r\n\t},\r\n\r\n\r\n\t// Determines whether each row should have a constant height\r\n\thasRigidRows: function() {\r\n\t\tvar eventLimit = this.opt('eventLimit');\r\n\r\n\t\treturn eventLimit && typeof eventLimit !== 'number';\r\n\t},\r\n\r\n\r\n\t/* Dimensions\r\n\t------------------------------------------------------------------------------------------------------------------*/\r\n\r\n\r\n\t// Refreshes the horizontal dimensions of the view\r\n\tupdateSize: function(totalHeight, isAuto, isResize) {\r\n\t\tvar eventLimit = this.opt('eventLimit');\r\n\t\tvar headRowEl = this.dayGrid.headContainerEl.find('.fc-row');\r\n\t\tvar scrollerHeight;\r\n\t\tvar scrollbarWidths;\r\n\r\n\t\t// hack to give the view some height prior to dayGrid's columns being rendered\r\n\t\t// TODO: separate setting height from scroller VS dayGrid.\r\n\t\tif (!this.dayGrid.rowEls) {\r\n\t\t\tif (!isAuto) {\r\n\t\t\t\tscrollerHeight = this.computeScrollerHeight(totalHeight);\r\n\t\t\t\tthis.scroller.setHeight(scrollerHeight);\r\n\t\t\t}\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tView.prototype.updateSize.apply(this, arguments);\r\n\r\n\t\tif (this.dayGrid.colWeekNumbersVisible) {\r\n\t\t\t// Make sure all week number cells running down the side have the same width.\r\n\t\t\t// Record the width for cells created later.\r\n\t\t\tthis.weekNumberWidth = matchCellWidths(\r\n\t\t\t\tthis.el.find('.fc-week-number')\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\t// reset all heights to be natural\r\n\t\tthis.scroller.clear();\r\n\t\tuncompensateScroll(headRowEl);\r\n\r\n\t\tthis.dayGrid.removeSegPopover(); // kill the \"more\" popover if displayed\r\n\r\n\t\t// is the event limit a constant level number?\r\n\t\tif (eventLimit && typeof eventLimit === 'number') {\r\n\t\t\tthis.dayGrid.limitRows(eventLimit); // limit the levels first so the height can redistribute after\r\n\t\t}\r\n\r\n\t\t// distribute the height to the rows\r\n\t\t// (totalHeight is a \"recommended\" value if isAuto)\r\n\t\tscrollerHeight = this.computeScrollerHeight(totalHeight);\r\n\t\tthis.setGridHeight(scrollerHeight, isAuto);\r\n\r\n\t\t// is the event limit dynamically calculated?\r\n\t\tif (eventLimit && typeof eventLimit !== 'number') {\r\n\t\t\tthis.dayGrid.limitRows(eventLimit); // limit the levels after the grid's row heights have been set\r\n\t\t}\r\n\r\n\t\tif (!isAuto) { // should we force dimensions of the scroll container?\r\n\r\n\t\t\tthis.scroller.setHeight(scrollerHeight);\r\n\t\t\tscrollbarWidths = this.scroller.getScrollbarWidths();\r\n\r\n\t\t\tif (scrollbarWidths.left || scrollbarWidths.right) { // using scrollbars?\r\n\r\n\t\t\t\tcompensateScroll(headRowEl, scrollbarWidths);\r\n\r\n\t\t\t\t// doing the scrollbar compensation might have created text overflow which created more height. redo\r\n\t\t\t\tscrollerHeight = this.computeScrollerHeight(totalHeight);\r\n\t\t\t\tthis.scroller.setHeight(scrollerHeight);\r\n\t\t\t}\r\n\r\n\t\t\t// guarantees the same scrollbar widths\r\n\t\t\tthis.scroller.lockOverflow(scrollbarWidths);\r\n\t\t}\r\n\t},\r\n\r\n\r\n\t// given a desired total height of the view, returns what the height of the scroller should be\r\n\tcomputeScrollerHeight: function(totalHeight) {\r\n\t\treturn totalHeight -\r\n\t\t\tsubtractInnerElHeight(this.el, this.scroller.el); // everything that's NOT the scroller\r\n\t},\r\n\r\n\r\n\t// Sets the height of just the DayGrid component in this view\r\n\tsetGridHeight: function(height, isAuto) {\r\n\t\tif (isAuto) {\r\n\t\t\tundistributeHeight(this.dayGrid.rowEls); // let the rows be their natural height with no expanding\r\n\t\t}\r\n\t\telse {\r\n\t\t\tdistributeHeight(this.dayGrid.rowEls, height, true); // true = compensate for height-hogging rows\r\n\t\t}\r\n\t},\r\n\r\n\r\n\t/* Scroll\r\n\t------------------------------------------------------------------------------------------------------------------*/\r\n\r\n\r\n\tcomputeInitialDateScroll: function() {\r\n\t\treturn { top: 0 };\r\n\t},\r\n\r\n\r\n\tqueryDateScroll: function() {\r\n\t\treturn { top: this.scroller.getScrollTop() };\r\n\t},\r\n\r\n\r\n\tapplyDateScroll: function(scroll) {\r\n\t\tif (scroll.top !== undefined) {\r\n\t\t\tthis.scroller.setScrollTop(scroll.top);\r\n\t\t}\r\n\t}\r\n\r\n});\r\n\r\n\r\n// Methods that will customize the rendering behavior of the BasicView's dayGrid\r\nvar basicDayGridMethods = { // not relly methods anymore\r\n\r\n\r\n\tcolWeekNumbersVisible: false, // display week numbers along the side?\r\n\r\n\r\n\t// Generates the HTML that will go before the day-of week header cells\r\n\trenderHeadIntroHtml: function() {\r\n\t\tvar view = this.view;\r\n\r\n\t\tif (this.colWeekNumbersVisible) {\r\n\t\t\treturn '' +\r\n\t\t\t\t'<th class=\"fc-week-number ' + view.calendar.theme.getClass('widgetHeader') + '\" ' + view.weekNumberStyleAttr() + '>' +\r\n\t\t\t\t\t'<span>' + // needed for matchCellWidths\r\n\t\t\t\t\t\thtmlEscape(this.opt('weekNumberTitle')) +\r\n\t\t\t\t\t'</span>' +\r\n\t\t\t\t'</th>';\r\n\t\t}\r\n\r\n\t\treturn '';\r\n\t},\r\n\r\n\r\n\t// Generates the HTML that will go before content-skeleton cells that display the day/week numbers\r\n\trenderNumberIntroHtml: function(row) {\r\n\t\tvar view = this.view;\r\n\t\tvar weekStart = this.getCellDate(row, 0);\r\n\r\n\t\tif (this.colWeekNumbersVisible) {\r\n\t\t\treturn '' +\r\n\t\t\t\t'<td class=\"fc-week-number\" ' + view.weekNumberStyleAttr() + '>' +\r\n\t\t\t\t\tview.buildGotoAnchorHtml( // aside from link, important for matchCellWidths\r\n\t\t\t\t\t\t{ date: weekStart, type: 'week', forceOff: this.colCnt === 1 },\r\n\t\t\t\t\t\tweekStart.format('w') // inner HTML\r\n\t\t\t\t\t) +\r\n\t\t\t\t'</td>';\r\n\t\t}\r\n\r\n\t\treturn '';\r\n\t},\r\n\r\n\r\n\t// Generates the HTML that goes before the day bg cells for each day-row\r\n\trenderBgIntroHtml: function() {\r\n\t\tvar view = this.view;\r\n\r\n\t\tif (this.colWeekNumbersVisible) {\r\n\t\t\treturn '<td class=\"fc-week-number ' + view.calendar.theme.getClass('widgetContent') + '\" ' +\r\n\t\t\t\tview.weekNumberStyleAttr() + '></td>';\r\n\t\t}\r\n\r\n\t\treturn '';\r\n\t},\r\n\r\n\r\n\t// Generates the HTML that goes before every other type of row generated by DayGrid.\r\n\t// Affects helper-skeleton and highlight-skeleton rows.\r\n\trenderIntroHtml: function() {\r\n\t\tvar view = this.view;\r\n\r\n\t\tif (this.colWeekNumbersVisible) {\r\n\t\t\treturn '<td class=\"fc-week-number\" ' + view.weekNumberStyleAttr() + '></td>';\r\n\t\t}\r\n\r\n\t\treturn '';\r\n\t},\r\n\r\n\r\n\tgetIsNumbersVisible: function() {\r\n\t\treturn DayGrid.prototype.getIsNumbersVisible.apply(this, arguments) || this.colWeekNumbersVisible;\r\n\t}\r\n\r\n};\r\n\r\n;;\r\n\r\n/* A month view with day cells running in rows (one-per-week) and columns\r\n----------------------------------------------------------------------------------------------------------------------*/\r\n\r\nvar MonthView = FC.MonthView = BasicView.extend({\r\n\r\n\r\n\t// Computes the date range that will be rendered.\r\n\tbuildRenderRange: function(currentUnzonedRange, currentRangeUnit, isRangeAllDay) {\r\n\t\tvar renderUnzonedRange = BasicView.prototype.buildRenderRange.apply(this, arguments);\r\n\t\tvar start = this.calendar.msToUtcMoment(renderUnzonedRange.startMs, isRangeAllDay);\r\n\t\tvar end = this.calendar.msToUtcMoment(renderUnzonedRange.endMs, isRangeAllDay);\r\n\t\tvar rowCnt;\r\n\r\n\t\t// ensure 6 weeks\r\n\t\tif (this.isFixedWeeks()) {\r\n\t\t\trowCnt = Math.ceil( // could be partial weeks due to hiddenDays\r\n\t\t\t\tend.diff(start, 'weeks', true) // dontRound=true\r\n\t\t\t);\r\n\t\t\tend.add(6 - rowCnt, 'weeks');\r\n\t\t}\r\n\r\n\t\treturn new UnzonedRange(start, end);\r\n\t},\r\n\r\n\r\n\t// Overrides the default BasicView behavior to have special multi-week auto-height logic\r\n\tsetGridHeight: function(height, isAuto) {\r\n\r\n\t\t// if auto, make the height of each row the height that it would be if there were 6 weeks\r\n\t\tif (isAuto) {\r\n\t\t\theight *= this.rowCnt / 6;\r\n\t\t}\r\n\r\n\t\tdistributeHeight(this.dayGrid.rowEls, height, !isAuto); // if auto, don't compensate for height-hogging rows\r\n\t},\r\n\r\n\r\n\tisFixedWeeks: function() {\r\n\t\treturn this.opt('fixedWeekCount');\r\n\t},\r\n\r\n\r\n\tisDateInOtherMonth: function(date, dateProfile) {\r\n\t\treturn date.month() !== moment.utc(dateProfile.currentUnzonedRange.startMs).month(); // TODO: optimize\r\n\t}\r\n\r\n});\r\n\r\n;;\r\n\r\nfcViews.basic = {\r\n\t'class': BasicView\r\n};\r\n\r\nfcViews.basicDay = {\r\n\ttype: 'basic',\r\n\tduration: { days: 1 }\r\n};\r\n\r\nfcViews.basicWeek = {\r\n\ttype: 'basic',\r\n\tduration: { weeks: 1 }\r\n};\r\n\r\nfcViews.month = {\r\n\t'class': MonthView,\r\n\tduration: { months: 1 }, // important for prev/next\r\n\tdefaults: {\r\n\t\tfixedWeekCount: true\r\n\t}\r\n};\r\n;;\r\n\r\nvar TimeGridFillRenderer = FillRenderer.extend({\r\n\r\n\r\n\tattachSegEls: function(type, segs) {\r\n\t\tvar timeGrid = this.component;\r\n\t\tvar containerEls;\r\n\r\n\t\t// TODO: more efficient lookup\r\n\t\tif (type === 'bgEvent') {\r\n\t\t\tcontainerEls = timeGrid.bgContainerEls;\r\n\t\t}\r\n\t\telse if (type === 'businessHours') {\r\n\t\t\tcontainerEls = timeGrid.businessContainerEls;\r\n\t\t}\r\n\t\telse if (type === 'highlight') {\r\n\t\t\tcontainerEls = timeGrid.highlightContainerEls;\r\n\t\t}\r\n\r\n\t\ttimeGrid.updateSegVerticals(segs);\r\n\t\ttimeGrid.attachSegsByCol(timeGrid.groupSegsByCol(segs), containerEls);\r\n\r\n\t\treturn segs.map(function(seg) {\r\n\t\t\treturn seg.el[0];\r\n\t\t});\r\n\t}\r\n\r\n});\r\n\r\n;;\r\n\r\n/*\r\nOnly handles foreground segs.\r\nDoes not own rendering. Use for low-level util methods by TimeGrid.\r\n*/\r\nvar TimeGridEventRenderer = EventRenderer.extend({\r\n\r\n\ttimeGrid: null,\r\n\r\n\r\n\tconstructor: function(timeGrid) {\r\n\t\tEventRenderer.apply(this, arguments);\r\n\r\n\t\tthis.timeGrid = timeGrid;\r\n\t},\r\n\r\n\r\n\trenderFgSegs: function(segs) {\r\n\t\tthis.renderFgSegsIntoContainers(segs, this.timeGrid.fgContainerEls);\r\n\t},\r\n\r\n\r\n\t// Given an array of foreground segments, render a DOM element for each, computes position,\r\n\t// and attaches to the column inner-container elements.\r\n\trenderFgSegsIntoContainers: function(segs, containerEls) {\r\n\t\tvar segsByCol;\r\n\t\tvar col;\r\n\r\n\t\tsegsByCol = this.timeGrid.groupSegsByCol(segs);\r\n\r\n\t\tfor (col = 0; col < this.timeGrid.colCnt; col++) {\r\n\t\t\tthis.updateFgSegCoords(segsByCol[col]);\r\n\t\t}\r\n\r\n\t\tthis.timeGrid.attachSegsByCol(segsByCol, containerEls);\r\n\t},\r\n\r\n\r\n\tunrenderFgSegs: function() {\r\n\t\tif (this.fgSegs) { // hack\r\n\t\t\tthis.fgSegs.forEach(function(seg) {\r\n\t\t\t\tseg.el.remove();\r\n\t\t\t});\r\n\t\t}\r\n\t},\r\n\r\n\r\n\t// Computes a default event time formatting string if `timeFormat` is not explicitly defined\r\n\tcomputeEventTimeFormat: function() {\r\n\t\treturn this.opt('noMeridiemTimeFormat'); // like \"6:30\" (no AM/PM)\r\n\t},\r\n\r\n\r\n\t// Computes a default `displayEventEnd` value if one is not expliclty defined\r\n\tcomputeDisplayEventEnd: function() {\r\n\t\treturn true;\r\n\t},\r\n\r\n\r\n\t// Renders the HTML for a single event segment's default rendering\r\n\tfgSegHtml: function(seg, disableResizing) {\r\n\t\tvar view = this.view;\r\n\t\tvar calendar = view.calendar;\r\n\t\tvar componentFootprint = seg.footprint.componentFootprint;\r\n\t\tvar isAllDay = componentFootprint.isAllDay;\r\n\t\tvar eventDef = seg.footprint.eventDef;\r\n\t\tvar isDraggable = view.isEventDefDraggable(eventDef);\r\n\t\tvar isResizableFromStart = !disableResizing && seg.isStart && view.isEventDefResizableFromStart(eventDef);\r\n\t\tvar isResizableFromEnd = !disableResizing && seg.isEnd && view.isEventDefResizableFromEnd(eventDef);\r\n\t\tvar classes = this.getSegClasses(seg, isDraggable, isResizableFromStart || isResizableFromEnd);\r\n\t\tvar skinCss = cssToStr(this.getSkinCss(eventDef));\r\n\t\tvar timeText;\r\n\t\tvar fullTimeText; // more verbose time text. for the print stylesheet\r\n\t\tvar startTimeText; // just the start time text\r\n\r\n\t\tclasses.unshift('fc-time-grid-event', 'fc-v-event');\r\n\r\n\t\t// if the event appears to span more than one day...\r\n\t\tif (view.isMultiDayRange(componentFootprint.unzonedRange)) {\r\n\t\t\t// Don't display time text on segments that run entirely through a day.\r\n\t\t\t// That would appear as midnight-midnight and would look dumb.\r\n\t\t\t// Otherwise, display the time text for the *segment's* times (like 6pm-midnight or midnight-10am)\r\n\t\t\tif (seg.isStart || seg.isEnd) {\r\n\t\t\t\tvar zonedStart = calendar.msToMoment(seg.startMs);\r\n\t\t\t\tvar zonedEnd = calendar.msToMoment(seg.endMs);\r\n\t\t\t\ttimeText = this._getTimeText(zonedStart, zonedEnd, isAllDay);\r\n\t\t\t\tfullTimeText = this._getTimeText(zonedStart, zonedEnd, isAllDay, 'LT');\r\n\t\t\t\tstartTimeText = this._getTimeText(zonedStart, zonedEnd, isAllDay, null, false); // displayEnd=false\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\t// Display the normal time text for the *event's* times\r\n\t\t\ttimeText = this.getTimeText(seg.footprint);\r\n\t\t\tfullTimeText = this.getTimeText(seg.footprint, 'LT');\r\n\t\t\tstartTimeText = this.getTimeText(seg.footprint, null, false); // displayEnd=false\r\n\t\t}\r\n\r\n\t\treturn '<a class=\"' + classes.join(' ') + '\"' +\r\n\t\t\t(eventDef.url ?\r\n\t\t\t\t' href=\"' + htmlEscape(eventDef.url) + '\"' :\r\n\t\t\t\t''\r\n\t\t\t\t) +\r\n\t\t\t(skinCss ?\r\n\t\t\t\t' style=\"' + skinCss + '\"' :\r\n\t\t\t\t''\r\n\t\t\t\t) +\r\n\t\t\t'>' +\r\n\t\t\t\t'<div class=\"fc-content\">' +\r\n\t\t\t\t\t(timeText ?\r\n\t\t\t\t\t\t'<div class=\"fc-time\"' +\r\n\t\t\t\t\t\t' data-start=\"' + htmlEscape(startTimeText) + '\"' +\r\n\t\t\t\t\t\t' data-full=\"' + htmlEscape(fullTimeText) + '\"' +\r\n\t\t\t\t\t\t'>' +\r\n\t\t\t\t\t\t\t'<span>' + htmlEscape(timeText) + '</span>' +\r\n\t\t\t\t\t\t'</div>' :\r\n\t\t\t\t\t\t''\r\n\t\t\t\t\t\t) +\r\n\t\t\t\t\t(eventDef.title ?\r\n\t\t\t\t\t\t'<div class=\"fc-title\">' +\r\n\t\t\t\t\t\t\thtmlEscape(eventDef.title) +\r\n\t\t\t\t\t\t'</div>' :\r\n\t\t\t\t\t\t''\r\n\t\t\t\t\t\t) +\r\n\t\t\t\t'</div>' +\r\n\t\t\t\t'<div class=\"fc-bg\"/>' +\r\n\t\t\t\t/* TODO: write CSS for this\r\n\t\t\t\t(isResizableFromStart ?\r\n\t\t\t\t\t'<div class=\"fc-resizer fc-start-resizer\" />' :\r\n\t\t\t\t\t''\r\n\t\t\t\t\t) +\r\n\t\t\t\t*/\r\n\t\t\t\t(isResizableFromEnd ?\r\n\t\t\t\t\t'<div class=\"fc-resizer fc-end-resizer\" />' :\r\n\t\t\t\t\t''\r\n\t\t\t\t\t) +\r\n\t\t\t'</a>';\r\n\t},\r\n\r\n\r\n\t// Given segments that are assumed to all live in the *same column*,\r\n\t// compute their verical/horizontal coordinates and assign to their elements.\r\n\tupdateFgSegCoords: function(segs) {\r\n\t\tthis.timeGrid.computeSegVerticals(segs); // horizontals relies on this\r\n\t\tthis.computeFgSegHorizontals(segs); // compute horizontal coordinates, z-index's, and reorder the array\r\n\t\tthis.timeGrid.assignSegVerticals(segs);\r\n\t\tthis.assignFgSegHorizontals(segs);\r\n\t},\r\n\r\n\r\n\t// Given an array of segments that are all in the same column, sets the backwardCoord and forwardCoord on each.\r\n\t// NOTE: Also reorders the given array by date!\r\n\tcomputeFgSegHorizontals: function(segs) {\r\n\t\tvar levels;\r\n\t\tvar level0;\r\n\t\tvar i;\r\n\r\n\t\tthis.sortEventSegs(segs); // order by certain criteria\r\n\t\tlevels = buildSlotSegLevels(segs);\r\n\t\tcomputeForwardSlotSegs(levels);\r\n\r\n\t\tif ((level0 = levels[0])) {\r\n\r\n\t\t\tfor (i = 0; i < level0.length; i++) {\r\n\t\t\t\tcomputeSlotSegPressures(level0[i]);\r\n\t\t\t}\r\n\r\n\t\t\tfor (i = 0; i < level0.length; i++) {\r\n\t\t\t\tthis.computeFgSegForwardBack(level0[i], 0, 0);\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\r\n\t// Calculate seg.forwardCoord and seg.backwardCoord for the segment, where both values range\r\n\t// from 0 to 1. If the calendar is left-to-right, the seg.backwardCoord maps to \"left\" and\r\n\t// seg.forwardCoord maps to \"right\" (via percentage). Vice-versa if the calendar is right-to-left.\r\n\t//\r\n\t// The segment might be part of a \"series\", which means consecutive segments with the same pressure\r\n\t// who's width is unknown until an edge has been hit. `seriesBackwardPressure` is the number of\r\n\t// segments behind this one in the current series, and `seriesBackwardCoord` is the starting\r\n\t// coordinate of the first segment in the series.\r\n\tcomputeFgSegForwardBack: function(seg, seriesBackwardPressure, seriesBackwardCoord) {\r\n\t\tvar forwardSegs = seg.forwardSegs;\r\n\t\tvar i;\r\n\r\n\t\tif (seg.forwardCoord === undefined) { // not already computed\r\n\r\n\t\t\tif (!forwardSegs.length) {\r\n\r\n\t\t\t\t// if there are no forward segments, this segment should butt up against the edge\r\n\t\t\t\tseg.forwardCoord = 1;\r\n\t\t\t}\r\n\t\t\telse {\r\n\r\n\t\t\t\t// sort highest pressure first\r\n\t\t\t\tthis.sortForwardSegs(forwardSegs);\r\n\r\n\t\t\t\t// this segment's forwardCoord will be calculated from the backwardCoord of the\r\n\t\t\t\t// highest-pressure forward segment.\r\n\t\t\t\tthis.computeFgSegForwardBack(forwardSegs[0], seriesBackwardPressure + 1, seriesBackwardCoord);\r\n\t\t\t\tseg.forwardCoord = forwardSegs[0].backwardCoord;\r\n\t\t\t}\r\n\r\n\t\t\t// calculate the backwardCoord from the forwardCoord. consider the series\r\n\t\t\tseg.backwardCoord = seg.forwardCoord -\r\n\t\t\t\t(seg.forwardCoord - seriesBackwardCoord) / // available width for series\r\n\t\t\t\t(seriesBackwardPressure + 1); // # of segments in the series\r\n\r\n\t\t\t// use this segment's coordinates to computed the coordinates of the less-pressurized\r\n\t\t\t// forward segments\r\n\t\t\tfor (i=0; i<forwardSegs.length; i++) {\r\n\t\t\t\tthis.computeFgSegForwardBack(forwardSegs[i], 0, seg.forwardCoord);\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\r\n\tsortForwardSegs: function(forwardSegs) {\r\n\t\tforwardSegs.sort(proxy(this, 'compareForwardSegs'));\r\n\t},\r\n\r\n\r\n\t// A cmp function for determining which forward segment to rely on more when computing coordinates.\r\n\tcompareForwardSegs: function(seg1, seg2) {\r\n\t\t// put higher-pressure first\r\n\t\treturn seg2.forwardPressure - seg1.forwardPressure ||\r\n\t\t\t// put segments that are closer to initial edge first (and favor ones with no coords yet)\r\n\t\t\t(seg1.backwardCoord || 0) - (seg2.backwardCoord || 0) ||\r\n\t\t\t// do normal sorting...\r\n\t\t\tthis.compareEventSegs(seg1, seg2);\r\n\t},\r\n\r\n\r\n\t// Given foreground event segments that have already had their position coordinates computed,\r\n\t// assigns position-related CSS values to their elements.\r\n\tassignFgSegHorizontals: function(segs) {\r\n\t\tvar i, seg;\r\n\r\n\t\tfor (i = 0; i < segs.length; i++) {\r\n\t\t\tseg = segs[i];\r\n\t\t\tseg.el.css(this.generateFgSegHorizontalCss(seg));\r\n\r\n\t\t\t// if the height is short, add a className for alternate styling\r\n\t\t\tif (seg.bottom - seg.top < 30) {\r\n\t\t\t\tseg.el.addClass('fc-short');\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\r\n\t// Generates an object with CSS properties/values that should be applied to an event segment element.\r\n\t// Contains important positioning-related properties that should be applied to any event element, customized or not.\r\n\tgenerateFgSegHorizontalCss: function(seg) {\r\n\t\tvar shouldOverlap = this.opt('slotEventOverlap');\r\n\t\tvar backwardCoord = seg.backwardCoord; // the left side if LTR. the right side if RTL. floating-point\r\n\t\tvar forwardCoord = seg.forwardCoord; // the right side if LTR. the left side if RTL. floating-point\r\n\t\tvar props = this.timeGrid.generateSegVerticalCss(seg); // get top/bottom first\r\n\t\tvar left; // amount of space from left edge, a fraction of the total width\r\n\t\tvar right; // amount of space from right edge, a fraction of the total width\r\n\r\n\t\tif (shouldOverlap) {\r\n\t\t\t// double the width, but don't go beyond the maximum forward coordinate (1.0)\r\n\t\t\tforwardCoord = Math.min(1, backwardCoord + (forwardCoord - backwardCoord) * 2);\r\n\t\t}\r\n\r\n\t\tif (this.timeGrid.isRTL) {\r\n\t\t\tleft = 1 - forwardCoord;\r\n\t\t\tright = backwardCoord;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tleft = backwardCoord;\r\n\t\t\tright = 1 - forwardCoord;\r\n\t\t}\r\n\r\n\t\tprops.zIndex = seg.level + 1; // convert from 0-base to 1-based\r\n\t\tprops.left = left * 100 + '%';\r\n\t\tprops.right = right * 100 + '%';\r\n\r\n\t\tif (shouldOverlap && seg.forwardPressure) {\r\n\t\t\t// add padding to the edge so that forward stacked events don't cover the resizer's icon\r\n\t\t\tprops[this.isRTL ? 'marginLeft' : 'marginRight'] = 10 * 2; // 10 is a guesstimate of the icon's width\r\n\t\t}\r\n\r\n\t\treturn props;\r\n\t}\r\n\r\n});\r\n\r\n\r\n// Builds an array of segments \"levels\". The first level will be the leftmost tier of segments if the calendar is\r\n// left-to-right, or the rightmost if the calendar is right-to-left. Assumes the segments are already ordered by date.\r\nfunction buildSlotSegLevels(segs) {\r\n\tvar levels = [];\r\n\tvar i, seg;\r\n\tvar j;\r\n\r\n\tfor (i=0; i<segs.length; i++) {\r\n\t\tseg = segs[i];\r\n\r\n\t\t// go through all the levels and stop on the first level where there are no collisions\r\n\t\tfor (j=0; j<levels.length; j++) {\r\n\t\t\tif (!computeSlotSegCollisions(seg, levels[j]).length) {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tseg.level = j;\r\n\r\n\t\t(levels[j] || (levels[j] = [])).push(seg);\r\n\t}\r\n\r\n\treturn levels;\r\n}\r\n\r\n\r\n// For every segment, figure out the other segments that are in subsequent\r\n// levels that also occupy the same vertical space. Accumulate in seg.forwardSegs\r\nfunction computeForwardSlotSegs(levels) {\r\n\tvar i, level;\r\n\tvar j, seg;\r\n\tvar k;\r\n\r\n\tfor (i=0; i<levels.length; i++) {\r\n\t\tlevel = levels[i];\r\n\r\n\t\tfor (j=0; j<level.length; j++) {\r\n\t\t\tseg = level[j];\r\n\r\n\t\t\tseg.forwardSegs = [];\r\n\t\t\tfor (k=i+1; k<levels.length; k++) {\r\n\t\t\t\tcomputeSlotSegCollisions(seg, levels[k], seg.forwardSegs);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\n\r\n// Figure out which path forward (via seg.forwardSegs) results in the longest path until\r\n// the furthest edge is reached. The number of segments in this path will be seg.forwardPressure\r\nfunction computeSlotSegPressures(seg) {\r\n\tvar forwardSegs = seg.forwardSegs;\r\n\tvar forwardPressure = 0;\r\n\tvar i, forwardSeg;\r\n\r\n\tif (seg.forwardPressure === undefined) { // not already computed\r\n\r\n\t\tfor (i=0; i<forwardSegs.length; i++) {\r\n\t\t\tforwardSeg = forwardSegs[i];\r\n\r\n\t\t\t// figure out the child's maximum forward path\r\n\t\t\tcomputeSlotSegPressures(forwardSeg);\r\n\r\n\t\t\t// either use the existing maximum, or use the child's forward pressure\r\n\t\t\t// plus one (for the forwardSeg itself)\r\n\t\t\tforwardPressure = Math.max(\r\n\t\t\t\tforwardPressure,\r\n\t\t\t\t1 + forwardSeg.forwardPressure\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\tseg.forwardPressure = forwardPressure;\r\n\t}\r\n}\r\n\r\n\r\n// Find all the segments in `otherSegs` that vertically collide with `seg`.\r\n// Append into an optionally-supplied `results` array and return.\r\nfunction computeSlotSegCollisions(seg, otherSegs, results) {\r\n\tresults = results || [];\r\n\r\n\tfor (var i=0; i<otherSegs.length; i++) {\r\n\t\tif (isSlotSegCollision(seg, otherSegs[i])) {\r\n\t\t\tresults.push(otherSegs[i]);\r\n\t\t}\r\n\t}\r\n\r\n\treturn results;\r\n}\r\n\r\n\r\n// Do these segments occupy the same vertical space?\r\nfunction isSlotSegCollision(seg1, seg2) {\r\n\treturn seg1.bottom > seg2.top && seg1.top < seg2.bottom;\r\n}\r\n\r\n;;\r\n\r\nvar TimeGridHelperRenderer = HelperRenderer.extend({\r\n\r\n\r\n\trenderSegs: function(segs, sourceSeg) {\r\n\t\tvar helperNodes = [];\r\n\t\tvar i, seg;\r\n\t\tvar sourceEl;\r\n\r\n\t\t// TODO: not good to call eventRenderer this way\r\n\t\tthis.eventRenderer.renderFgSegsIntoContainers(\r\n\t\t\tsegs,\r\n\t\t\tthis.component.helperContainerEls\r\n\t\t);\r\n\r\n\t\t// Try to make the segment that is in the same row as sourceSeg look the same\r\n\t\tfor (i = 0; i < segs.length; i++) {\r\n\t\t\tseg = segs[i];\r\n\r\n\t\t\tif (sourceSeg && sourceSeg.col === seg.col) {\r\n\t\t\t\tsourceEl = sourceSeg.el;\r\n\t\t\t\tseg.el.css({\r\n\t\t\t\t\tleft: sourceEl.css('left'),\r\n\t\t\t\t\tright: sourceEl.css('right'),\r\n\t\t\t\t\t'margin-left': sourceEl.css('margin-left'),\r\n\t\t\t\t\t'margin-right': sourceEl.css('margin-right')\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\thelperNodes.push(seg.el[0]);\r\n\t\t}\r\n\r\n\t\treturn $(helperNodes); // must return the elements rendered\r\n\t}\r\n\r\n});\r\n\r\n;;\r\n\r\n/* A component that renders one or more columns of vertical time slots\r\n----------------------------------------------------------------------------------------------------------------------*/\r\n// We mixin DayTable, even though there is only a single row of days\r\n\r\nvar TimeGrid = FC.TimeGrid = InteractiveDateComponent.extend(StandardInteractionsMixin, DayTableMixin, {\r\n\r\n\teventRendererClass: TimeGridEventRenderer,\r\n\tbusinessHourRendererClass: BusinessHourRenderer,\r\n\thelperRendererClass: TimeGridHelperRenderer,\r\n\tfillRendererClass: TimeGridFillRenderer,\r\n\r\n\tview: null, // TODO: make more general and/or remove\r\n\thelperRenderer: null,\r\n\r\n\tdayRanges: null, // UnzonedRange[], of start-end of each day\r\n\tslotDuration: null, // duration of a \"slot\", a distinct time segment on given day, visualized by lines\r\n\tsnapDuration: null, // granularity of time for dragging and selecting\r\n\tsnapsPerSlot: null,\r\n\tlabelFormat: null, // formatting string for times running along vertical axis\r\n\tlabelInterval: null, // duration of how often a label should be displayed for a slot\r\n\r\n\theadContainerEl: null, // div that hold's the date header\r\n\tcolEls: null, // cells elements in the day-row background\r\n\tslatContainerEl: null, // div that wraps all the slat rows\r\n\tslatEls: null, // elements running horizontally across all columns\r\n\tnowIndicatorEls: null,\r\n\r\n\tcolCoordCache: null,\r\n\tslatCoordCache: null,\r\n\r\n\tbottomRuleEl: null, // hidden by default\r\n\tcolContainerEls: null, // containers for each column\r\n\r\n\t// inner-containers for each column where different types of segs live\r\n\tfgContainerEls: null,\r\n\tbgContainerEls: null,\r\n\thelperContainerEls: null,\r\n\thighlightContainerEls: null,\r\n\tbusinessContainerEls: null,\r\n\r\n\t// arrays of different types of displayed segments\r\n\thelperSegs: null,\r\n\thighlightSegs: null,\r\n\tbusinessSegs: null,\r\n\r\n\r\n\tconstructor: function(view) {\r\n\t\tthis.view = view; // do first, for opt calls during initialization\r\n\r\n\t\tInteractiveDateComponent.call(this); // call the super-constructor\r\n\r\n\t\tthis.processOptions();\r\n\t},\r\n\r\n\r\n\t// Slices up the given span (unzoned start/end with other misc data) into an array of segments\r\n\tcomponentFootprintToSegs: function(componentFootprint) {\r\n\t\tvar segs = this.sliceRangeByTimes(componentFootprint.unzonedRange);\r\n\t\tvar i;\r\n\r\n\t\tfor (i = 0; i < segs.length; i++) {\r\n\t\t\tif (this.isRTL) {\r\n\t\t\t\tsegs[i].col = this.daysPerRow - 1 - segs[i].dayIndex;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tsegs[i].col = segs[i].dayIndex;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn segs;\r\n\t},\r\n\r\n\r\n\t/* Date Handling\r\n\t------------------------------------------------------------------------------------------------------------------*/\r\n\r\n\r\n\tsliceRangeByTimes: function(unzonedRange) {\r\n\t\tvar segs = [];\r\n\t\tvar segRange;\r\n\t\tvar dayIndex;\r\n\r\n\t\tfor (dayIndex = 0; dayIndex < this.daysPerRow; dayIndex++) {\r\n\r\n\t\t\tsegRange = unzonedRange.intersect(this.dayRanges[dayIndex]);\r\n\r\n\t\t\tif (segRange) {\r\n\t\t\t\tsegs.push({\r\n\t\t\t\t\tstartMs: segRange.startMs,\r\n\t\t\t\t\tendMs: segRange.endMs,\r\n\t\t\t\t\tisStart: segRange.isStart,\r\n\t\t\t\t\tisEnd: segRange.isEnd,\r\n\t\t\t\t\tdayIndex: dayIndex\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn segs;\r\n\t},\r\n\r\n\r\n\t/* Options\r\n\t------------------------------------------------------------------------------------------------------------------*/\r\n\r\n\r\n\t// Parses various options into properties of this object\r\n\tprocessOptions: function() {\r\n\t\tvar slotDuration = this.opt('slotDuration');\r\n\t\tvar snapDuration = this.opt('snapDuration');\r\n\t\tvar input;\r\n\r\n\t\tslotDuration = moment.duration(slotDuration);\r\n\t\tsnapDuration = snapDuration ? moment.duration(snapDuration) : slotDuration;\r\n\r\n\t\tthis.slotDuration = slotDuration;\r\n\t\tthis.snapDuration = snapDuration;\r\n\t\tthis.snapsPerSlot = slotDuration / snapDuration; // TODO: ensure an integer multiple?\r\n\r\n\t\t// might be an array value (for TimelineView).\r\n\t\t// if so, getting the most granular entry (the last one probably).\r\n\t\tinput = this.opt('slotLabelFormat');\r\n\t\tif ($.isArray(input)) {\r\n\t\t\tinput = input[input.length - 1];\r\n\t\t}\r\n\r\n\t\tthis.labelFormat = input ||\r\n\t\t\tthis.opt('smallTimeFormat'); // the computed default\r\n\r\n\t\tinput = this.opt('slotLabelInterval');\r\n\t\tthis.labelInterval = input ?\r\n\t\t\tmoment.duration(input) :\r\n\t\t\tthis.computeLabelInterval(slotDuration);\r\n\t},\r\n\r\n\r\n\t// Computes an automatic value for slotLabelInterval\r\n\tcomputeLabelInterval: function(slotDuration) {\r\n\t\tvar i;\r\n\t\tvar labelInterval;\r\n\t\tvar slotsPerLabel;\r\n\r\n\t\t// find the smallest stock label interval that results in more than one slots-per-label\r\n\t\tfor (i = AGENDA_STOCK_SUB_DURATIONS.length - 1; i >= 0; i--) {\r\n\t\t\tlabelInterval = moment.duration(AGENDA_STOCK_SUB_DURATIONS[i]);\r\n\t\t\tslotsPerLabel = divideDurationByDuration(labelInterval, slotDuration);\r\n\t\t\tif (isInt(slotsPerLabel) && slotsPerLabel > 1) {\r\n\t\t\t\treturn labelInterval;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn moment.duration(slotDuration); // fall back. clone\r\n\t},\r\n\r\n\r\n\t/* Date Rendering\r\n\t------------------------------------------------------------------------------------------------------------------*/\r\n\r\n\r\n\trenderDates: function(dateProfile) {\r\n\t\tthis.dateProfile = dateProfile;\r\n\t\tthis.updateDayTable();\r\n\t\tthis.renderSlats();\r\n\t\tthis.renderColumns();\r\n\t},\r\n\r\n\r\n\trenderSkeleton: function() {\r\n\t\tvar theme = this.view.calendar.theme;\r\n\r\n\t\tthis.el.html(\r\n\t\t\t'<div class=\"fc-bg\"></div>' +\r\n\t\t\t'<div class=\"fc-slats\"></div>' +\r\n\t\t\t'<hr class=\"fc-divider ' + theme.getClass('widgetHeader') + '\" style=\"display:none\" />'\r\n\t\t);\r\n\r\n\t\tthis.bottomRuleEl = this.el.find('hr');\r\n\t},\r\n\r\n\r\n\trenderSlats: function() {\r\n\t\tvar theme = this.view.calendar.theme;\r\n\r\n\t\tthis.slatContainerEl = this.el.find('> .fc-slats')\r\n\t\t\t.html(\r\n\t\t\t\t'<table class=\"' + theme.getClass('tableGrid') + '\">' +\r\n\t\t\t\t\tthis.renderSlatRowHtml() +\r\n\t\t\t\t'</table>'\r\n\t\t\t);\r\n\r\n\t\tthis.slatEls = this.slatContainerEl.find('tr');\r\n\r\n\t\tthis.slatCoordCache = new CoordCache({\r\n\t\t\tels: this.slatEls,\r\n\t\t\tisVertical: true\r\n\t\t});\r\n\t},\r\n\r\n\r\n\t// Generates the HTML for the horizontal \"slats\" that run width-wise. Has a time axis on a side. Depends on RTL.\r\n\trenderSlatRowHtml: function() {\r\n\t\tvar view = this.view;\r\n\t\tvar calendar = view.calendar;\r\n\t\tvar theme = calendar.theme;\r\n\t\tvar isRTL = this.isRTL;\r\n\t\tvar dateProfile = this.dateProfile;\r\n\t\tvar html = '';\r\n\t\tvar slotTime = moment.duration(+dateProfile.minTime); // wish there was .clone() for durations\r\n\t\tvar slotIterator = moment.duration(0);\r\n\t\tvar slotDate; // will be on the view's first day, but we only care about its time\r\n\t\tvar isLabeled;\r\n\t\tvar axisHtml;\r\n\r\n\t\t// Calculate the time for each slot\r\n\t\twhile (slotTime < dateProfile.maxTime) {\r\n\t\t\tslotDate = calendar.msToUtcMoment(dateProfile.renderUnzonedRange.startMs).time(slotTime);\r\n\t\t\tisLabeled = isInt(divideDurationByDuration(slotIterator, this.labelInterval));\r\n\r\n\t\t\taxisHtml =\r\n\t\t\t\t'<td class=\"fc-axis fc-time ' + theme.getClass('widgetContent') + '\" ' + view.axisStyleAttr() + '>' +\r\n\t\t\t\t\t(isLabeled ?\r\n\t\t\t\t\t\t'<span>' + // for matchCellWidths\r\n\t\t\t\t\t\t\thtmlEscape(slotDate.format(this.labelFormat)) +\r\n\t\t\t\t\t\t'</span>' :\r\n\t\t\t\t\t\t''\r\n\t\t\t\t\t\t) +\r\n\t\t\t\t'</td>';\r\n\r\n\t\t\thtml +=\r\n\t\t\t\t'<tr data-time=\"' + slotDate.format('HH:mm:ss') + '\"' +\r\n\t\t\t\t\t(isLabeled ? '' : ' class=\"fc-minor\"') +\r\n\t\t\t\t\t'>' +\r\n\t\t\t\t\t(!isRTL ? axisHtml : '') +\r\n\t\t\t\t\t'<td class=\"' + theme.getClass('widgetContent') + '\"/>' +\r\n\t\t\t\t\t(isRTL ? axisHtml : '') +\r\n\t\t\t\t\"</tr>\";\r\n\r\n\t\t\tslotTime.add(this.slotDuration);\r\n\t\t\tslotIterator.add(this.slotDuration);\r\n\t\t}\r\n\r\n\t\treturn html;\r\n\t},\r\n\r\n\r\n\trenderColumns: function() {\r\n\t\tvar dateProfile = this.dateProfile;\r\n\t\tvar theme = this.view.calendar.theme;\r\n\r\n\t\tthis.dayRanges = this.dayDates.map(function(dayDate) {\r\n\t\t\treturn new UnzonedRange(\r\n\t\t\t\tdayDate.clone().add(dateProfile.minTime),\r\n\t\t\t\tdayDate.clone().add(dateProfile.maxTime)\r\n\t\t\t);\r\n\t\t});\r\n\r\n\t\tif (this.headContainerEl) {\r\n\t\t\tthis.headContainerEl.html(this.renderHeadHtml());\r\n\t\t}\r\n\r\n\t\tthis.el.find('> .fc-bg').html(\r\n\t\t\t'<table class=\"' + theme.getClass('tableGrid') + '\">' +\r\n\t\t\t\tthis.renderBgTrHtml(0) + // row=0\r\n\t\t\t'</table>'\r\n\t\t);\r\n\r\n\t\tthis.colEls = this.el.find('.fc-day, .fc-disabled-day');\r\n\r\n\t\tthis.colCoordCache = new CoordCache({\r\n\t\t\tels: this.colEls,\r\n\t\t\tisHorizontal: true\r\n\t\t});\r\n\r\n\t\tthis.renderContentSkeleton();\r\n\t},\r\n\r\n\r\n\t/* Content Skeleton\r\n\t------------------------------------------------------------------------------------------------------------------*/\r\n\r\n\r\n\t// Renders the DOM that the view's content will live in\r\n\trenderContentSkeleton: function() {\r\n\t\tvar cellHtml = '';\r\n\t\tvar i;\r\n\t\tvar skeletonEl;\r\n\r\n\t\tfor (i = 0; i < this.colCnt; i++) {\r\n\t\t\tcellHtml +=\r\n\t\t\t\t'<td>' +\r\n\t\t\t\t\t'<div class=\"fc-content-col\">' +\r\n\t\t\t\t\t\t'<div class=\"fc-event-container fc-helper-container\"></div>' +\r\n\t\t\t\t\t\t'<div class=\"fc-event-container\"></div>' +\r\n\t\t\t\t\t\t'<div class=\"fc-highlight-container\"></div>' +\r\n\t\t\t\t\t\t'<div class=\"fc-bgevent-container\"></div>' +\r\n\t\t\t\t\t\t'<div class=\"fc-business-container\"></div>' +\r\n\t\t\t\t\t'</div>' +\r\n\t\t\t\t'</td>';\r\n\t\t}\r\n\r\n\t\tskeletonEl = $(\r\n\t\t\t'<div class=\"fc-content-skeleton\">' +\r\n\t\t\t\t'<table>' +\r\n\t\t\t\t\t'<tr>' + cellHtml + '</tr>' +\r\n\t\t\t\t'</table>' +\r\n\t\t\t'</div>'\r\n\t\t);\r\n\r\n\t\tthis.colContainerEls = skeletonEl.find('.fc-content-col');\r\n\t\tthis.helperContainerEls = skeletonEl.find('.fc-helper-container');\r\n\t\tthis.fgContainerEls = skeletonEl.find('.fc-event-container:not(.fc-helper-container)');\r\n\t\tthis.bgContainerEls = skeletonEl.find('.fc-bgevent-container');\r\n\t\tthis.highlightContainerEls = skeletonEl.find('.fc-highlight-container');\r\n\t\tthis.businessContainerEls = skeletonEl.find('.fc-business-container');\r\n\r\n\t\tthis.bookendCells(skeletonEl.find('tr')); // TODO: do this on string level\r\n\t\tthis.el.append(skeletonEl);\r\n\t},\r\n\r\n\r\n\t// Given a flat array of segments, return an array of sub-arrays, grouped by each segment's col\r\n\tgroupSegsByCol: function(segs) {\r\n\t\tvar segsByCol = [];\r\n\t\tvar i;\r\n\r\n\t\tfor (i = 0; i < this.colCnt; i++) {\r\n\t\t\tsegsByCol.push([]);\r\n\t\t}\r\n\r\n\t\tfor (i = 0; i < segs.length; i++) {\r\n\t\t\tsegsByCol[segs[i].col].push(segs[i]);\r\n\t\t}\r\n\r\n\t\treturn segsByCol;\r\n\t},\r\n\r\n\r\n\t// Given segments grouped by column, insert the segments' elements into a parallel array of container\r\n\t// elements, each living within a column.\r\n\tattachSegsByCol: function(segsByCol, containerEls) {\r\n\t\tvar col;\r\n\t\tvar segs;\r\n\t\tvar i;\r\n\r\n\t\tfor (col = 0; col < this.colCnt; col++) { // iterate each column grouping\r\n\t\t\tsegs = segsByCol[col];\r\n\r\n\t\t\tfor (i = 0; i < segs.length; i++) {\r\n\t\t\t\tcontainerEls.eq(col).append(segs[i].el);\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\r\n\t/* Now Indicator\r\n\t------------------------------------------------------------------------------------------------------------------*/\r\n\r\n\r\n\tgetNowIndicatorUnit: function() {\r\n\t\treturn 'minute'; // will refresh on the minute\r\n\t},\r\n\r\n\r\n\trenderNowIndicator: function(date) {\r\n\t\t// seg system might be overkill, but it handles scenario where line needs to be rendered\r\n\t\t//  more than once because of columns with the same date (resources columns for example)\r\n\t\tvar segs = this.componentFootprintToSegs(\r\n\t\t\tnew ComponentFootprint(\r\n\t\t\t\tnew UnzonedRange(date, date.valueOf() + 1), // protect against null range\r\n\t\t\t\tfalse // all-day\r\n\t\t\t)\r\n\t\t);\r\n\t\tvar top = this.computeDateTop(date, date);\r\n\t\tvar nodes = [];\r\n\t\tvar i;\r\n\r\n\t\t// render lines within the columns\r\n\t\tfor (i = 0; i < segs.length; i++) {\r\n\t\t\tnodes.push($('<div class=\"fc-now-indicator fc-now-indicator-line\"></div>')\r\n\t\t\t\t.css('top', top)\r\n\t\t\t\t.appendTo(this.colContainerEls.eq(segs[i].col))[0]);\r\n\t\t}\r\n\r\n\t\t// render an arrow over the axis\r\n\t\tif (segs.length > 0) { // is the current time in view?\r\n\t\t\tnodes.push($('<div class=\"fc-now-indicator fc-now-indicator-arrow\"></div>')\r\n\t\t\t\t.css('top', top)\r\n\t\t\t\t.appendTo(this.el.find('.fc-content-skeleton'))[0]);\r\n\t\t}\r\n\r\n\t\tthis.nowIndicatorEls = $(nodes);\r\n\t},\r\n\r\n\r\n\tunrenderNowIndicator: function() {\r\n\t\tif (this.nowIndicatorEls) {\r\n\t\t\tthis.nowIndicatorEls.remove();\r\n\t\t\tthis.nowIndicatorEls = null;\r\n\t\t}\r\n\t},\r\n\r\n\r\n\t/* Coordinates\r\n\t------------------------------------------------------------------------------------------------------------------*/\r\n\r\n\r\n\tupdateSize: function(totalHeight, isAuto, isResize) {\r\n\t\tInteractiveDateComponent.prototype.updateSize.apply(this, arguments);\r\n\r\n\t\tthis.slatCoordCache.build();\r\n\r\n\t\tif (isResize) {\r\n\t\t\tthis.updateSegVerticals(\r\n\t\t\t\t[].concat(this.eventRenderer.getSegs(), this.businessSegs || [])\r\n\t\t\t);\r\n\t\t}\r\n\t},\r\n\r\n\r\n\tgetTotalSlatHeight: function() {\r\n\t\treturn this.slatContainerEl.outerHeight();\r\n\t},\r\n\r\n\r\n\t// Computes the top coordinate, relative to the bounds of the grid, of the given date.\r\n\t// `ms` can be a millisecond UTC time OR a UTC moment.\r\n\t// A `startOfDayDate` must be given for avoiding ambiguity over how to treat midnight.\r\n\tcomputeDateTop: function(ms, startOfDayDate) {\r\n\t\treturn this.computeTimeTop(\r\n\t\t\tmoment.duration(\r\n\t\t\t\tms - startOfDayDate.clone().stripTime()\r\n\t\t\t)\r\n\t\t);\r\n\t},\r\n\r\n\r\n\t// Computes the top coordinate, relative to the bounds of the grid, of the given time (a Duration).\r\n\tcomputeTimeTop: function(time) {\r\n\t\tvar len = this.slatEls.length;\r\n\t\tvar dateProfile = this.dateProfile;\r\n\t\tvar slatCoverage = (time - dateProfile.minTime) / this.slotDuration; // floating-point value of # of slots covered\r\n\t\tvar slatIndex;\r\n\t\tvar slatRemainder;\r\n\r\n\t\t// compute a floating-point number for how many slats should be progressed through.\r\n\t\t// from 0 to number of slats (inclusive)\r\n\t\t// constrained because minTime/maxTime might be customized.\r\n\t\tslatCoverage = Math.max(0, slatCoverage);\r\n\t\tslatCoverage = Math.min(len, slatCoverage);\r\n\r\n\t\t// an integer index of the furthest whole slat\r\n\t\t// from 0 to number slats (*exclusive*, so len-1)\r\n\t\tslatIndex = Math.floor(slatCoverage);\r\n\t\tslatIndex = Math.min(slatIndex, len - 1);\r\n\r\n\t\t// how much further through the slatIndex slat (from 0.0-1.0) must be covered in addition.\r\n\t\t// could be 1.0 if slatCoverage is covering *all* the slots\r\n\t\tslatRemainder = slatCoverage - slatIndex;\r\n\r\n\t\treturn this.slatCoordCache.getTopPosition(slatIndex) +\r\n\t\t\tthis.slatCoordCache.getHeight(slatIndex) * slatRemainder;\r\n\t},\r\n\r\n\r\n\t// Refreshes the CSS top/bottom coordinates for each segment element.\r\n\t// Works when called after initial render, after a window resize/zoom for example.\r\n\tupdateSegVerticals: function(segs) {\r\n\t\tthis.computeSegVerticals(segs);\r\n\t\tthis.assignSegVerticals(segs);\r\n\t},\r\n\r\n\r\n\t// For each segment in an array, computes and assigns its top and bottom properties\r\n\tcomputeSegVerticals: function(segs) {\r\n\t\tvar eventMinHeight = this.opt('agendaEventMinHeight');\r\n\t\tvar i, seg;\r\n\t\tvar dayDate;\r\n\r\n\t\tfor (i = 0; i < segs.length; i++) {\r\n\t\t\tseg = segs[i];\r\n\t\t\tdayDate = this.dayDates[seg.dayIndex];\r\n\r\n\t\t\tseg.top = this.computeDateTop(seg.startMs, dayDate);\r\n\t\t\tseg.bottom = Math.max(\r\n\t\t\t\tseg.top + eventMinHeight,\r\n\t\t\t\tthis.computeDateTop(seg.endMs, dayDate)\r\n\t\t\t);\r\n\t\t}\r\n\t},\r\n\r\n\r\n\t// Given segments that already have their top/bottom properties computed, applies those values to\r\n\t// the segments' elements.\r\n\tassignSegVerticals: function(segs) {\r\n\t\tvar i, seg;\r\n\r\n\t\tfor (i = 0; i < segs.length; i++) {\r\n\t\t\tseg = segs[i];\r\n\t\t\tseg.el.css(this.generateSegVerticalCss(seg));\r\n\t\t}\r\n\t},\r\n\r\n\r\n\t// Generates an object with CSS properties for the top/bottom coordinates of a segment element\r\n\tgenerateSegVerticalCss: function(seg) {\r\n\t\treturn {\r\n\t\t\ttop: seg.top,\r\n\t\t\tbottom: -seg.bottom // flipped because needs to be space beyond bottom edge of event container\r\n\t\t};\r\n\t},\r\n\r\n\r\n\t/* Hit System\r\n\t------------------------------------------------------------------------------------------------------------------*/\r\n\r\n\r\n\tprepareHits: function() {\r\n\t\tthis.colCoordCache.build();\r\n\t\tthis.slatCoordCache.build();\r\n\t},\r\n\r\n\r\n\treleaseHits: function() {\r\n\t\tthis.colCoordCache.clear();\r\n\t\t// NOTE: don't clear slatCoordCache because we rely on it for computeTimeTop\r\n\t},\r\n\r\n\r\n\tqueryHit: function(leftOffset, topOffset) {\r\n\t\tvar snapsPerSlot = this.snapsPerSlot;\r\n\t\tvar colCoordCache = this.colCoordCache;\r\n\t\tvar slatCoordCache = this.slatCoordCache;\r\n\r\n\t\tif (colCoordCache.isLeftInBounds(leftOffset) && slatCoordCache.isTopInBounds(topOffset)) {\r\n\t\t\tvar colIndex = colCoordCache.getHorizontalIndex(leftOffset);\r\n\t\t\tvar slatIndex = slatCoordCache.getVerticalIndex(topOffset);\r\n\r\n\t\t\tif (colIndex != null && slatIndex != null) {\r\n\t\t\t\tvar slatTop = slatCoordCache.getTopOffset(slatIndex);\r\n\t\t\t\tvar slatHeight = slatCoordCache.getHeight(slatIndex);\r\n\t\t\t\tvar partial = (topOffset - slatTop) / slatHeight; // floating point number between 0 and 1\r\n\t\t\t\tvar localSnapIndex = Math.floor(partial * snapsPerSlot); // the snap # relative to start of slat\r\n\t\t\t\tvar snapIndex = slatIndex * snapsPerSlot + localSnapIndex;\r\n\t\t\t\tvar snapTop = slatTop + (localSnapIndex / snapsPerSlot) * slatHeight;\r\n\t\t\t\tvar snapBottom = slatTop + ((localSnapIndex + 1) / snapsPerSlot) * slatHeight;\r\n\r\n\t\t\t\treturn {\r\n\t\t\t\t\tcol: colIndex,\r\n\t\t\t\t\tsnap: snapIndex,\r\n\t\t\t\t\tcomponent: this, // needed unfortunately :(\r\n\t\t\t\t\tleft: colCoordCache.getLeftOffset(colIndex),\r\n\t\t\t\t\tright: colCoordCache.getRightOffset(colIndex),\r\n\t\t\t\t\ttop: snapTop,\r\n\t\t\t\t\tbottom: snapBottom\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\r\n\tgetHitFootprint: function(hit) {\r\n\t\tvar start = this.getCellDate(0, hit.col); // row=0\r\n\t\tvar time = this.computeSnapTime(hit.snap); // pass in the snap-index\r\n\t\tvar end;\r\n\r\n\t\tstart.time(time);\r\n\t\tend = start.clone().add(this.snapDuration);\r\n\r\n\t\treturn new ComponentFootprint(\r\n\t\t\tnew UnzonedRange(start, end),\r\n\t\t\tfalse // all-day?\r\n\t\t);\r\n\t},\r\n\r\n\r\n\t// Given a row number of the grid, representing a \"snap\", returns a time (Duration) from its start-of-day\r\n\tcomputeSnapTime: function(snapIndex) {\r\n\t\treturn moment.duration(this.dateProfile.minTime + this.snapDuration * snapIndex);\r\n\t},\r\n\r\n\r\n\tgetHitEl: function(hit) {\r\n\t\treturn this.colEls.eq(hit.col);\r\n\t},\r\n\r\n\r\n\t/* Event Drag Visualization\r\n\t------------------------------------------------------------------------------------------------------------------*/\r\n\r\n\r\n\t// Renders a visual indication of an event being dragged over the specified date(s).\r\n\t// A returned value of `true` signals that a mock \"helper\" event has been rendered.\r\n\trenderDrag: function(eventFootprints, seg, isTouch) {\r\n\t\tvar i;\r\n\r\n\t\tif (seg) { // if there is event information for this drag, render a helper event\r\n\r\n\t\t\tif (eventFootprints.length) {\r\n\t\t\t\tthis.helperRenderer.renderEventDraggingFootprints(eventFootprints, seg, isTouch);\r\n\r\n\t\t\t\t// signal that a helper has been rendered\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse { // otherwise, just render a highlight\r\n\r\n\t\t\tfor (i = 0; i < eventFootprints.length; i++) {\r\n\t\t\t\tthis.renderHighlight(eventFootprints[i].componentFootprint);\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\r\n\t// Unrenders any visual indication of an event being dragged\r\n\tunrenderDrag: function(seg) {\r\n\t\tthis.unrenderHighlight();\r\n\t\tthis.helperRenderer.unrender();\r\n\t},\r\n\r\n\r\n\t/* Event Resize Visualization\r\n\t------------------------------------------------------------------------------------------------------------------*/\r\n\r\n\r\n\t// Renders a visual indication of an event being resized\r\n\trenderEventResize: function(eventFootprints, seg, isTouch) {\r\n\t\tthis.helperRenderer.renderEventResizingFootprints(eventFootprints, seg, isTouch);\r\n\t},\r\n\r\n\r\n\t// Unrenders any visual indication of an event being resized\r\n\tunrenderEventResize: function(seg) {\r\n\t\tthis.helperRenderer.unrender();\r\n\t},\r\n\r\n\r\n\t/* Selection\r\n\t------------------------------------------------------------------------------------------------------------------*/\r\n\r\n\r\n\t// Renders a visual indication of a selection. Overrides the default, which was to simply render a highlight.\r\n\trenderSelectionFootprint: function(componentFootprint) {\r\n\t\tif (this.opt('selectHelper')) { // this setting signals that a mock helper event should be rendered\r\n\t\t\tthis.helperRenderer.renderComponentFootprint(componentFootprint);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tthis.renderHighlight(componentFootprint);\r\n\t\t}\r\n\t},\r\n\r\n\r\n\t// Unrenders any visual indication of a selection\r\n\tunrenderSelection: function() {\r\n\t\tthis.helperRenderer.unrender();\r\n\t\tthis.unrenderHighlight();\r\n\t}\r\n\r\n});\r\n\r\n;;\r\n\r\n/* An abstract class for all agenda-related views. Displays one more columns with time slots running vertically.\r\n----------------------------------------------------------------------------------------------------------------------*/\r\n// Is a manager for the TimeGrid subcomponent and possibly the DayGrid subcomponent (if allDaySlot is on).\r\n// Responsible for managing width/height.\r\n\r\nvar AgendaView = FC.AgendaView = View.extend({\r\n\r\n\tscroller: null,\r\n\r\n\ttimeGridClass: TimeGrid, // class used to instantiate the timeGrid. subclasses can override\r\n\ttimeGrid: null, // the main time-grid subcomponent of this view\r\n\r\n\tdayGridClass: DayGrid, // class used to instantiate the dayGrid. subclasses can override\r\n\tdayGrid: null, // the \"all-day\" subcomponent. if all-day is turned off, this will be null\r\n\r\n\taxisWidth: null, // the width of the time axis running down the side\r\n\r\n\t// indicates that minTime/maxTime affects rendering\r\n\tusesMinMaxTime: true,\r\n\r\n\r\n\tconstructor: function() {\r\n\t\tView.apply(this, arguments);\r\n\r\n\t\tthis.timeGrid = this.instantiateTimeGrid();\r\n\t\tthis.addChild(this.timeGrid);\r\n\r\n\t\tif (this.opt('allDaySlot')) { // should we display the \"all-day\" area?\r\n\t\t\tthis.dayGrid = this.instantiateDayGrid(); // the all-day subcomponent of this view\r\n\t\t\tthis.addChild(this.dayGrid);\r\n\t\t}\r\n\r\n\t\tthis.scroller = new Scroller({\r\n\t\t\toverflowX: 'hidden',\r\n\t\t\toverflowY: 'auto'\r\n\t\t});\r\n\t},\r\n\r\n\r\n\t// Instantiates the TimeGrid object this view needs. Draws from this.timeGridClass\r\n\tinstantiateTimeGrid: function() {\r\n\t\tvar subclass = this.timeGridClass.extend(agendaTimeGridMethods);\r\n\r\n\t\treturn new subclass(this);\r\n\t},\r\n\r\n\r\n\t// Instantiates the DayGrid object this view might need. Draws from this.dayGridClass\r\n\tinstantiateDayGrid: function() {\r\n\t\tvar subclass = this.dayGridClass.extend(agendaDayGridMethods);\r\n\r\n\t\treturn new subclass(this);\r\n\t},\r\n\r\n\r\n\t/* Rendering\r\n\t------------------------------------------------------------------------------------------------------------------*/\r\n\r\n\r\n\trenderSkeleton: function() {\r\n\t\tvar timeGridWrapEl;\r\n\t\tvar timeGridEl;\r\n\r\n\t\tthis.el.addClass('fc-agenda-view').html(this.renderSkeletonHtml());\r\n\r\n\t\tthis.scroller.render();\r\n\r\n\t\ttimeGridWrapEl = this.scroller.el.addClass('fc-time-grid-container');\r\n\t\ttimeGridEl = $('<div class=\"fc-time-grid\" />').appendTo(timeGridWrapEl);\r\n\r\n\t\tthis.el.find('.fc-body > tr > td').append(timeGridWrapEl);\r\n\r\n\t\tthis.timeGrid.headContainerEl = this.el.find('.fc-head-container');\r\n\t\tthis.timeGrid.setElement(timeGridEl);\r\n\r\n\t\tif (this.dayGrid) {\r\n\t\t\tthis.dayGrid.setElement(this.el.find('.fc-day-grid'));\r\n\r\n\t\t\t// have the day-grid extend it's coordinate area over the <hr> dividing the two grids\r\n\t\t\tthis.dayGrid.bottomCoordPadding = this.dayGrid.el.next('hr').outerHeight();\r\n\t\t}\r\n\t},\r\n\r\n\r\n\tunrenderSkeleton: function() {\r\n\t\tthis.timeGrid.removeElement();\r\n\r\n\t\tif (this.dayGrid) {\r\n\t\t\tthis.dayGrid.removeElement();\r\n\t\t}\r\n\r\n\t\tthis.scroller.destroy();\r\n\t},\r\n\r\n\r\n\t// Builds the HTML skeleton for the view.\r\n\t// The day-grid and time-grid components will render inside containers defined by this HTML.\r\n\trenderSkeletonHtml: function() {\r\n\t\tvar theme = this.calendar.theme;\r\n\r\n\t\treturn '' +\r\n\t\t\t'<table class=\"' + theme.getClass('tableGrid') + '\">' +\r\n\t\t\t\t(this.opt('columnHeader') ?\r\n\t\t\t\t\t'<thead class=\"fc-head\">' +\r\n\t\t\t\t\t\t'<tr>' +\r\n\t\t\t\t\t\t\t'<td class=\"fc-head-container ' + theme.getClass('widgetHeader') + '\">&nbsp;</td>' +\r\n\t\t\t\t\t\t'</tr>' +\r\n\t\t\t\t\t'</thead>' :\r\n\t\t\t\t\t''\r\n\t\t\t\t\t) +\r\n\t\t\t\t'<tbody class=\"fc-body\">' +\r\n\t\t\t\t\t'<tr>' +\r\n\t\t\t\t\t\t'<td class=\"' + theme.getClass('widgetContent') + '\">' +\r\n\t\t\t\t\t\t\t(this.dayGrid ?\r\n\t\t\t\t\t\t\t\t'<div class=\"fc-day-grid\"/>' +\r\n\t\t\t\t\t\t\t\t'<hr class=\"fc-divider ' + theme.getClass('widgetHeader') + '\"/>' :\r\n\t\t\t\t\t\t\t\t''\r\n\t\t\t\t\t\t\t\t) +\r\n\t\t\t\t\t\t'</td>' +\r\n\t\t\t\t\t'</tr>' +\r\n\t\t\t\t'</tbody>' +\r\n\t\t\t'</table>';\r\n\t},\r\n\r\n\r\n\t// Generates an HTML attribute string for setting the width of the axis, if it is known\r\n\taxisStyleAttr: function() {\r\n\t\tif (this.axisWidth !== null) {\r\n\t\t\t return 'style=\"width:' + this.axisWidth + 'px\"';\r\n\t\t}\r\n\t\treturn '';\r\n\t},\r\n\r\n\r\n\t/* Now Indicator\r\n\t------------------------------------------------------------------------------------------------------------------*/\r\n\r\n\r\n\tgetNowIndicatorUnit: function() {\r\n\t\treturn this.timeGrid.getNowIndicatorUnit();\r\n\t},\r\n\r\n\r\n\t/* Dimensions\r\n\t------------------------------------------------------------------------------------------------------------------*/\r\n\r\n\r\n\t// Adjusts the vertical dimensions of the view to the specified values\r\n\tupdateSize: function(totalHeight, isAuto, isResize) {\r\n\t\tvar eventLimit;\r\n\t\tvar scrollerHeight;\r\n\t\tvar scrollbarWidths;\r\n\r\n\t\tView.prototype.updateSize.apply(this, arguments);\r\n\r\n\t\t// make all axis cells line up, and record the width so newly created axis cells will have it\r\n\t\tthis.axisWidth = matchCellWidths(this.el.find('.fc-axis'));\r\n\r\n\t\t// hack to give the view some height prior to timeGrid's columns being rendered\r\n\t\t// TODO: separate setting height from scroller VS timeGrid.\r\n\t\tif (!this.timeGrid.colEls) {\r\n\t\t\tif (!isAuto) {\r\n\t\t\t\tscrollerHeight = this.computeScrollerHeight(totalHeight);\r\n\t\t\t\tthis.scroller.setHeight(scrollerHeight);\r\n\t\t\t}\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// set of fake row elements that must compensate when scroller has scrollbars\r\n\t\tvar noScrollRowEls = this.el.find('.fc-row:not(.fc-scroller *)');\r\n\r\n\t\t// reset all dimensions back to the original state\r\n\t\tthis.timeGrid.bottomRuleEl.hide(); // .show() will be called later if this <hr> is necessary\r\n\t\tthis.scroller.clear(); // sets height to 'auto' and clears overflow\r\n\t\tuncompensateScroll(noScrollRowEls);\r\n\r\n\t\t// limit number of events in the all-day area\r\n\t\tif (this.dayGrid) {\r\n\t\t\tthis.dayGrid.removeSegPopover(); // kill the \"more\" popover if displayed\r\n\r\n\t\t\teventLimit = this.opt('eventLimit');\r\n\t\t\tif (eventLimit && typeof eventLimit !== 'number') {\r\n\t\t\t\teventLimit = AGENDA_ALL_DAY_EVENT_LIMIT; // make sure \"auto\" goes to a real number\r\n\t\t\t}\r\n\t\t\tif (eventLimit) {\r\n\t\t\t\tthis.dayGrid.limitRows(eventLimit);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (!isAuto) { // should we force dimensions of the scroll container?\r\n\r\n\t\t\tscrollerHeight = this.computeScrollerHeight(totalHeight);\r\n\t\t\tthis.scroller.setHeight(scrollerHeight);\r\n\t\t\tscrollbarWidths = this.scroller.getScrollbarWidths();\r\n\r\n\t\t\tif (scrollbarWidths.left || scrollbarWidths.right) { // using scrollbars?\r\n\r\n\t\t\t\t// make the all-day and header rows lines up\r\n\t\t\t\tcompensateScroll(noScrollRowEls, scrollbarWidths);\r\n\r\n\t\t\t\t// the scrollbar compensation might have changed text flow, which might affect height, so recalculate\r\n\t\t\t\t// and reapply the desired height to the scroller.\r\n\t\t\t\tscrollerHeight = this.computeScrollerHeight(totalHeight);\r\n\t\t\t\tthis.scroller.setHeight(scrollerHeight);\r\n\t\t\t}\r\n\r\n\t\t\t// guarantees the same scrollbar widths\r\n\t\t\tthis.scroller.lockOverflow(scrollbarWidths);\r\n\r\n\t\t\t// if there's any space below the slats, show the horizontal rule.\r\n\t\t\t// this won't cause any new overflow, because lockOverflow already called.\r\n\t\t\tif (this.timeGrid.getTotalSlatHeight() < scrollerHeight) {\r\n\t\t\t\tthis.timeGrid.bottomRuleEl.show();\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\r\n\t// given a desired total height of the view, returns what the height of the scroller should be\r\n\tcomputeScrollerHeight: function(totalHeight) {\r\n\t\treturn totalHeight -\r\n\t\t\tsubtractInnerElHeight(this.el, this.scroller.el); // everything that's NOT the scroller\r\n\t},\r\n\r\n\r\n\t/* Scroll\r\n\t------------------------------------------------------------------------------------------------------------------*/\r\n\r\n\r\n\t// Computes the initial pre-configured scroll state prior to allowing the user to change it\r\n\tcomputeInitialDateScroll: function() {\r\n\t\tvar scrollTime = moment.duration(this.opt('scrollTime'));\r\n\t\tvar top = this.timeGrid.computeTimeTop(scrollTime);\r\n\r\n\t\t// zoom can give weird floating-point values. rather scroll a little bit further\r\n\t\ttop = Math.ceil(top);\r\n\r\n\t\tif (top) {\r\n\t\t\ttop++; // to overcome top border that slots beyond the first have. looks better\r\n\t\t}\r\n\r\n\t\treturn { top: top };\r\n\t},\r\n\r\n\r\n\tqueryDateScroll: function() {\r\n\t\treturn { top: this.scroller.getScrollTop() };\r\n\t},\r\n\r\n\r\n\tapplyDateScroll: function(scroll) {\r\n\t\tif (scroll.top !== undefined) {\r\n\t\t\tthis.scroller.setScrollTop(scroll.top);\r\n\t\t}\r\n\t},\r\n\r\n\r\n\t/* Hit Areas\r\n\t------------------------------------------------------------------------------------------------------------------*/\r\n\t// forward all hit-related method calls to the grids (dayGrid might not be defined)\r\n\r\n\r\n\tgetHitFootprint: function(hit) {\r\n\t\t// TODO: hit.component is set as a hack to identify where the hit came from\r\n\t\treturn hit.component.getHitFootprint(hit);\r\n\t},\r\n\r\n\r\n\tgetHitEl: function(hit) {\r\n\t\t// TODO: hit.component is set as a hack to identify where the hit came from\r\n\t\treturn hit.component.getHitEl(hit);\r\n\t},\r\n\r\n\r\n\t/* Event Rendering\r\n\t------------------------------------------------------------------------------------------------------------------*/\r\n\r\n\r\n\texecuteEventRender: function(eventsPayload) {\r\n\t\tvar dayEventsPayload = {};\r\n\t\tvar timedEventsPayload = {};\r\n\t\tvar id, eventInstanceGroup;\r\n\r\n\t\t// separate the events into all-day and timed\r\n\t\tfor (id in eventsPayload) {\r\n\t\t\teventInstanceGroup = eventsPayload[id];\r\n\r\n\t\t\tif (eventInstanceGroup.getEventDef().isAllDay()) {\r\n\t\t\t\tdayEventsPayload[id] = eventInstanceGroup;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\ttimedEventsPayload[id] = eventInstanceGroup;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis.timeGrid.executeEventRender(timedEventsPayload);\r\n\r\n\t\tif (this.dayGrid) {\r\n\t\t\tthis.dayGrid.executeEventRender(dayEventsPayload);\r\n\t\t}\r\n\t},\r\n\r\n\r\n\t/* Dragging/Resizing Routing\r\n\t------------------------------------------------------------------------------------------------------------------*/\r\n\r\n\r\n\t// A returned value of `true` signals that a mock \"helper\" event has been rendered.\r\n\trenderDrag: function(eventFootprints, seg, isTouch) {\r\n\t\tvar groups = groupEventFootprintsByAllDay(eventFootprints);\r\n\t\tvar renderedHelper = false;\r\n\r\n\t\trenderedHelper = this.timeGrid.renderDrag(groups.timed, seg, isTouch);\r\n\r\n\t\tif (this.dayGrid) {\r\n\t\t\trenderedHelper = this.dayGrid.renderDrag(groups.allDay, seg, isTouch) || renderedHelper;\r\n\t\t}\r\n\r\n\t\treturn renderedHelper;\r\n\t},\r\n\r\n\r\n\trenderEventResize: function(eventFootprints, seg, isTouch) {\r\n\t\tvar groups = groupEventFootprintsByAllDay(eventFootprints);\r\n\r\n\t\tthis.timeGrid.renderEventResize(groups.timed, seg, isTouch);\r\n\r\n\t\tif (this.dayGrid) {\r\n\t\t\tthis.dayGrid.renderEventResize(groups.allDay, seg, isTouch);\r\n\t\t}\r\n\t},\r\n\r\n\r\n\t/* Selection\r\n\t------------------------------------------------------------------------------------------------------------------*/\r\n\r\n\r\n\t// Renders a visual indication of a selection\r\n\trenderSelectionFootprint: function(componentFootprint) {\r\n\t\tif (!componentFootprint.isAllDay) {\r\n\t\t\tthis.timeGrid.renderSelectionFootprint(componentFootprint);\r\n\t\t}\r\n\t\telse if (this.dayGrid) {\r\n\t\t\tthis.dayGrid.renderSelectionFootprint(componentFootprint);\r\n\t\t}\r\n\t}\r\n\r\n});\r\n\r\n\r\n// Methods that will customize the rendering behavior of the AgendaView's timeGrid\r\n// TODO: move into TimeGrid\r\nvar agendaTimeGridMethods = {\r\n\r\n\r\n\t// Generates the HTML that will go before the day-of week header cells\r\n\trenderHeadIntroHtml: function() {\r\n\t\tvar view = this.view;\r\n\t\tvar calendar = view.calendar;\r\n\t\tvar weekStart = calendar.msToUtcMoment(this.dateProfile.renderUnzonedRange.startMs, true);\r\n\t\tvar weekText;\r\n\r\n\t\tif (this.opt('weekNumbers')) {\r\n\t\t\tweekText = weekStart.format(this.opt('smallWeekFormat'));\r\n\r\n\t\t\treturn '' +\r\n\t\t\t\t'<th class=\"fc-axis fc-week-number ' + calendar.theme.getClass('widgetHeader') + '\" ' + view.axisStyleAttr() + '>' +\r\n\t\t\t\t\tview.buildGotoAnchorHtml( // aside from link, important for matchCellWidths\r\n\t\t\t\t\t\t{ date: weekStart, type: 'week', forceOff: this.colCnt > 1 },\r\n\t\t\t\t\t\thtmlEscape(weekText) // inner HTML\r\n\t\t\t\t\t) +\r\n\t\t\t\t'</th>';\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn '<th class=\"fc-axis ' + calendar.theme.getClass('widgetHeader') + '\" ' + view.axisStyleAttr() + '></th>';\r\n\t\t}\r\n\t},\r\n\r\n\r\n\t// Generates the HTML that goes before the bg of the TimeGrid slot area. Long vertical column.\r\n\trenderBgIntroHtml: function() {\r\n\t\tvar view = this.view;\r\n\r\n\t\treturn '<td class=\"fc-axis ' + view.calendar.theme.getClass('widgetContent') + '\" ' + view.axisStyleAttr() + '></td>';\r\n\t},\r\n\r\n\r\n\t// Generates the HTML that goes before all other types of cells.\r\n\t// Affects content-skeleton, helper-skeleton, highlight-skeleton for both the time-grid and day-grid.\r\n\trenderIntroHtml: function() {\r\n\t\tvar view = this.view;\r\n\r\n\t\treturn '<td class=\"fc-axis\" ' + view.axisStyleAttr() + '></td>';\r\n\t}\r\n\r\n};\r\n\r\n\r\n// Methods that will customize the rendering behavior of the AgendaView's dayGrid\r\nvar agendaDayGridMethods = {\r\n\r\n\r\n\t// Generates the HTML that goes before the all-day cells\r\n\trenderBgIntroHtml: function() {\r\n\t\tvar view = this.view;\r\n\r\n\t\treturn '' +\r\n\t\t\t'<td class=\"fc-axis ' + view.calendar.theme.getClass('widgetContent') + '\" ' + view.axisStyleAttr() + '>' +\r\n\t\t\t\t'<span>' + // needed for matchCellWidths\r\n\t\t\t\t\tview.getAllDayHtml() +\r\n\t\t\t\t'</span>' +\r\n\t\t\t'</td>';\r\n\t},\r\n\r\n\r\n\t// Generates the HTML that goes before all other types of cells.\r\n\t// Affects content-skeleton, helper-skeleton, highlight-skeleton for both the time-grid and day-grid.\r\n\trenderIntroHtml: function() {\r\n\t\tvar view = this.view;\r\n\r\n\t\treturn '<td class=\"fc-axis\" ' + view.axisStyleAttr() + '></td>';\r\n\t}\r\n\r\n};\r\n\r\n\r\nfunction groupEventFootprintsByAllDay(eventFootprints) {\r\n\tvar allDay = [];\r\n\tvar timed = [];\r\n\tvar i;\r\n\r\n\tfor (i = 0; i < eventFootprints.length; i++) {\r\n\t\tif (eventFootprints[i].componentFootprint.isAllDay) {\r\n\t\t\tallDay.push(eventFootprints[i]);\r\n\t\t}\r\n\t\telse {\r\n\t\t\ttimed.push(eventFootprints[i]);\r\n\t\t}\r\n\t}\r\n\r\n\treturn { allDay: allDay, timed: timed };\r\n}\r\n\r\n;;\r\n\r\nvar AGENDA_ALL_DAY_EVENT_LIMIT = 5;\r\n\r\n// potential nice values for the slot-duration and interval-duration\r\n// from largest to smallest\r\nvar AGENDA_STOCK_SUB_DURATIONS = [\r\n\t{ hours: 1 },\r\n\t{ minutes: 30 },\r\n\t{ minutes: 15 },\r\n\t{ seconds: 30 },\r\n\t{ seconds: 15 }\r\n];\r\n\r\nfcViews.agenda = {\r\n\t'class': AgendaView,\r\n\tdefaults: {\r\n\t\tallDaySlot: true,\r\n\t\tslotDuration: '00:30:00',\r\n\t\tslotEventOverlap: true // a bad name. confused with overlap/constraint system\r\n\t}\r\n};\r\n\r\nfcViews.agendaDay = {\r\n\ttype: 'agenda',\r\n\tduration: { days: 1 }\r\n};\r\n\r\nfcViews.agendaWeek = {\r\n\ttype: 'agenda',\r\n\tduration: { weeks: 1 }\r\n};\r\n;;\r\n\r\n/*\r\nResponsible for the scroller, and forwarding event-related actions into the \"grid\".\r\n*/\r\nvar ListView = FC.ListView = View.extend({\r\n\r\n\tsegSelector: '.fc-list-item', // which elements accept event actions\r\n\t//eventRendererClass is below\r\n\t//eventPointingClass is below\r\n\r\n\tscroller: null,\r\n\tcontentEl: null,\r\n\r\n\tdayDates: null, // localized ambig-time moment array\r\n\tdayRanges: null, // UnzonedRange[], of start-end of each day\r\n\r\n\r\n\tconstructor: function() {\r\n\t\tView.apply(this, arguments);\r\n\r\n\t\tthis.scroller = new Scroller({\r\n\t\t\toverflowX: 'hidden',\r\n\t\t\toverflowY: 'auto'\r\n\t\t});\r\n\t},\r\n\r\n\r\n\trenderSkeleton: function() {\r\n\t\tthis.el.addClass(\r\n\t\t\t'fc-list-view ' +\r\n\t\t\tthis.calendar.theme.getClass('listView')\r\n\t\t);\r\n\r\n\t\tthis.scroller.render();\r\n\t\tthis.scroller.el.appendTo(this.el);\r\n\r\n\t\tthis.contentEl = this.scroller.scrollEl; // shortcut\r\n\t},\r\n\r\n\r\n\tunrenderSkeleton: function() {\r\n\t\tthis.scroller.destroy(); // will remove the Grid too\r\n\t},\r\n\r\n\r\n\tupdateSize: function(totalHeight, isAuto, isResize) {\r\n\t\tthis.scroller.setHeight(this.computeScrollerHeight(totalHeight));\r\n\t},\r\n\r\n\r\n\tcomputeScrollerHeight: function(totalHeight) {\r\n\t\treturn totalHeight -\r\n\t\t\tsubtractInnerElHeight(this.el, this.scroller.el); // everything that's NOT the scroller\r\n\t},\r\n\r\n\r\n\trenderDates: function(dateProfile) {\r\n\t\tvar calendar = this.calendar;\r\n\t\tvar dayStart = calendar.msToUtcMoment(dateProfile.renderUnzonedRange.startMs, true);\r\n\t\tvar viewEnd = calendar.msToUtcMoment(dateProfile.renderUnzonedRange.endMs, true);\r\n\t\tvar dayDates = [];\r\n\t\tvar dayRanges = [];\r\n\r\n\t\twhile (dayStart < viewEnd) {\r\n\r\n\t\t\tdayDates.push(dayStart.clone());\r\n\r\n\t\t\tdayRanges.push(new UnzonedRange(\r\n\t\t\t\tdayStart,\r\n\t\t\t\tdayStart.clone().add(1, 'day')\r\n\t\t\t));\r\n\r\n\t\t\tdayStart.add(1, 'day');\r\n\t\t}\r\n\r\n\t\tthis.dayDates = dayDates;\r\n\t\tthis.dayRanges = dayRanges;\r\n\r\n\t\t// all real rendering happens in EventRenderer\r\n\t},\r\n\r\n\r\n\t// slices by day\r\n\tcomponentFootprintToSegs: function(footprint) {\r\n\t\tvar dayRanges = this.dayRanges;\r\n\t\tvar dayIndex;\r\n\t\tvar segRange;\r\n\t\tvar seg;\r\n\t\tvar segs = [];\r\n\r\n\t\tfor (dayIndex = 0; dayIndex < dayRanges.length; dayIndex++) {\r\n\t\t\tsegRange = footprint.unzonedRange.intersect(dayRanges[dayIndex]);\r\n\r\n\t\t\tif (segRange) {\r\n\t\t\t\tseg = {\r\n\t\t\t\t\tstartMs: segRange.startMs,\r\n\t\t\t\t\tendMs: segRange.endMs,\r\n\t\t\t\t\tisStart: segRange.isStart,\r\n\t\t\t\t\tisEnd: segRange.isEnd,\r\n\t\t\t\t\tdayIndex: dayIndex\r\n\t\t\t\t};\r\n\r\n\t\t\t\tsegs.push(seg);\r\n\r\n\t\t\t\t// detect when footprint won't go fully into the next day,\r\n\t\t\t\t// and mutate the latest seg to the be the end.\r\n\t\t\t\tif (\r\n\t\t\t\t\t!seg.isEnd && !footprint.isAllDay &&\r\n\t\t\t\t\tdayIndex + 1 < dayRanges.length &&\r\n\t\t\t\t\tfootprint.unzonedRange.endMs < dayRanges[dayIndex + 1].startMs + this.nextDayThreshold\r\n\t\t\t\t) {\r\n\t\t\t\t\tseg.endMs = footprint.unzonedRange.endMs;\r\n\t\t\t\t\tseg.isEnd = true;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn segs;\r\n\t},\r\n\r\n\r\n\teventRendererClass: EventRenderer.extend({\r\n\r\n\r\n\t\trenderFgSegs: function(segs) {\r\n\t\t\tif (!segs.length) {\r\n\t\t\t\tthis.component.renderEmptyMessage();\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tthis.component.renderSegList(segs);\r\n\t\t\t}\r\n\t\t},\r\n\r\n\r\n\t\t// generates the HTML for a single event row\r\n\t\tfgSegHtml: function(seg) {\r\n\t\t\tvar view = this.view;\r\n\t\t\tvar calendar = view.calendar;\r\n\t\t\tvar theme = calendar.theme;\r\n\t\t\tvar eventFootprint = seg.footprint;\r\n\t\t\tvar eventDef = eventFootprint.eventDef;\r\n\t\t\tvar componentFootprint = eventFootprint.componentFootprint;\r\n\t\t\tvar url = eventDef.url;\r\n\t\t\tvar classes = [ 'fc-list-item' ].concat(this.getClasses(eventDef));\r\n\t\t\tvar bgColor = this.getBgColor(eventDef);\r\n\t\t\tvar timeHtml;\r\n\r\n\t\t\tif (componentFootprint.isAllDay) {\r\n\t\t\t\ttimeHtml = view.getAllDayHtml();\r\n\t\t\t}\r\n\t\t\t// if the event appears to span more than one day\r\n\t\t\telse if (view.isMultiDayRange(componentFootprint.unzonedRange)) {\r\n\t\t\t\tif (seg.isStart || seg.isEnd) { // outer segment that probably lasts part of the day\r\n\t\t\t\t\ttimeHtml = htmlEscape(this._getTimeText(\r\n\t\t\t\t\t\tcalendar.msToMoment(seg.startMs),\r\n\t\t\t\t\t\tcalendar.msToMoment(seg.endMs),\r\n\t\t\t\t\t\tcomponentFootprint.isAllDay\r\n\t\t\t\t\t));\r\n\t\t\t\t}\r\n\t\t\t\telse { // inner segment that lasts the whole day\r\n\t\t\t\t\ttimeHtml = view.getAllDayHtml();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\t// Display the normal time text for the *event's* times\r\n\t\t\t\ttimeHtml = htmlEscape(this.getTimeText(eventFootprint));\r\n\t\t\t}\r\n\r\n\t\t\tif (url) {\r\n\t\t\t\tclasses.push('fc-has-url');\r\n\t\t\t}\r\n\r\n\t\t\treturn '<tr class=\"' + classes.join(' ') + '\">' +\r\n\t\t\t\t(this.displayEventTime ?\r\n\t\t\t\t\t'<td class=\"fc-list-item-time ' + theme.getClass('widgetContent') + '\">' +\r\n\t\t\t\t\t\t(timeHtml || '') +\r\n\t\t\t\t\t'</td>' :\r\n\t\t\t\t\t'') +\r\n\t\t\t\t'<td class=\"fc-list-item-marker ' + theme.getClass('widgetContent') + '\">' +\r\n\t\t\t\t\t'<span class=\"fc-event-dot\"' +\r\n\t\t\t\t\t(bgColor ?\r\n\t\t\t\t\t\t' style=\"background-color:' + bgColor + '\"' :\r\n\t\t\t\t\t\t'') +\r\n\t\t\t\t\t'></span>' +\r\n\t\t\t\t'</td>' +\r\n\t\t\t\t'<td class=\"fc-list-item-title ' + theme.getClass('widgetContent') + '\">' +\r\n\t\t\t\t\t'<a' + (url ? ' href=\"' + htmlEscape(url) + '\"' : '') + '>' +\r\n\t\t\t\t\t\thtmlEscape(eventDef.title || '') +\r\n\t\t\t\t\t'</a>' +\r\n\t\t\t\t'</td>' +\r\n\t\t\t'</tr>';\r\n\t\t},\r\n\r\n\r\n\t\t// like \"4:00am\"\r\n\t\tcomputeEventTimeFormat: function() {\r\n\t\t\treturn this.opt('mediumTimeFormat');\r\n\t\t}\r\n\r\n\t}),\r\n\r\n\r\n\teventPointingClass: EventPointing.extend({\r\n\r\n\t\t// for events with a url, the whole <tr> should be clickable,\r\n\t\t// but it's impossible to wrap with an <a> tag. simulate this.\r\n\t\thandleClick: function(seg, ev) {\r\n\t\t\tvar url;\r\n\r\n\t\t\tEventPointing.prototype.handleClick.apply(this, arguments); // super. might prevent the default action\r\n\r\n\t\t\t// not clicking on or within an <a> with an href\r\n\t\t\tif (!$(ev.target).closest('a[href]').length) {\r\n\t\t\t\turl = seg.footprint.eventDef.url;\r\n\r\n\t\t\t\tif (url && !ev.isDefaultPrevented()) { // jsEvent not cancelled in handler\r\n\t\t\t\t\twindow.location.href = url; // simulate link click\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t}),\r\n\r\n\r\n\trenderEmptyMessage: function() {\r\n\t\tthis.contentEl.html(\r\n\t\t\t'<div class=\"fc-list-empty-wrap2\">' + // TODO: try less wraps\r\n\t\t\t'<div class=\"fc-list-empty-wrap1\">' +\r\n\t\t\t'<div class=\"fc-list-empty\">' +\r\n\t\t\t\thtmlEscape(this.opt('noEventsMessage')) +\r\n\t\t\t'</div>' +\r\n\t\t\t'</div>' +\r\n\t\t\t'</div>'\r\n\t\t);\r\n\t},\r\n\r\n\r\n\t// render the event segments in the view\r\n\trenderSegList: function(allSegs) {\r\n\t\tvar segsByDay = this.groupSegsByDay(allSegs); // sparse array\r\n\t\tvar dayIndex;\r\n\t\tvar daySegs;\r\n\t\tvar i;\r\n\t\tvar tableEl = $('<table class=\"fc-list-table ' + this.calendar.theme.getClass('tableList') + '\"><tbody/></table>');\r\n\t\tvar tbodyEl = tableEl.find('tbody');\r\n\r\n\t\tfor (dayIndex = 0; dayIndex < segsByDay.length; dayIndex++) {\r\n\t\t\tdaySegs = segsByDay[dayIndex];\r\n\r\n\t\t\tif (daySegs) { // sparse array, so might be undefined\r\n\r\n\t\t\t\t// append a day header\r\n\t\t\t\ttbodyEl.append(this.dayHeaderHtml(this.dayDates[dayIndex]));\r\n\r\n\t\t\t\tthis.eventRenderer.sortEventSegs(daySegs);\r\n\r\n\t\t\t\tfor (i = 0; i < daySegs.length; i++) {\r\n\t\t\t\t\ttbodyEl.append(daySegs[i].el); // append event row\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis.contentEl.empty().append(tableEl);\r\n\t},\r\n\r\n\r\n\t// Returns a sparse array of arrays, segs grouped by their dayIndex\r\n\tgroupSegsByDay: function(segs) {\r\n\t\tvar segsByDay = []; // sparse array\r\n\t\tvar i, seg;\r\n\r\n\t\tfor (i = 0; i < segs.length; i++) {\r\n\t\t\tseg = segs[i];\r\n\t\t\t(segsByDay[seg.dayIndex] || (segsByDay[seg.dayIndex] = []))\r\n\t\t\t\t.push(seg);\r\n\t\t}\r\n\r\n\t\treturn segsByDay;\r\n\t},\r\n\r\n\r\n\t// generates the HTML for the day headers that live amongst the event rows\r\n\tdayHeaderHtml: function(dayDate) {\r\n\t\tvar mainFormat = this.opt('listDayFormat');\r\n\t\tvar altFormat = this.opt('listDayAltFormat');\r\n\r\n\t\treturn '<tr class=\"fc-list-heading\" data-date=\"' + dayDate.format('YYYY-MM-DD') + '\">' +\r\n\t\t\t'<td class=\"' + this.calendar.theme.getClass('widgetHeader') + '\" colspan=\"3\">' +\r\n\t\t\t\t(mainFormat ?\r\n\t\t\t\t\tthis.buildGotoAnchorHtml(\r\n\t\t\t\t\t\tdayDate,\r\n\t\t\t\t\t\t{ 'class': 'fc-list-heading-main' },\r\n\t\t\t\t\t\thtmlEscape(dayDate.format(mainFormat)) // inner HTML\r\n\t\t\t\t\t) :\r\n\t\t\t\t\t'') +\r\n\t\t\t\t(altFormat ?\r\n\t\t\t\t\tthis.buildGotoAnchorHtml(\r\n\t\t\t\t\t\tdayDate,\r\n\t\t\t\t\t\t{ 'class': 'fc-list-heading-alt' },\r\n\t\t\t\t\t\thtmlEscape(dayDate.format(altFormat)) // inner HTML\r\n\t\t\t\t\t) :\r\n\t\t\t\t\t'') +\r\n\t\t\t'</td>' +\r\n\t\t'</tr>';\r\n\t}\r\n\r\n});\r\n\r\n;;\r\n\r\nfcViews.list = {\r\n\t'class': ListView,\r\n\tbuttonTextKey: 'list', // what to lookup in locale files\r\n\tdefaults: {\r\n\t\tbuttonText: 'list', // text to display for English\r\n\t\tlistDayFormat: 'LL', // like \"January 1, 2016\"\r\n\t\tnoEventsMessage: 'No events to display'\r\n\t}\r\n};\r\n\r\nfcViews.listDay = {\r\n\ttype: 'list',\r\n\tduration: { days: 1 },\r\n\tdefaults: {\r\n\t\tlistDayFormat: 'dddd' // day-of-week is all we need. full date is probably in header\r\n\t}\r\n};\r\n\r\nfcViews.listWeek = {\r\n\ttype: 'list',\r\n\tduration: { weeks: 1 },\r\n\tdefaults: {\r\n\t\tlistDayFormat: 'dddd', // day-of-week is more important\r\n\t\tlistDayAltFormat: 'LL'\r\n\t}\r\n};\r\n\r\nfcViews.listMonth = {\r\n\ttype: 'list',\r\n\tduration: { month: 1 },\r\n\tdefaults: {\r\n\t\tlistDayAltFormat: 'dddd' // day-of-week is nice-to-have\r\n\t}\r\n};\r\n\r\nfcViews.listYear = {\r\n\ttype: 'list',\r\n\tduration: { year: 1 },\r\n\tdefaults: {\r\n\t\tlistDayAltFormat: 'dddd' // day-of-week is nice-to-have\r\n\t}\r\n};\r\n\r\n;;\r\n\r\nreturn FC; // export for Node/CommonJS\r\n});",null]}