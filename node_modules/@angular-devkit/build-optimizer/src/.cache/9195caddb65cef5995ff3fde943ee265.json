{"remainingRequest":"D:\\SIGESPRO\\sigespro\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--3-1!D:\\SIGESPRO\\sigespro\\src\\assets\\charts\\amchart\\serial.js","dependencies":[{"path":"D:\\SIGESPRO\\sigespro\\src\\assets\\charts\\amchart\\serial.js","mtime":1582660898073},{"path":"D:\\SIGESPRO\\sigespro\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1582660885942},{"path":"D:\\SIGESPRO\\sigespro\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1582660881929}],"contextDependencies":[],"result":["(function () {\r\n    var e = window.AmCharts;\r\n    e.AmRectangularChart = e.Class({ inherits: e.AmCoordinateChart, construct: function (a) { e.AmRectangularChart.base.construct.call(this, a); this.theme = a; this.createEvents(\"zoomed\", \"changed\"); this.marginRight = this.marginBottom = this.marginTop = this.marginLeft = 20; this.depth3D = this.angle = 0; this.plotAreaFillColors = \"#FFFFFF\"; this.plotAreaFillAlphas = 0; this.plotAreaBorderColor = \"#000000\"; this.plotAreaBorderAlpha = 0; this.maxZoomFactor = 20; this.zoomOutButtonImageSize = 19; this.zoomOutButtonImage = \"lens\"; this.zoomOutText = \"Show all\"; this.zoomOutButtonColor = \"#e5e5e5\"; this.zoomOutButtonAlpha = 0; this.zoomOutButtonRollOverAlpha = 1; this.zoomOutButtonPadding = 8; this.trendLines = []; this.autoMargins = !0; this.marginsUpdated = !1; this.autoMarginOffset = 10; e.applyTheme(this, a, \"AmRectangularChart\"); }, initChart: function () { e.AmRectangularChart.base.initChart.call(this); this.updateDxy(); !this.marginsUpdated && this.autoMargins && (this.resetMargins(), this.drawGraphs = !1); this.processScrollbars(); this.updateMargins(); this.updatePlotArea(); this.updateScrollbars(); this.updateTrendLines(); this.updateChartCursor(); this.updateValueAxes(); this.scrollbarOnly || this.updateGraphs(); }, drawChart: function () { e.AmRectangularChart.base.drawChart.call(this); this.drawPlotArea(); if (e.ifArray(this.chartData)) {\r\n            var a = this.chartCursor;\r\n            a && a.draw();\r\n        } }, resetMargins: function () { var a = {}, b; if (\"xy\" == this.type) {\r\n            var c = this.xAxes, d = this.yAxes;\r\n            for (b = 0; b < c.length; b++) {\r\n                var g = c[b];\r\n                g.ignoreAxisWidth || (g.setOrientation(!0), g.fixAxisPosition(), a[g.position] = !0);\r\n            }\r\n            for (b = 0; b < d.length; b++)\r\n                c = d[b], c.ignoreAxisWidth || (c.setOrientation(!1), c.fixAxisPosition(), a[c.position] = !0);\r\n        }\r\n        else {\r\n            d = this.valueAxes;\r\n            for (b = 0; b < d.length; b++)\r\n                c = d[b], c.ignoreAxisWidth || (c.setOrientation(this.rotate), c.fixAxisPosition(), a[c.position] = !0);\r\n            (b = this.categoryAxis) && !b.ignoreAxisWidth && (b.setOrientation(!this.rotate), b.fixAxisPosition(), b.fixAxisPosition(), a[b.position] = !0);\r\n        } a.left && (this.marginLeft = 0); a.right && (this.marginRight = 0); a.top && (this.marginTop = 0); a.bottom && (this.marginBottom = 0); this.fixMargins = a; }, measureMargins: function () { var a = this.valueAxes, b, c = this.autoMarginOffset, d = this.fixMargins, g = this.realWidth, h = this.realHeight, f = c, e = c, l = g; b = h; var m; for (m = 0; m < a.length; m++)\r\n            a[m].handleSynchronization(), b = this.getAxisBounds(a[m], f, l, e, b), f = Math.round(b.l), l = Math.round(b.r), e = Math.round(b.t), b = Math.round(b.b); if (a = this.categoryAxis)\r\n            b = this.getAxisBounds(a, f, l, e, b), f = Math.round(b.l), l = Math.round(b.r), e = Math.round(b.t), b = Math.round(b.b); d.left && f < c && (this.marginLeft = Math.round(-f + c), !isNaN(this.minMarginLeft) && this.marginLeft < this.minMarginLeft && (this.marginLeft = this.minMarginLeft)); d.right && l >= g - c && (this.marginRight = Math.round(l - g + c), !isNaN(this.minMarginRight) && this.marginRight < this.minMarginRight && (this.marginRight = this.minMarginRight)); d.top && e < c + this.titleHeight && (this.marginTop = Math.round(this.marginTop - e + c + this.titleHeight), !isNaN(this.minMarginTop) && this.marginTop < this.minMarginTop && (this.marginTop = this.minMarginTop)); d.bottom && b > h - c && (this.marginBottom = Math.round(this.marginBottom + b - h + c), !isNaN(this.minMarginBottom) && this.marginBottom < this.minMarginBottom && (this.marginBottom = this.minMarginBottom)); this.initChart(); }, getAxisBounds: function (a, b, c, d, g) { if (!a.ignoreAxisWidth) {\r\n            var h = a.labelsSet, f = a.tickLength;\r\n            a.inside && (f = 0);\r\n            if (h)\r\n                switch (h = a.getBBox(), a.position) {\r\n                    case \"top\":\r\n                        a = h.y;\r\n                        d > a && (d = a);\r\n                        break;\r\n                    case \"bottom\":\r\n                        a = h.y + h.height;\r\n                        g < a && (g = a);\r\n                        break;\r\n                    case \"right\":\r\n                        a = h.x + h.width + f + 3;\r\n                        c < a && (c = a);\r\n                        break;\r\n                    case \"left\": a = h.x - f, b > a && (b = a);\r\n                }\r\n        } return { l: b, t: d, r: c, b: g }; }, drawZoomOutButton: function () { var a = this; if (!a.zbSet) {\r\n            var b = a.container.set();\r\n            a.zoomButtonSet.push(b);\r\n            var c = a.color, d = a.fontSize, g = a.zoomOutButtonImageSize, h = a.zoomOutButtonImage.replace(/\\.[a-z]*$/i, \"\"), f = a.langObj.zoomOutText || a.zoomOutText, k = a.zoomOutButtonColor, l = a.zoomOutButtonAlpha, m = a.zoomOutButtonFontSize, p = a.zoomOutButtonPadding;\r\n            isNaN(m) || (d = m);\r\n            (m = a.zoomOutButtonFontColor) && (c = m);\r\n            var m = a.zoomOutButton, n;\r\n            m && (m.fontSize && (d = m.fontSize), m.color && (c = m.color), m.backgroundColor && (k = m.backgroundColor), isNaN(m.backgroundAlpha) || (a.zoomOutButtonRollOverAlpha = m.backgroundAlpha));\r\n            var u = m = 0, u = a.pathToImages;\r\n            if (h) {\r\n                if (e.isAbsolute(h) || void 0 === u)\r\n                    u = \"\";\r\n                n = a.container.image(u + h + a.extension, 0, 0, g, g);\r\n                e.setCN(a, n, \"zoom-out-image\");\r\n                b.push(n);\r\n                n = n.getBBox();\r\n                m = n.width + 5;\r\n            }\r\n            void 0 !== f && (c = e.text(a.container, f, c, a.fontFamily, d, \"start\"), e.setCN(a, c, \"zoom-out-label\"), d = c.getBBox(), u = n ? n.height / 2 - 3 : d.height / 2, c.translate(m, u), b.push(c));\r\n            n = b.getBBox();\r\n            c = 1;\r\n            e.isModern || (c = 0);\r\n            k = e.rect(a.container, n.width + 2 * p + 5, n.height + 2 * p - 2, k, 1, 1, k, c);\r\n            k.setAttr(\"opacity\", l);\r\n            k.translate(-p, -p);\r\n            e.setCN(a, k, \"zoom-out-bg\");\r\n            b.push(k);\r\n            k.toBack();\r\n            a.zbBG = k;\r\n            n = k.getBBox();\r\n            b.translate(a.marginLeftReal + a.plotAreaWidth - n.width + p, a.marginTopReal + p);\r\n            b.hide();\r\n            b.mouseover(function () { a.rollOverZB(); }).mouseout(function () { a.rollOutZB(); }).click(function () { a.clickZB(); }).touchstart(function () { a.rollOverZB(); }).touchend(function () { a.rollOutZB(); a.clickZB(); });\r\n            for (l = 0; l < b.length; l++)\r\n                b[l].attr({ cursor: \"pointer\" });\r\n            void 0 !== a.zoomOutButtonTabIndex && (b.setAttr(\"tabindex\", a.zoomOutButtonTabIndex), b.setAttr(\"role\", \"menuitem\"), b.keyup(function (b) { 13 == b.keyCode && a.clickZB(); }));\r\n            a.zbSet = b;\r\n        } }, rollOverZB: function () { this.rolledOverZB = !0; this.zbBG.setAttr(\"opacity\", this.zoomOutButtonRollOverAlpha); }, rollOutZB: function () { this.rolledOverZB = !1; this.zbBG.setAttr(\"opacity\", this.zoomOutButtonAlpha); }, clickZB: function () { this.rolledOverZB = !1; this.zoomOut(); }, zoomOut: function () { this.zoomOutValueAxes(); }, drawPlotArea: function () { var a = this.dx, b = this.dy, c = this.marginLeftReal, d = this.marginTopReal, g = this.plotAreaWidth - 1, h = this.plotAreaHeight - 1, f = this.plotAreaFillColors, k = this.plotAreaFillAlphas, l = this.plotAreaBorderColor, m = this.plotAreaBorderAlpha; \"object\" == typeof k && (k = k[0]); f = e.polygon(this.container, [0, g, g, 0, 0], [0, 0, h, h, 0], f, k, 1, l, m, this.plotAreaGradientAngle); e.setCN(this, f, \"plot-area\"); f.translate(c + a, d + b); this.set.push(f); 0 !== a && 0 !== b && (f = this.plotAreaFillColors, \"object\" == typeof f && (f = f[0]), f = e.adjustLuminosity(f, -.15), g = e.polygon(this.container, [0, a, g + a, g, 0], [0, b, b, 0, 0], f, k, 1, l, m), e.setCN(this, g, \"plot-area-bottom\"), g.translate(c, d + h), this.set.push(g), a = e.polygon(this.container, [0, 0, a, a, 0], [0, h, h + b, b, 0], f, k, 1, l, m), e.setCN(this, a, \"plot-area-left\"), a.translate(c, d), this.set.push(a)); (c = this.bbset) && this.scrollbarOnly && c.remove(); }, updatePlotArea: function () { var a = this.updateWidth(), b = this.updateHeight(), c = this.container; this.realWidth = a; this.realWidth = b; c && this.container.setSize(a, b); var c = this.marginLeftReal, d = this.marginTopReal, a = a - c - this.marginRightReal - this.dx, b = b - d - this.marginBottomReal; 1 > a && (a = 1); 1 > b && (b = 1); this.plotAreaWidth = Math.round(a); this.plotAreaHeight = Math.round(b); this.plotBalloonsSet.translate(c, d); }, updateDxy: function () { this.dx = Math.round(this.depth3D * Math.cos(this.angle * Math.PI / 180)); this.dy = Math.round(-this.depth3D * Math.sin(this.angle * Math.PI / 180)); this.d3x = Math.round(this.columnSpacing3D * Math.cos(this.angle * Math.PI / 180)); this.d3y = Math.round(-this.columnSpacing3D * Math.sin(this.angle * Math.PI / 180)); }, updateMargins: function () { var a = this.getTitleHeight(); this.titleHeight = a; this.marginTopReal = this.marginTop - this.dy; this.fixMargins && !this.fixMargins.top && (this.marginTopReal += a); this.marginBottomReal = this.marginBottom; this.marginLeftReal = this.marginLeft; this.marginRightReal = this.marginRight; }, updateValueAxes: function () { var a = this.valueAxes, b; for (b = 0; b < a.length; b++) {\r\n            var c = a[b];\r\n            this.setAxisRenderers(c);\r\n            this.updateObjectSize(c);\r\n        } }, setAxisRenderers: function (a) { a.axisRenderer = e.RecAxis; a.guideFillRenderer = e.RecFill; a.axisItemRenderer = e.RecItem; a.marginsChanged = !0; }, updateGraphs: function () { var a = this.graphs, b; for (b = 0; b < a.length; b++) {\r\n            var c = a[b];\r\n            c.index = b;\r\n            c.rotate = this.rotate;\r\n            this.updateObjectSize(c);\r\n        } }, updateObjectSize: function (a) { a.width = this.plotAreaWidth - 1; a.height = this.plotAreaHeight - 1; a.x = this.marginLeftReal; a.y = this.marginTopReal; a.dx = this.dx; a.dy = this.dy; }, updateChartCursor: function () { var a = this.chartCursor; a && (a = e.processObject(a, e.ChartCursor, this.theme), this.updateObjectSize(a), this.addChartCursor(a), a.chart = this); }, processScrollbars: function () { var a = this.chartScrollbar; a && (a = e.processObject(a, e.ChartScrollbar, this.theme), this.addChartScrollbar(a)); }, updateScrollbars: function () { }, removeChartCursor: function () { e.callMethod(\"destroy\", [this.chartCursor]); this.chartCursor = null; }, zoomTrendLines: function () { var a = this.trendLines, b; for (b = 0; b < a.length; b++) {\r\n            var c = a[b];\r\n            c.valueAxis.recalculateToPercents ? c.set && c.set.hide() : (c.x = this.marginLeftReal, c.y = this.marginTopReal, c.draw());\r\n        } }, handleCursorValueZoom: function () { }, addTrendLine: function (a) { this.trendLines.push(a); }, zoomOutValueAxes: function () { for (var a = this.valueAxes, b = 0; b < a.length; b++)\r\n            a[b].zoomOut(); }, removeTrendLine: function (a) { var b = this.trendLines, c; for (c = b.length - 1; 0 <= c; c--)\r\n            b[c] == a && b.splice(c, 1); }, adjustMargins: function (a, b) { var c = a.position, d = a.scrollbarHeight + a.offset; a.enabled && (\"top\" == c ? b ? this.marginLeftReal += d : this.marginTopReal += d : b ? this.marginRightReal += d : this.marginBottomReal += d); }, getScrollbarPosition: function (a, b, c) { var d = \"bottom\", g = \"top\"; a.oppositeAxis || (g = d, d = \"top\"); a.position = b ? \"bottom\" == c || \"left\" == c ? d : g : \"top\" == c || \"right\" == c ? d : g; }, updateChartScrollbar: function (a, b) { if (a) {\r\n            a.rotate = b;\r\n            var c = this.marginTopReal, d = this.marginLeftReal, g = a.scrollbarHeight, h = this.dx, f = this.dy, e = a.offset;\r\n            \"top\" == a.position ? b ? (a.y = c, a.x = d - g - e) : (a.y = c - g + f - e, a.x = d + h) : b ? (a.y = c + f, a.x = d + this.plotAreaWidth + h + e) : (a.y = c + this.plotAreaHeight + e, a.x = this.marginLeftReal);\r\n        } }, showZB: function (a) { var b = this.zbSet; a && (b = this.zoomOutText, \"\" !== b && b && this.drawZoomOutButton()); if (b = this.zbSet)\r\n            this.zoomButtonSet.push(b), a ? b.show() : b.hide(), this.rollOutZB(); }, handleReleaseOutside: function (a) { e.AmRectangularChart.base.handleReleaseOutside.call(this, a); (a = this.chartCursor) && a.handleReleaseOutside && a.handleReleaseOutside(); }, handleMouseDown: function (a) { e.AmRectangularChart.base.handleMouseDown.call(this, a); var b = this.chartCursor; b && b.handleMouseDown && !this.rolledOverZB && b.handleMouseDown(a); }, update: function () { e.AmRectangularChart.base.update.call(this); this.chartCursor && this.chartCursor.update && this.chartCursor.update(); }, handleScrollbarValueZoom: function (a) { this.relativeZoomValueAxes(a.target.valueAxes, a.relativeStart, a.relativeEnd); this.zoomAxesAndGraphs(); }, zoomValueScrollbar: function (a) { if (a && a.enabled) {\r\n            var b = a.valueAxes[0], c = b.relativeStart, d = b.relativeEnd;\r\n            b.reversed && (d = 1 - c, c = 1 - b.relativeEnd);\r\n            a.percentZoom(c, d);\r\n        } }, zoomAxesAndGraphs: function () { if (!this.scrollbarOnly) {\r\n            var a = this.valueAxes, b;\r\n            for (b = 0; b < a.length; b++)\r\n                a[b].zoom(this.start, this.end);\r\n            a = this.graphs;\r\n            for (b = 0; b < a.length; b++)\r\n                a[b].zoom(this.start, this.end);\r\n            (b = this.chartCursor) && b.clearSelection();\r\n            this.zoomTrendLines();\r\n        } }, handleValueAxisZoomReal: function (a, b) { var c = a.relativeStart, d = a.relativeEnd; if (c > d)\r\n            var g = c, c = d, d = g; this.relativeZoomValueAxes(b, c, d); this.updateAfterValueZoom(); }, updateAfterValueZoom: function () { this.zoomAxesAndGraphs(); this.zoomScrollbar(); }, relativeZoomValueAxes: function (a, b, c) { this.hideBalloonReal(); b = e.fitToBounds(b, 0, 1); c = e.fitToBounds(c, 0, 1); if (b > c) {\r\n            var d = b;\r\n            b = c;\r\n            c = d;\r\n        } var d = 1 / this.maxZoomFactor, g = e.getDecimals(d) + 4; c - b < d && (c = b + (c - b) / 2, b = c - d / 2, c += d / 2, 1 < c && (b -= c - 1, c = 1), 0 > b && (b = 0, c = d)); b = e.roundTo(b, g); c = e.roundTo(c, g); d = !1; if (a) {\r\n            for (g = 0; g < a.length; g++) {\r\n                var h = a[g].zoomToRelativeValues(b, c, !0);\r\n                h && (d = h);\r\n            }\r\n            this.showZB();\r\n        } return d; }, addChartCursor: function (a) {\r\n            e.callMethod(\"destroy\", [this.chartCursor]);\r\n            a && (this.listenTo(a, \"moved\", this.handleCursorMove), this.listenTo(a, \"zoomed\", this.handleCursorZoom), this.listenTo(a, \"zoomStarted\", this.handleCursorZoomStarted), this.listenTo(a, \"panning\", this.handleCursorPanning), this.listenTo(a, \"onHideCursor\", this.handleCursorHide));\r\n            this.chartCursor = a;\r\n        }, handleCursorChange: function () { }, handleCursorMove: function (a) { var b, c = this.valueAxes; for (b = 0; b < c.length; b++)\r\n            if (!a.panning) {\r\n                var d = c[b];\r\n                d && d.showBalloon && d.showBalloon(a.x, a.y);\r\n            } }, handleCursorZoom: function (a) { if (this.skipZoomed)\r\n            this.skipZoomed = !1;\r\n        else {\r\n            var b = this.startX0, c = this.endX0, d = this.endY0, g = this.startY0, h = a.startX, f = a.endX, e = a.startY, l = a.endY;\r\n            this.startX0 = this.endX0 = this.startY0 = this.endY0 = NaN;\r\n            this.handleCursorZoomReal(b + h * (c - b), b + f * (c - b), g + e * (d - g), g + l * (d - g), a);\r\n        } }, handleCursorHide: function () { var a, b = this.valueAxes; for (a = 0; a < b.length; a++)\r\n            b[a].hideBalloon(); b = this.graphs; for (a = 0; a < b.length; a++)\r\n            b[a].hideBalloonReal(); } });\r\n})();\r\n(function () {\r\n    var e = window.AmCharts;\r\n    e.AmSerialChart = e.Class({ inherits: e.AmRectangularChart, construct: function (a) { this.type = \"serial\"; e.AmSerialChart.base.construct.call(this, a); this.cname = \"AmSerialChart\"; this.theme = a; this.columnSpacing = 5; this.columnSpacing3D = 0; this.columnWidth = .8; var b = new e.CategoryAxis(a); b.chart = this; this.categoryAxis = b; this.zoomOutOnDataUpdate = !0; this.mouseWheelZoomEnabled = this.mouseWheelScrollEnabled = this.rotate = this.skipZoom = !1; this.minSelectedTime = 0; e.applyTheme(this, a, this.cname); }, initChart: function () { e.AmSerialChart.base.initChart.call(this); this.updateCategoryAxis(this.categoryAxis, this.rotate, \"categoryAxis\"); if (this.dataChanged)\r\n            this.parseData();\r\n        else\r\n            this.onDataUpdated(); this.drawGraphs = !0; }, onDataUpdated: function () { var a = this.countColumns(), b = this.chartData, c = this.graphs, d; for (d = 0; d < c.length; d++) {\r\n            var g = c[d];\r\n            g.data = b;\r\n            g.columnCount = a;\r\n        } 0 < b.length && (this.firstTime = this.getStartTime(b[0].time), this.lastTime = this.getEndTime(b[b.length - 1].time)); this.drawChart(); this.autoMargins && !this.marginsUpdated ? (this.marginsUpdated = !0, this.measureMargins()) : this.dispDUpd(); }, syncGrid: function () {\r\n            if (this.synchronizeGrid) {\r\n                var a = this.valueAxes, b, c;\r\n                if (0 < a.length) {\r\n                    var d = 0;\r\n                    for (c = 0; c < a.length; c++)\r\n                        b = a[c], d < b.gridCountReal && (d = b.gridCountReal);\r\n                    var g = !1;\r\n                    for (c = 0; c < a.length; c++)\r\n                        if (b = a[c], b.gridCountReal < d) {\r\n                            var h = (d - b.gridCountReal) / 2, f = g = h;\r\n                            0 !== h - Math.round(h) && (g -= .5, f += .5);\r\n                            0 <= b.min && 0 > b.min - g * b.step && (f += g, g = 0);\r\n                            0 >= b.max && 0 < b.max + f * b.step && (g += f, f = 0);\r\n                            h = e.getDecimals(b.step);\r\n                            b.minimum = e.roundTo(b.min -\r\n                                g * b.step, h);\r\n                            b.maximum = e.roundTo(b.max + f * b.step, h);\r\n                            b.setStep = b.step;\r\n                            g = b.strictMinMax = !0;\r\n                        }\r\n                    g && this.updateAfterValueZoom();\r\n                    for (c = 0; c < a.length; c++)\r\n                        b = a[c], b.minimum = NaN, b.maximum = NaN, b.setStep = NaN, b.strictMinMax = !1;\r\n                }\r\n            }\r\n        }, handleWheelReal: function (a, b) {\r\n            if (!this.wheelBusy) {\r\n                var c = this.categoryAxis, d = c.parseDates, g = c.minDuration(), e = 1, f = 1;\r\n                this.mouseWheelZoomEnabled ? b || (e = -1) : b && (e = -1);\r\n                var k = this.chartCursor;\r\n                if (k) {\r\n                    var l = k.mouseX, k = k.mouseY;\r\n                    e != f && (l = this.rotate ? k / this.plotAreaHeight : l / this.plotAreaWidth, e *= l, f *= 1 -\r\n                        l);\r\n                    l = .05 * (this.end - this.start);\r\n                    d && (l = .05 * (this.endTime - this.startTime) / g);\r\n                    1 > l && (l = 1);\r\n                    e *= l;\r\n                    f *= l;\r\n                    if (!d || c.equalSpacing)\r\n                        e = Math.round(e), f = Math.round(f);\r\n                }\r\n                k = this.chartData.length;\r\n                c = this.lastTime;\r\n                l = this.firstTime;\r\n                0 > a ? d ? (k = this.endTime - this.startTime, d = this.startTime + e * g, g = this.endTime + f * g, 0 < f && 0 < e && g >= c && (g = c, d = c - k), this.zoomToDates(new Date(d), new Date(g))) : (0 < f && 0 < e && this.end >= k - 1 && (e = f = 0), d = this.start + e, g = this.end + f, this.zoomToIndexes(d, g)) : d ? (k = this.endTime - this.startTime, d = this.startTime - e * g, g = this.endTime -\r\n                    f * g, 0 < f && 0 < e && d <= l && (d = l, g = l + k), this.zoomToDates(new Date(d), new Date(g))) : (0 < f && 0 < e && 1 > this.start && (e = f = 0), d = this.start - e, g = this.end - f, this.zoomToIndexes(d, g));\r\n            }\r\n        }, validateData: function (a) { this.marginsUpdated = !1; this.zoomOutOnDataUpdate && !a && (this.endTime = this.end = this.startTime = this.start = NaN); var b = a = !1, c = !1, d = this.chartScrollbar; d && (d.dragging && (a = !0, d.handleDragStop()), d.resizingRight && (c = !0, d.rightDragStop()), d.resizingLeft && (b = !0, d.leftDragStop())); e.AmSerialChart.base.validateData.call(this); a && d.handleDragStart(); c && d.rightDragStart(); b && d.leftDragStart(); }, drawChart: function () { if (0 < this.realWidth && 0 < this.realHeight) {\r\n            e.AmSerialChart.base.drawChart.call(this);\r\n            var a = this.chartData;\r\n            if (e.ifArray(a)) {\r\n                var b = this.chartScrollbar;\r\n                !b || !this.marginsUpdated && this.autoMargins || b.draw();\r\n                (b = this.valueScrollbar) && b.draw();\r\n                var b = a.length - 1, c, d;\r\n                c = this.categoryAxis;\r\n                if (c.parseDates && !c.equalSpacing) {\r\n                    if (c = this.startTime, d = this.endTime, isNaN(c) || isNaN(d))\r\n                        c = this.firstTime, d = this.lastTime;\r\n                }\r\n                else {\r\n                    c = this.start;\r\n                    d = this.end;\r\n                    if (isNaN(c) || isNaN(d))\r\n                        d = c = NaN;\r\n                    isNaN(c) && (isNaN(this.startTime) || (c = this.getClosestIndex(a, \"time\", this.startTime, !0, 0, a.length)));\r\n                    isNaN(d) && (isNaN(this.endTime) || (d = this.getClosestIndex(a, \"time\", this.endTime, !1, 0, a.length)));\r\n                    if (isNaN(c) || isNaN(d))\r\n                        c = 0, d = b;\r\n                }\r\n                this.endTime = this.startTime = this.end = this.start = void 0;\r\n                this.zoom(c, d);\r\n            }\r\n        }\r\n        else\r\n            this.cleanChart(); }, cleanChart: function () { e.callMethod(\"destroy\", [this.valueAxes, this.graphs, this.categoryAxis, this.chartScrollbar, this.chartCursor, this.valueScrollbar]); }, updateCategoryAxis: function (a, b, c) { a.chart = this; a.id = c; a.rotate = b; a.setOrientation(!this.rotate); a.init(); this.setAxisRenderers(a); this.updateObjectSize(a); }, updateValueAxes: function () { e.AmSerialChart.base.updateValueAxes.call(this); var a = this.valueAxes, b; for (b = 0; b < a.length; b++) {\r\n            var c = a[b], d = this.rotate;\r\n            c.rotate = d;\r\n            c.setOrientation(d);\r\n            d = this.categoryAxis;\r\n            if (!d.startOnAxis || d.parseDates)\r\n                c.expandMinMax = !0;\r\n        } }, getStartTime: function (a) { var b = this.categoryAxis; return e.resetDateToMin(new Date(a), b.minPeriod, 1, b.firstDayOfWeek).getTime(); }, getEndTime: function (a) { var b = e.extractPeriod(this.categoryAxis.minPeriod); return e.changeDate(new Date(a), b.period, b.count, !0).getTime() - 1; }, updateMargins: function () { e.AmSerialChart.base.updateMargins.call(this); var a = this.chartScrollbar; a && (this.getScrollbarPosition(a, this.rotate, this.categoryAxis.position), this.adjustMargins(a, this.rotate)); if (a = this.valueScrollbar)\r\n            this.getScrollbarPosition(a, !this.rotate, this.valueAxes[0].position), this.adjustMargins(a, !this.rotate); }, updateScrollbars: function () { e.AmSerialChart.base.updateScrollbars.call(this); this.updateChartScrollbar(this.chartScrollbar, this.rotate); this.updateChartScrollbar(this.valueScrollbar, !this.rotate); }, zoom: function (a, b) { var c = this.categoryAxis; c.parseDates && !c.equalSpacing ? (this.timeZoom(a, b), isNaN(a) && this.zoomOutValueAxes()) : this.indexZoom(a, b); (c = this.chartCursor) && (c.pan || c.hideCursorReal()); this.updateLegendValues(); }, timeZoom: function (a, b) {\r\n            var c = this.maxSelectedTime;\r\n            isNaN(c) || (b != this.endTime && b -\r\n                a > c && (a = b - c), a != this.startTime && b - a > c && (b = a + c));\r\n            var d = this.minSelectedTime;\r\n            if (0 < d && b - a < d) {\r\n                var g = Math.round(a + (b - a) / 2), d = Math.round(d / 2);\r\n                a = g - d;\r\n                b = g + d;\r\n            }\r\n            d = this.chartData;\r\n            g = this.categoryAxis;\r\n            if (e.ifArray(d) && (a != this.startTime || b != this.endTime)) {\r\n                var h = g.minDuration(), f = this.firstTime, k = this.lastTime;\r\n                a || (a = f, isNaN(c) || (a = k - c));\r\n                b || (b = k);\r\n                a > k && (a = k);\r\n                b < f && (b = f);\r\n                a < f && (a = f);\r\n                b > k && (b = k);\r\n                b < a && (b = a + h);\r\n                b - a < h / 5 && (b < k ? b = a + h / 5 : a = b - h / 5);\r\n                this.startTime = a;\r\n                this.endTime = b;\r\n                c = d.length - 1;\r\n                h = this.getClosestIndex(d, \"time\", a, !0, 0, c);\r\n                d = this.getClosestIndex(d, \"time\", b, !1, h, c);\r\n                g.timeZoom(a, b);\r\n                g.zoom(h, d);\r\n                this.start = e.fitToBounds(h, 0, c);\r\n                this.end = e.fitToBounds(d, 0, c);\r\n                this.zoomAxesAndGraphs();\r\n                this.zoomScrollbar();\r\n                this.fixCursor();\r\n                this.showZB();\r\n                this.syncGrid();\r\n                this.updateColumnsDepth();\r\n                this.dispatchTimeZoomEvent();\r\n            }\r\n        }, showZB: function () { var a, b = this.categoryAxis; b && b.parseDates && !b.equalSpacing && (this.startTime > this.firstTime && (a = !0), this.endTime < this.lastTime && (a = !0)); 0 < this.start && (a = !0); this.end < this.chartData.length - 1 && (a = !0); if (b = this.valueAxes)\r\n            b = b[0], isNaN(b.relativeStart) || (0 !== e.roundTo(b.relativeStart, 3) && (a = !0), 1 != e.roundTo(b.relativeEnd, 3) && (a = !0)); e.AmSerialChart.base.showZB.call(this, a); }, updateAfterValueZoom: function () { e.AmSerialChart.base.updateAfterValueZoom.call(this); this.updateColumnsDepth(); }, indexZoom: function (a, b) { var c = this.maxSelectedSeries, d = !1; isNaN(c) || (b != this.end && b - a > c && (a = b - c, d = !0), a != this.start && b - a > c && (b = a + c, d = !0)); if (d && (d = this.chartScrollbar) && d.dragger) {\r\n            var g = d.dragger.getBBox();\r\n            d.maxWidth = g.width;\r\n            d.maxHeight = g.height;\r\n        } if (a != this.start || b != this.end)\r\n            d = this.chartData.length - 1, isNaN(a) && (a = 0, isNaN(c) || (a = d - c)), isNaN(b) && (b = d), b < a && (b = a), b > d && (b = d), a > d && (a = d - 1), 0 > a && (a = 0), this.start = a, this.end = b, this.categoryAxis.zoom(a, b), this.zoomAxesAndGraphs(), this.zoomScrollbar(), this.fixCursor(), 0 !== a || b != this.chartData.length - 1 ? this.showZB(!0) : this.showZB(!1), this.syncGrid(), this.updateColumnsDepth(), this.dispatchIndexZoomEvent(); }, updateGraphs: function () { e.AmSerialChart.base.updateGraphs.call(this); var a = this.graphs, b; for (b = 0; b < a.length; b++) {\r\n            var c = a[b];\r\n            c.columnWidthReal = this.columnWidth;\r\n            c.categoryAxis = this.categoryAxis;\r\n            e.isString(c.fillToGraph) && (c.fillToGraph = this.graphsById[c.fillToGraph]);\r\n        } }, zoomAxesAndGraphs: function () { e.AmSerialChart.base.zoomAxesAndGraphs.call(this); this.updateColumnsDepth(); }, updateColumnsDepth: function () { if (0 !== this.depth3D || 0 !== this.angle) {\r\n            var a, b = this.graphs, c;\r\n            this.columnsArray = [];\r\n            for (a = 0; a < b.length; a++) {\r\n                c = b[a];\r\n                var d = c.columnsArray;\r\n                if (d) {\r\n                    var g;\r\n                    for (g = 0; g < d.length; g++)\r\n                        this.columnsArray.push(d[g]);\r\n                }\r\n            }\r\n            this.columnsArray.sort(this.compareDepth);\r\n            b = this.columnsSet;\r\n            if (0 < this.columnsArray.length) {\r\n                d = this.container.set();\r\n                this.columnSet.push(d);\r\n                for (a = 0; a < this.columnsArray.length; a++)\r\n                    d.push(this.columnsArray[a].column.set);\r\n                c && d.translate(c.x, c.y);\r\n                this.columnsSet = d;\r\n            }\r\n            e.remove(b);\r\n        } }, compareDepth: function (a, b) { return a.depth > b.depth ? 1 : -1; }, zoomScrollbar: function () { var a = this.chartScrollbar, b = this.categoryAxis; if (a) {\r\n            if (!this.zoomedByScrollbar) {\r\n                var c = a.dragger;\r\n                c && c.stop();\r\n            }\r\n            this.zoomedByScrollbar = !1;\r\n            b.parseDates && !b.equalSpacing ? a.timeZoom(this.startTime, this.endTime) : a.zoom(this.start, this.end);\r\n        } this.zoomValueScrollbar(this.valueScrollbar); }, updateTrendLines: function () { var a = this.trendLines, b; for (b = 0; b < a.length; b++) {\r\n            var c = a[b], c = e.processObject(c, e.TrendLine, this.theme);\r\n            a[b] = c;\r\n            c.chart = this;\r\n            c.id || (c.id = \"trendLineAuto\" + b + \"_\" + (new Date).getTime());\r\n            e.isString(c.valueAxis) && (c.valueAxis = this.getValueAxisById(c.valueAxis));\r\n            c.valueAxis || (c.valueAxis = this.valueAxes[0]);\r\n            c.categoryAxis = this.categoryAxis;\r\n        } }, countColumns: function () { var a = 0, b = this.valueAxes.length, c = this.graphs.length, d, g, e = !1, f, k; for (k = 0; k < b; k++) {\r\n            g = this.valueAxes[k];\r\n            var l = g.stackType, m = 0;\r\n            if (\"100%\" == l || \"regular\" == l)\r\n                for (e = !1, f = 0; f < c; f++)\r\n                    d = this.graphs[f], d.tcc = 1, d.valueAxis == g && \"column\" == d.type && (!e && d.stackable && (a++, e = !0), (!d.stackable && d.clustered || d.newStack && 0 !== m) && a++, d.columnIndex = a - 1, d.clustered || (d.columnIndex = 0), m++);\r\n            if (\"none\" == l || \"3d\" == l) {\r\n                m = !1;\r\n                for (f = 0; f < c; f++)\r\n                    d = this.graphs[f], d.valueAxis == g && \"column\" == d.type && (d.clustered ? (d.tcc = 1, d.newStack && (a = 0), d.hidden || (d.columnIndex = a, a++)) : d.hidden || (m = !0, d.tcc = 1, d.columnIndex = 0));\r\n                m && 0 === a && (a = 1);\r\n            }\r\n            if (\"3d\" == l) {\r\n                g = 1;\r\n                for (m = 0; m < c; m++)\r\n                    d = this.graphs[m], d.newStack && g++, d.depthCount = g, d.tcc = a;\r\n                a = g;\r\n            }\r\n        } return a; }, parseData: function () { e.AmSerialChart.base.parseData.call(this); this.parseSerialData(this.dataProvider); }, getCategoryIndexByValue: function (a) { var b = this.chartData, c; for (c = 0; c < b.length; c++)\r\n            if (b[c].category == a)\r\n                return c; }, handleScrollbarZoom: function (a) { this.zoomedByScrollbar = !0; this.zoom(a.start, a.end); }, dispatchTimeZoomEvent: function () { if (this.drawGraphs && (this.prevStartTime != this.startTime || this.prevEndTime != this.endTime)) {\r\n            var a = { type: \"zoomed\" };\r\n            a.startDate = new Date(this.startTime);\r\n            a.endDate = new Date(this.endTime);\r\n            a.startIndex = this.start;\r\n            a.endIndex = this.end;\r\n            this.startIndex = this.start;\r\n            this.endIndex = this.end;\r\n            this.startDate = a.startDate;\r\n            this.endDate = a.endDate;\r\n            this.prevStartTime = this.startTime;\r\n            this.prevEndTime = this.endTime;\r\n            var b = this.categoryAxis, c = e.extractPeriod(b.minPeriod).period, b = b.dateFormatsObject[c];\r\n            a.startValue = e.formatDate(a.startDate, b, this);\r\n            a.endValue = e.formatDate(a.endDate, b, this);\r\n            a.chart = this;\r\n            a.target = this;\r\n            this.fire(a);\r\n        } }, dispatchIndexZoomEvent: function () { if (this.drawGraphs && (this.prevStartIndex != this.start || this.prevEndIndex != this.end)) {\r\n            this.startIndex = this.start;\r\n            this.endIndex = this.end;\r\n            var a = this.chartData;\r\n            if (e.ifArray(a) && !isNaN(this.start) && !isNaN(this.end)) {\r\n                var b = { chart: this, target: this, type: \"zoomed\" };\r\n                b.startIndex = this.start;\r\n                b.endIndex = this.end;\r\n                b.startValue = a[this.start].category;\r\n                b.endValue = a[this.end].category;\r\n                this.categoryAxis.parseDates && (this.startTime = a[this.start].time, this.endTime = a[this.end].time, b.startDate = new Date(this.startTime), b.endDate = new Date(this.endTime));\r\n                this.prevStartIndex = this.start;\r\n                this.prevEndIndex = this.end;\r\n                this.fire(b);\r\n            }\r\n        } }, updateLegendValues: function () { this.legend && this.legend.updateValues(); }, getClosestIndex: function (a, b, c, d, g, e) {\r\n            0 > g && (g = 0);\r\n            e > a.length - 1 && (e = a.length - 1);\r\n            var f = g + Math.round((e - g) / 2), k = a[f][b];\r\n            return c == k ? f : 1 >= e - g ? d ? g : Math.abs(a[g][b] - c) < Math.abs(a[e][b] - c) ? g : e : c == k ? f : c < k ? this.getClosestIndex(a, b, c, d, g, f) : this.getClosestIndex(a, b, c, d, f, e);\r\n        }, zoomToIndexes: function (a, b) { var c = this.chartData; if (c) {\r\n            var d = c.length;\r\n            0 < d && (0 > a && (a = 0), b > d - 1 && (b = d - 1), d = this.categoryAxis, d.parseDates && !d.equalSpacing ? this.zoom(c[a].time, this.getEndTime(c[b].time)) : this.zoom(a, b));\r\n        } }, zoomToDates: function (a, b) { var c = this.chartData; if (c)\r\n            if (this.categoryAxis.equalSpacing) {\r\n                var d = this.getClosestIndex(c, \"time\", a.getTime(), !0, 0, c.length);\r\n                b = e.resetDateToMin(b, this.categoryAxis.minPeriod, 1);\r\n                c = this.getClosestIndex(c, \"time\", b.getTime(), !1, 0, c.length);\r\n                this.zoom(d, c);\r\n            }\r\n            else\r\n                this.zoom(a.getTime(), b.getTime()); }, zoomToCategoryValues: function (a, b) { this.chartData && this.zoom(this.getCategoryIndexByValue(a), this.getCategoryIndexByValue(b)); }, formatPeriodString: function (a, b) { if (b) {\r\n            b.periodDataItem = {};\r\n            b.periodPercentDataItem = {};\r\n            var c = [\"value\", \"open\", \"low\", \"high\", \"close\"], d = \"value open low high close average sum count\".split(\" \"), g = b.valueAxis, h = this.chartData, f = b.numberFormatter;\r\n            f || (f = this.nf);\r\n            for (var k = 0; k < c.length; k++) {\r\n                for (var l = c[k], m = 0, p = 0, n = 0, u = 0, v, x, E, t, r, B, q, w, y, C, F = this.start; F <= this.end; F++) {\r\n                    var D = h[F];\r\n                    if (D) {\r\n                        var A = D.axes[g.id].graphs[b.id];\r\n                        if (A) {\r\n                            if (A.values) {\r\n                                var z = A.values[l], D = D.x.categoryAxis;\r\n                                if (this.rotate) {\r\n                                    if (0 > D || D > A.graph.height)\r\n                                        z = NaN;\r\n                                }\r\n                                else if (0 > D || D > A.graph.width)\r\n                                    z = NaN;\r\n                                if (!isNaN(z)) {\r\n                                    isNaN(v) && (v = z);\r\n                                    x = z;\r\n                                    if (isNaN(E) || E > z)\r\n                                        E = z;\r\n                                    if (isNaN(t) || t < z)\r\n                                        t = z;\r\n                                    r = e.getDecimals(m);\r\n                                    D = e.getDecimals(z);\r\n                                    m += z;\r\n                                    m = e.roundTo(m, Math.max(r, D));\r\n                                    p++;\r\n                                    r = m / p;\r\n                                }\r\n                            }\r\n                            if (A.percents && (A = A.percents[l], !isNaN(A))) {\r\n                                isNaN(B) && (B = A);\r\n                                q = A;\r\n                                if (isNaN(w) || w > A)\r\n                                    w = A;\r\n                                if (isNaN(y) || y < A)\r\n                                    y = A;\r\n                                C = e.getDecimals(n);\r\n                                z = e.getDecimals(A);\r\n                                n += A;\r\n                                n = e.roundTo(n, Math.max(C, z));\r\n                                u++;\r\n                                C = n / u;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                m = { open: v, close: x, high: t, low: E, average: r, sum: m, count: p };\r\n                n = { open: B, close: q, high: y, low: w, average: C, sum: n, count: u };\r\n                a = e.formatValue(a, m, d, f, l + \"\\\\.\", this.usePrefixes, this.prefixesOfSmallNumbers, this.prefixesOfBigNumbers);\r\n                a = e.formatValue(a, n, d, this.pf, \"percents\\\\.\" + l + \"\\\\.\");\r\n                b.periodDataItem[l] = m;\r\n                b.periodPercentDataItem[l] = n;\r\n            }\r\n        } return a = e.cleanFromEmpty(a); }, formatString: function (a, b, c) { if (b) {\r\n            var d = b.graph;\r\n            if (void 0 !== a) {\r\n                if (-1 != a.indexOf(\"[[category]]\")) {\r\n                    var g = b.serialDataItem.category;\r\n                    if (this.categoryAxis.parseDates) {\r\n                        var h = this.balloonDateFormat, f = this.chartCursor;\r\n                        f && f.categoryBalloonDateFormat && (h = f.categoryBalloonDateFormat);\r\n                        h = e.formatDate(g, h, this);\r\n                        -1 != h.indexOf(\"fff\") && (h = e.formatMilliseconds(h, g));\r\n                        g = h;\r\n                    }\r\n                    a = a.replace(/\\[\\[category\\]\\]/g, String(g.replace(\"$\", \"$$$\")));\r\n                }\r\n                g = d.numberFormatter;\r\n                g || (g = this.nf);\r\n                h = b.graph.valueAxis;\r\n                (f = h.duration) && !isNaN(b.values.value) && (f = e.formatDuration(b.values.value, f, \"\", h.durationUnits, h.maxInterval, g), a = a.replace(RegExp(\"\\\\[\\\\[value\\\\]\\\\]\", \"g\"), f));\r\n                \"date\" == h.type && (h = e.formatDate(new Date(b.values.value), d.dateFormat, this), f = RegExp(\"\\\\[\\\\[value\\\\]\\\\]\", \"g\"), a = a.replace(f, h), h = e.formatDate(new Date(b.values.open), d.dateFormat, this), f = RegExp(\"\\\\[\\\\[open\\\\]\\\\]\", \"g\"), a = a.replace(f, h));\r\n                d = \"value open low high close total\".split(\" \");\r\n                h = this.pf;\r\n                a = e.formatValue(a, b.percents, d, h, \"percents\\\\.\");\r\n                a = e.formatValue(a, b.values, d, g, \"\", this.usePrefixes, this.prefixesOfSmallNumbers, this.prefixesOfBigNumbers);\r\n                a = e.formatValue(a, b.values, [\"percents\"], h);\r\n                -1 != a.indexOf(\"[[\") && (a = e.formatDataContextValue(a, b.dataContext));\r\n                -1 != a.indexOf(\"[[\") && b.graph.customData && (a = e.formatDataContextValue(a, b.graph.customData));\r\n                a = e.AmSerialChart.base.formatString.call(this, a, b, c);\r\n            }\r\n            return a;\r\n        } }, updateChartCursor: function () { e.AmSerialChart.base.updateChartCursor.call(this); var a = this.chartCursor, b = this.categoryAxis; if (a) {\r\n            var c = a.categoryBalloonAlpha, d = a.categoryBalloonColor, g = a.color;\r\n            void 0 === d && (d = a.cursorColor);\r\n            var h = a.valueZoomable, f = a.zoomable, k = a.valueLineEnabled;\r\n            this.rotate ? (a.vLineEnabled = k, a.hZoomEnabled = h, a.vZoomEnabled = f) : (a.hLineEnabled = k, a.vZoomEnabled = h, a.hZoomEnabled = f);\r\n            if (a.valueLineBalloonEnabled)\r\n                for (k = 0; k < this.valueAxes.length; k++)\r\n                    h = this.valueAxes[k], (f = h.balloon) || (f = {}), f = e.extend(f, this.balloon, !0), f.fillColor = d, f.balloonColor = d, f.fillAlpha = c, f.borderColor = d, f.color = g, h.balloon = f;\r\n            else\r\n                for (f = 0; f < this.valueAxes.length; f++)\r\n                    h = this.valueAxes[f], h.balloon && (h.balloon = null);\r\n            b && (b.balloonTextFunction = a.categoryBalloonFunction, a.categoryLineAxis = b, b.balloonText = a.categoryBalloonText, a.categoryBalloonEnabled && ((f = b.balloon) || (f = {}), f = e.extend(f, this.balloon, !0), f.fillColor = d, f.balloonColor = d, f.fillAlpha = c, f.borderColor = d, f.color = g, b.balloon = f), b.balloon && (b.balloon.enabled = a.categoryBalloonEnabled));\r\n        } }, addChartScrollbar: function (a) { e.callMethod(\"destroy\", [this.chartScrollbar]); a && (a.chart = this, this.listenTo(a, \"zoomed\", this.handleScrollbarZoom)); this.rotate ? void 0 === a.width && (a.width = a.scrollbarHeight) : void 0 === a.height && (a.height = a.scrollbarHeight); a.gridAxis = this.categoryAxis; this.chartScrollbar = a; }, addValueScrollbar: function (a) { e.callMethod(\"destroy\", [this.valueScrollbar]); a && (a.chart = this, this.listenTo(a, \"zoomed\", this.handleScrollbarValueZoom), this.listenTo(a, \"zoomStarted\", this.handleCursorZoomStarted)); var b = a.scrollbarHeight; this.rotate ? void 0 === a.height && (a.height = b) : void 0 === a.width && (a.width = b); a.gridAxis || (a.gridAxis = this.valueAxes[0]); a.valueAxes = this.valueAxes; this.valueScrollbar = a; }, removeChartScrollbar: function () { e.callMethod(\"destroy\", [this.chartScrollbar]); this.chartScrollbar = null; }, removeValueScrollbar: function () { e.callMethod(\"destroy\", [this.valueScrollbar]); this.valueScrollbar = null; }, handleReleaseOutside: function (a) { e.AmSerialChart.base.handleReleaseOutside.call(this, a); e.callMethod(\"handleReleaseOutside\", [this.chartScrollbar, this.valueScrollbar]); }, update: function () { e.AmSerialChart.base.update.call(this); this.chartScrollbar && this.chartScrollbar.update && this.chartScrollbar.update(); this.valueScrollbar && this.valueScrollbar.update && this.valueScrollbar.update(); }, processScrollbars: function () { e.AmSerialChart.base.processScrollbars.call(this); var a = this.valueScrollbar; a && (a = e.processObject(a, e.ChartScrollbar, this.theme), a.id = \"valueScrollbar\", this.addValueScrollbar(a)); }, handleValueAxisZoom: function (a) { this.handleValueAxisZoomReal(a, this.valueAxes); }, zoomOut: function () { e.AmSerialChart.base.zoomOut.call(this); this.zoom(); this.syncGrid(); }, getNextItem: function (a) { var b = a.index, c = this.chartData, d = a.graph; if (b + 1 < c.length)\r\n            for (b += 1; b < c.length; b++)\r\n                if (a = c[b])\r\n                    if (a = a.axes[d.valueAxis.id].graphs[d.id], !isNaN(a.y))\r\n                        return a; }, handleCursorZoomReal: function (a, b, c, d, e) { var h = e.target, f, k; this.rotate ? (isNaN(a) || isNaN(b) || this.relativeZoomValueAxes(this.valueAxes, a, b) && this.updateAfterValueZoom(), h.vZoomEnabled && (f = e.start, k = e.end)) : (isNaN(c) || isNaN(d) || this.relativeZoomValueAxes(this.valueAxes, c, d) && this.updateAfterValueZoom(), h.hZoomEnabled && (f = e.start, k = e.end)); isNaN(f) || isNaN(k) || (a = this.categoryAxis, a.parseDates && !a.equalSpacing ? this.zoomToDates(new Date(f), new Date(k)) : this.zoomToIndexes(f, k)); }, handleCursorZoomStarted: function () { var a = this.valueAxes; if (a) {\r\n            var a = a[0], b = a.relativeStart, c = a.relativeEnd;\r\n            a.reversed && (b = 1 - a.relativeEnd, c = 1 - a.relativeStart);\r\n            this.rotate ? (this.startX0 = b, this.endX0 = c) : (this.startY0 = b, this.endY0 = c);\r\n        } this.categoryAxis && (this.start0 = this.start, this.end0 = this.end, this.startTime0 = this.startTime, this.endTime0 = this.endTime); }, fixCursor: function () { this.chartCursor && this.chartCursor.fixPosition(); this.prevCursorItem = null; }, handleCursorMove: function (a) { e.AmSerialChart.base.handleCursorMove.call(this, a); var b = a.target, c = this.categoryAxis; if (a.panning)\r\n            this.handleCursorHide(a);\r\n        else if (this.chartData && !b.isHidden) {\r\n            var d = this.graphs;\r\n            if (d) {\r\n                var g;\r\n                g = c.xToIndex(this.rotate ? a.y : a.x);\r\n                if (g = this.chartData[g]) {\r\n                    var h, f, k, l;\r\n                    if (b.oneBalloonOnly && b.valueBalloonsEnabled) {\r\n                        var m = Infinity;\r\n                        for (h = d.length - 1; 0 <= h; h--)\r\n                            if (f = d[h], f.balloon.enabled && f.showBalloon && !f.hidden) {\r\n                                k = f.valueAxis.id;\r\n                                k = g.axes[k].graphs[f.id];\r\n                                if (b.showNextAvailable && isNaN(k.y) && (k = this.getNextItem(k), !k))\r\n                                    continue;\r\n                                k = k.y;\r\n                                \"top\" == f.showBalloonAt && (k = 0);\r\n                                \"bottom\" == f.showBalloonAt && (k = this.height);\r\n                                var p = b.mouseX, n = b.mouseY;\r\n                                k = this.rotate ? Math.abs(p - k) : Math.abs(n - k);\r\n                                k < m && (m = k, l = f);\r\n                            }\r\n                        b.mostCloseGraph = l;\r\n                    }\r\n                    if (this.prevCursorItem != g || l != this.prevMostCloseGraph) {\r\n                        m = [];\r\n                        for (h = 0; h < d.length; h++) {\r\n                            f = d[h];\r\n                            k = f.valueAxis.id;\r\n                            k = g.axes[k].graphs[f.id];\r\n                            if (b.showNextAvailable && isNaN(k.y) && (k = this.getNextItem(k), !k && f.balloon)) {\r\n                                f.balloon.hide();\r\n                                continue;\r\n                            }\r\n                            l && f != l ? (f.showGraphBalloon(k, b.pointer, !1, b.graphBulletSize, b.graphBulletAlpha), f.balloon.hide(0)) : b.valueBalloonsEnabled ? (f.balloon.showBullet = b.bulletsEnabled, f.balloon.bulletSize = b.bulletSize / 2, a.hideBalloons || (f.showGraphBalloon(k, b.pointer, !1, b.graphBulletSize, b.graphBulletAlpha), f.balloon.set && m.push({ balloon: f.balloon, y: f.balloon.pointToY }))) : (f.currentDataItem = k, f.resizeBullet(k, b.graphBulletSize, b.graphBulletAlpha));\r\n                        }\r\n                        b.avoidBalloonOverlapping && this.arrangeBalloons(m);\r\n                        this.prevCursorItem = g;\r\n                    }\r\n                    this.prevMostCloseGraph = l;\r\n                }\r\n            }\r\n            c.showBalloon(a.x, a.y, b.categoryBalloonDateFormat, a.skip);\r\n            this.updateLegendValues();\r\n        } }, handleCursorHide: function (a) { e.AmSerialChart.base.handleCursorHide.call(this, a); a = this.categoryAxis; this.prevCursorItem = null; this.updateLegendValues(); a && a.hideBalloon(); a = this.graphs; var b; for (b = 0; b < a.length; b++)\r\n            a[b].currentDataItem = null; }, handleCursorPanning: function (a) { var b = a.target, c, d = a.deltaX, g = a.deltaY, h = a.delta2X, f = a.delta2Y; a = !1; if (this.rotate) {\r\n            isNaN(h) && (h = d, a = !0);\r\n            var k = this.endX0;\r\n            c = this.startX0;\r\n            var l = k - c, k = k - l * h, m = l;\r\n            a || (m = 0);\r\n            a = e.fitToBounds(c - l * d, 0, 1 - m);\r\n        }\r\n        else\r\n            isNaN(f) && (f = g, a = !0), k = this.endY0, c = this.startY0, l = k - c, k += l * g, m = l, a || (m = 0), a = e.fitToBounds(c + l * f, 0, 1 - m); c = e.fitToBounds(k, m, 1); var p; b.valueZoomable && (p = this.relativeZoomValueAxes(this.valueAxes, a, c)); var n; c = this.categoryAxis; this.rotate && (d = g, h = f); a = !1; isNaN(h) && (h = d, a = !0); if (b.zoomable && (0 < Math.abs(d) || 0 < Math.abs(h)))\r\n            if (c.parseDates && !c.equalSpacing) {\r\n                if (f = this.startTime0, g = this.endTime0, c = g - f, h *= c, l = this.firstTime, k = this.lastTime, m = c, a || (m = 0), a = Math.round(e.fitToBounds(f - c * d, l, k - m)), h = Math.round(e.fitToBounds(g - h, l + m, k)), this.startTime != a || this.endTime != h)\r\n                    n = { chart: this, target: b, type: \"zoomed\", start: a, end: h }, this.skipZoomed = !0, b.fire(n), this.zoom(a, h), n = !0;\r\n            }\r\n            else if (f = this.start0, g = this.end0, c = g - f, d = Math.round(c * d), h = Math.round(c * h), l = this.chartData.length - 1, a || (c = 0), a = e.fitToBounds(f - d, 0, l - c), c = e.fitToBounds(g - h, c, l), this.start != a || this.end != c)\r\n                this.skipZoomed = !0, b.fire({ chart: this, target: b, type: \"zoomed\", start: a, end: c }), this.zoom(a, c), n = !0; !n && p && this.updateAfterValueZoom(); }, arrangeBalloons: function (a) { var b = this.plotAreaHeight; a.sort(this.compareY); var c, d, e, h = this.plotAreaWidth, f = a.length; for (c = 0; c < f; c++)\r\n            d = a[c].balloon, d.setBounds(0, 0, h, b), d.restorePrevious(), d.draw(), b = d.yPos - 3; a.reverse(); for (c = 0; c < f; c++) {\r\n            d = a[c].balloon;\r\n            var b = d.bottom, k = d.bottom - d.yPos;\r\n            0 < c && b - k < e + 3 && d.setBounds && (d.setBounds(0, e + 3, h, e + k + 3), d.restorePrevious(), d.draw());\r\n            d.set && d.set.show();\r\n            e = d.bottom;\r\n        } }, compareY: function (a, b) { return a.y < b.y ? 1 : -1; } });\r\n})();\r\n(function () {\r\n    var e = window.AmCharts;\r\n    e.Cuboid = e.Class({ construct: function (a, b, c, d, e, h, f, k, l, m, p, n, u, v, x, E, t) { this.set = a.set(); this.container = a; this.h = Math.round(c); this.w = Math.round(b); this.dx = d; this.dy = e; this.colors = h; this.alpha = f; this.bwidth = k; this.bcolor = l; this.balpha = m; this.dashLength = v; this.topRadius = E; this.pattern = x; this.rotate = u; this.bcn = t; u ? 0 > b && 0 === p && (p = 180) : 0 > c && 270 == p && (p = 90); this.gradientRotation = p; 0 === d && 0 === e && (this.cornerRadius = n); this.draw(); }, draw: function () {\r\n            var a = this.set;\r\n            a.clear();\r\n            var b = this.container, c = b.chart, d = this.w, g = this.h, h = this.dx, f = this.dy, k = this.colors, l = this.alpha, m = this.bwidth, p = this.bcolor, n = this.balpha, u = this.gradientRotation, v = this.cornerRadius, x = this.dashLength, E = this.pattern, t = this.topRadius, r = this.bcn, B = k, q = k;\r\n            \"object\" == typeof k && (B = k[0], q = k[k.length - 1]);\r\n            var w, y, C, F, D, A, z, L, M, Q = l;\r\n            E && (l = 0);\r\n            var G, H, I, J, K = this.rotate;\r\n            if (0 < Math.abs(h) || 0 < Math.abs(f))\r\n                if (isNaN(t))\r\n                    z = q, q = e.adjustLuminosity(B, -.2), q = e.adjustLuminosity(B, -.2), w = e.polygon(b, [0, h, d + h, d, 0], [0, f, f, 0, 0], q, l, 1, p, 0, u), 0 < n && (M = e.line(b, [0, h, d + h], [0, f, f], p, n, m, x)), y = e.polygon(b, [0, 0, d, d, 0], [0, g, g, 0, 0], q, l, 1, p, 0, u), y.translate(h, f), 0 < n && (C = e.line(b, [h, h], [f, f + g], p, n, m, x)), F = e.polygon(b, [0, 0, h, h, 0], [0, g, g + f, f, 0], q, l, 1, p, 0, u), D = e.polygon(b, [d, d, d + h, d + h, d], [0, g, g + f, f, 0], q, l, 1, p, 0, u), 0 < n && (A = e.line(b, [d, d + h, d + h, d], [0, f, g + f, g], p, n, m, x)), q = e.adjustLuminosity(z, .2), z = e.polygon(b, [0, h, d + h, d, 0], [g, g + f, g + f, g, g], q, l, 1, p, 0, u), 0 < n && (L = e.line(b, [0, h, d + h], [g, g + f, g + f], p, n, m, x));\r\n                else {\r\n                    var N, O, P;\r\n                    K ? (N = g / 2, q = h / 2, P = g / 2, O = d + h / 2, H = Math.abs(g / 2), G = Math.abs(h / 2)) : (q = d / 2, N = f / 2, O = d / 2, P = g + f / 2 + 1, G = Math.abs(d / 2), H = Math.abs(f / 2));\r\n                    I = G * t;\r\n                    J = H * t;\r\n                    .1 < G && .1 < G && (w = e.circle(b, G, B, l, m, p, n, !1, H), w.translate(q, N));\r\n                    .1 < I && .1 < I && (z = e.circle(b, I, e.adjustLuminosity(B, .5), l, m, p, n, !1, J), z.translate(O, P));\r\n                }\r\n            l = Q;\r\n            1 > Math.abs(g) && (g = 0);\r\n            1 > Math.abs(d) && (d = 0);\r\n            !isNaN(t) && (0 < Math.abs(h) || 0 < Math.abs(f)) ? (k = [B], k = { fill: k, stroke: p, \"stroke-width\": m, \"stroke-opacity\": n, \"fill-opacity\": l }, K ? (l = \"M0,0 L\" + d + \",\" + (g / 2 - g / 2 * t), m = \" B\", 0 < d && (m = \" A\"), e.VML ? (l += m + Math.round(d -\r\n                I) + \",\" + Math.round(g / 2 - J) + \",\" + Math.round(d + I) + \",\" + Math.round(g / 2 + J) + \",\" + d + \",0,\" + d + \",\" + g, l = l + (\" L0,\" + g) + (m + Math.round(-G) + \",\" + Math.round(g / 2 - H) + \",\" + Math.round(G) + \",\" + Math.round(g / 2 + H) + \",0,\" + g + \",0,0\")) : (l += \"A\" + I + \",\" + J + \",0,0,0,\" + d + \",\" + (g - g / 2 * (1 - t)) + \"L0,\" + g, l += \"A\" + G + \",\" + H + \",0,0,1,0,0\"), G = 90) : (m = d / 2 - d / 2 * t, l = \"M0,0 L\" + m + \",\" + g, e.VML ? (l = \"M0,0 L\" + m + \",\" + g, m = \" B\", 0 > g && (m = \" A\"), l += m + Math.round(d / 2 - I) + \",\" + Math.round(g - J) + \",\" + Math.round(d / 2 + I) + \",\" + Math.round(g + J) + \",0,\" + g + \",\" + d + \",\" + g, l += \" L\" + d + \",0\", l += m + Math.round(d /\r\n                2 + G) + \",\" + Math.round(H) + \",\" + Math.round(d / 2 - G) + \",\" + Math.round(-H) + \",\" + d + \",0,0,0\") : (l += \"A\" + I + \",\" + J + \",0,0,0,\" + (d - d / 2 * (1 - t)) + \",\" + g + \"L\" + d + \",0\", l += \"A\" + G + \",\" + H + \",0,0,1,0,0\"), G = 180), b = b.path(l).attr(k), b.gradient(\"linearGradient\", [B, e.adjustLuminosity(B, -.3), e.adjustLuminosity(B, -.3), B], G), K ? b.translate(h / 2, 0) : b.translate(0, f / 2)) : b = 0 === g ? e.line(b, [0, d], [0, 0], p, n, m, x) : 0 === d ? e.line(b, [0, 0], [0, g], p, n, m, x) : 0 < v ? e.rect(b, d, g, k, l, m, p, n, v, u, x) : e.polygon(b, [0, 0, d, d, 0], [0, g, g, 0, 0], k, l, m, p, n, u, !1, x);\r\n            d = isNaN(t) ? 0 > g ? [w, M, y, C, F, D, A, z, L, b] : [z, L, y, C, F, D, w, M, A, b] : K ? 0 < d ? [w, b, z] : [z, b, w] : 0 > g ? [w, b, z] : [z, b, w];\r\n            e.setCN(c, b, r + \"front\");\r\n            e.setCN(c, y, r + \"back\");\r\n            e.setCN(c, z, r + \"top\");\r\n            e.setCN(c, w, r + \"bottom\");\r\n            e.setCN(c, F, r + \"left\");\r\n            e.setCN(c, D, r + \"right\");\r\n            for (w = 0; w < d.length; w++)\r\n                if (y = d[w])\r\n                    a.push(y), e.setCN(c, y, r + \"element\");\r\n            E && b.pattern(E, NaN, c.path);\r\n        }, width: function (a) { isNaN(a) && (a = 0); this.w = Math.round(a); this.draw(); }, height: function (a) { isNaN(a) && (a = 0); this.h = Math.round(a); this.draw(); }, animateHeight: function (a, b) { var c = this; c.animationFinished = !1; c.easing = b; c.totalFrames = a * e.updateRate; c.rh = c.h; c.frame = 0; c.height(1); setTimeout(function () { c.updateHeight.call(c); }, 1E3 / e.updateRate); }, updateHeight: function () { var a = this; a.frame++; var b = a.totalFrames; a.frame <= b ? (b = a.easing(0, a.frame, 1, a.rh - 1, b), a.height(b), window.requestAnimationFrame ? window.requestAnimationFrame(function () { a.updateHeight.call(a); }) : setTimeout(function () { a.updateHeight.call(a); }, 1E3 / e.updateRate)) : (a.height(a.rh), a.animationFinished = !0); }, animateWidth: function (a, b) { var c = this; c.animationFinished = !1; c.easing = b; c.totalFrames = a * e.updateRate; c.rw = c.w; c.frame = 0; c.width(1); setTimeout(function () { c.updateWidth.call(c); }, 1E3 / e.updateRate); }, updateWidth: function () { var a = this; a.frame++; var b = a.totalFrames; a.frame <= b ? (b = a.easing(0, a.frame, 1, a.rw - 1, b), a.width(b), window.requestAnimationFrame ? window.requestAnimationFrame(function () { a.updateWidth.call(a); }) : setTimeout(function () { a.updateWidth.call(a); }, 1E3 / e.updateRate)) : (a.width(a.rw), a.animationFinished = !0); } });\r\n})();\r\n(function () {\r\n    var e = window.AmCharts;\r\n    e.CategoryAxis = e.Class({ inherits: e.AxisBase, construct: function (a) { this.cname = \"CategoryAxis\"; e.CategoryAxis.base.construct.call(this, a); this.minPeriod = \"DD\"; this.equalSpacing = this.parseDates = !1; this.position = \"bottom\"; this.startOnAxis = !1; this.gridPosition = \"middle\"; this.safeDistance = 30; this.stickBalloonToCategory = !1; e.applyTheme(this, a, this.cname); }, draw: function () {\r\n            e.CategoryAxis.base.draw.call(this);\r\n            this.generateDFObject();\r\n            var a = this.chart.chartData;\r\n            this.data = a;\r\n            this.labelRotationR = this.labelRotation;\r\n            this.type = null;\r\n            if (e.ifArray(a)) {\r\n                var b, c = this.chart;\r\n                \"scrollbar\" != this.id ? (e.setCN(c, this.set, \"category-axis\"), e.setCN(c, this.labelsSet, \"category-axis\"), e.setCN(c, this.axisLine.axisSet, \"category-axis\")) : this.bcn = this.id + \"-\";\r\n                var d = this.start, g = this.labelFrequency, h = 0, f = this.end - d + 1, k = this.gridCountR, l = this.showFirstLabel, m = this.showLastLabel, p, n = \"\", n = e.extractPeriod(this.minPeriod), u = e.getPeriodDuration(n.period, n.count), v, x, E, t, r, B = this.rotate, q = this.firstDayOfWeek, w = this.boldPeriodBeginning;\r\n                b = e.resetDateToMin(new Date(a[a.length - 1].time + 1.05 * u), this.minPeriod, 1, q).getTime();\r\n                this.firstTime = c.firstTime;\r\n                this.endTime > b && (this.endTime = b);\r\n                r = this.minorGridEnabled;\r\n                x = this.gridAlpha;\r\n                var y = 0, C = 0;\r\n                if (this.widthField)\r\n                    for (b = this.start; b <= this.end; b++)\r\n                        if (t = this.data[b]) {\r\n                            var F = Number(this.data[b].dataContext[this.widthField]);\r\n                            isNaN(F) || (y += F, t.widthValue = F);\r\n                        }\r\n                if (this.parseDates && !this.equalSpacing)\r\n                    this.lastTime = a[a.length - 1].time, this.maxTime = e.resetDateToMin(new Date(this.lastTime + 1.05 * u), this.minPeriod, 1, q).getTime(), this.timeDifference = this.endTime - this.startTime, this.parseDatesDraw();\r\n                else if (!this.parseDates) {\r\n                    if (this.cellWidth = this.getStepWidth(f), f < k && (k = f), h += this.start, this.stepWidth = this.getStepWidth(f), 0 < k)\r\n                        for (q = Math.floor(f / k), t = this.chooseMinorFrequency(q), f = h, f / 2 == Math.round(f / 2) && f--, 0 > f && (f = 0), w = 0, this.widthField && (f = this.start, q = 1), this.end - f + 1 >= this.autoRotateCount && (this.labelRotationR = this.autoRotateAngle), b = f; b <= this.end + 2; b++) {\r\n                            k = !1;\r\n                            0 <= b && b < this.data.length ? (v = this.data[b], n = v.category, k = v.forceShow) : n = \"\";\r\n                            if (r && !isNaN(t))\r\n                                if (b / t == Math.round(b / t) || k)\r\n                                    b / q == Math.round(b / q) || k || (this.gridAlpha = this.minorGridAlpha, n = void 0);\r\n                                else\r\n                                    continue;\r\n                            else if (b / q != Math.round(b / q) && !k)\r\n                                continue;\r\n                            f = this.getCoordinate(b - h);\r\n                            k = 0;\r\n                            \"start\" == this.gridPosition && (f -= this.cellWidth / 2, k = this.cellWidth / 2);\r\n                            p = !0;\r\n                            E = k;\r\n                            \"start\" == this.tickPosition && (E = 0, p = !1, k = 0);\r\n                            if (b == d && !l || b == this.end && !m)\r\n                                n = void 0;\r\n                            Math.round(w / g) != w / g && (n = void 0);\r\n                            w++;\r\n                            a = this.cellWidth;\r\n                            B && (a = NaN, this.ignoreAxisWidth || !c.autoMargins) && (a = \"right\" == this.position ? c.marginRight - this.titleWidth : c.marginLeft - this.titleWidth, a -= this.tickLength + 10);\r\n                            this.labelFunction && v && (n = this.labelFunction(n, v, this));\r\n                            n = e.fixBrakes(n);\r\n                            u = !1;\r\n                            this.boldLabels && (u = !0);\r\n                            b > this.end && \"start\" == this.tickPosition && (n = \" \");\r\n                            this.rotate && this.inside && (k -= 2);\r\n                            isNaN(v.widthValue) || (v.percentWidthValue = v.widthValue / y * 100, a = this.rotate ? this.height * v.widthValue / y : this.width * v.widthValue / y, f = C, C += a, E = k = a / 2);\r\n                            p = new this.axisItemRenderer(this, f, n, p, a, k, void 0, u, E, !1, v.labelColor, v.className);\r\n                            p.serialDataItem = v;\r\n                            this.pushAxisItem(p);\r\n                            this.gridAlpha = x;\r\n                        }\r\n                }\r\n                else if (this.parseDates && this.equalSpacing) {\r\n                    h = this.start;\r\n                    this.startTime = this.data[this.start].time;\r\n                    this.endTime = this.data[this.end].time;\r\n                    this.timeDifference = this.endTime - this.startTime;\r\n                    b = this.choosePeriod(0);\r\n                    g = b.period;\r\n                    v = b.count;\r\n                    b = e.getPeriodDuration(g, v);\r\n                    b < u && (g = n.period, v = n.count, b = u);\r\n                    x = g;\r\n                    \"WW\" == x && (x = \"DD\");\r\n                    this.currentDateFormat = this.dateFormatsObject[x];\r\n                    this.stepWidth = this.getStepWidth(f);\r\n                    k = Math.ceil(this.timeDifference / b) + 1;\r\n                    n = e.resetDateToMin(new Date(this.startTime -\r\n                        b), g, v, q).getTime();\r\n                    this.cellWidth = this.getStepWidth(f);\r\n                    f = Math.round(n / b);\r\n                    d = -1;\r\n                    f / 2 == Math.round(f / 2) && (d = -2, n -= b);\r\n                    f = this.start;\r\n                    f / 2 == Math.round(f / 2) && f--;\r\n                    0 > f && (f = 0);\r\n                    C = this.end + 2;\r\n                    C >= this.data.length && (C = this.data.length);\r\n                    a = !1;\r\n                    a = !l;\r\n                    this.previousPos = -1E3;\r\n                    20 < this.labelRotationR && (this.safeDistance = 5);\r\n                    F = f;\r\n                    if (this.data[f].time != e.resetDateToMin(new Date(this.data[f].time), g, v, q).getTime()) {\r\n                        var u = 0, D = n;\r\n                        for (b = f; b < C; b++)\r\n                            t = this.data[b].time, this.checkPeriodChange(g, v, t, D) && (u++, 2 <= u && (F = b, b = C), D = t);\r\n                    }\r\n                    r && 1 < v && (t = this.chooseMinorFrequency(v), e.getPeriodDuration(g, t));\r\n                    if (0 < this.gridCountR)\r\n                        for (b = f; b < C; b++)\r\n                            if (t = this.data[b].time, this.checkPeriodChange(g, v, t, n) && b >= F) {\r\n                                f = this.getCoordinate(b - this.start);\r\n                                r = !1;\r\n                                this.nextPeriod[x] && (r = this.checkPeriodChange(this.nextPeriod[x], 1, t, n, x)) && e.resetDateToMin(new Date(t), this.nextPeriod[x], 1, q).getTime() != t && (r = !1);\r\n                                u = !1;\r\n                                r && this.markPeriodChange ? (r = this.dateFormatsObject[this.nextPeriod[x]], u = !0) : r = this.dateFormatsObject[x];\r\n                                n = e.formatDate(new Date(t), r, c);\r\n                                if (b == d && !l || b == k && !m)\r\n                                    n = \" \";\r\n                                a ? a = !1 : (w || (u = !1), f - this.previousPos > this.safeDistance * Math.cos(this.labelRotationR * Math.PI / 180) && (this.labelFunction && (n = this.labelFunction(n, new Date(t), this, g, v, E)), this.boldLabels && (u = !0), p = new this.axisItemRenderer(this, f, n, void 0, void 0, void 0, void 0, u), r = p.graphics(), this.pushAxisItem(p), r = r.getBBox().width, e.isModern || (r -= f), this.previousPos = f + r));\r\n                                E = n = t;\r\n                            }\r\n                }\r\n                for (b = l = 0; b < this.data.length; b++)\r\n                    if (t = this.data[b])\r\n                        this.parseDates && !this.equalSpacing ? (m = t.time, d = this.cellWidth, \"MM\" == this.minPeriod && (d = 864E5 * e.daysInMonth(new Date(m)) * this.stepWidth, t.cellWidth = d), m = Math.round((m - this.startTime) * this.stepWidth + d / 2)) : m = this.getCoordinate(b - h), t.x[this.id] = m;\r\n                if (this.widthField)\r\n                    for (b = this.start; b <= this.end; b++)\r\n                        t = this.data[b], d = t.widthValue, t.percentWidthValue = d / y * 100, this.rotate ? (m = this.height * d / y / 2 + l, l = this.height * d / y + l) : (m = this.width * d / y / 2 + l, l = this.width * d / y + l), t.x[this.id] = m;\r\n                y = this.guides.length;\r\n                for (b = 0; b < y; b++)\r\n                    if (l = this.guides[b], q = q = q = r = d = NaN, m = l.above, l.toCategory && (q = c.getCategoryIndexByValue(l.toCategory), isNaN(q) || (d = this.getCoordinate(q - h), l.expand && (d += this.cellWidth / 2), p = new this.axisItemRenderer(this, d, \"\", !0, NaN, NaN, l), this.pushAxisItem(p, m))), l.category && (q = c.getCategoryIndexByValue(l.category), isNaN(q) || (r = this.getCoordinate(q - h), l.expand && (r -= this.cellWidth / 2), q = (d - r) / 2, p = new this.axisItemRenderer(this, r, l.label, !0, NaN, q, l), this.pushAxisItem(p, m))), w = c.dataDateFormat, l.toDate && (!w || l.toDate instanceof Date || (l.toDate = l.toDate.toString() + \" |\"), l.toDate = e.getDate(l.toDate, w), this.equalSpacing ?\r\n                        (q = c.getClosestIndex(this.data, \"time\", l.toDate.getTime(), !1, 0, this.data.length - 1), isNaN(q) || (d = this.getCoordinate(q - h))) : d = (l.toDate.getTime() - this.startTime) * this.stepWidth, p = new this.axisItemRenderer(this, d, \"\", !0, NaN, NaN, l), this.pushAxisItem(p, m)), l.date && (!w || l.date instanceof Date || (l.date = l.date.toString() + \" |\"), l.date = e.getDate(l.date, w), this.equalSpacing ? (q = c.getClosestIndex(this.data, \"time\", l.date.getTime(), !1, 0, this.data.length - 1), isNaN(q) || (r = this.getCoordinate(q - h))) : r = (l.date.getTime() -\r\n                        this.startTime) * this.stepWidth, q = (d - r) / 2, p = !0, l.toDate && (p = !1), p = \"H\" == this.orientation ? new this.axisItemRenderer(this, r, l.label, p, 2 * q, NaN, l) : new this.axisItemRenderer(this, r, l.label, !1, NaN, q, l), this.pushAxisItem(p, m)), p && (q = p.label) && this.addEventListeners(q, l), 0 < d || 0 < r) {\r\n                        q = !1;\r\n                        if (this.rotate) {\r\n                            if (d < this.height || r < this.height)\r\n                                q = !0;\r\n                        }\r\n                        else if (d < this.width || r < this.width)\r\n                            q = !0;\r\n                        q && (d = new this.guideFillRenderer(this, r, d, l), r = d.graphics(), this.pushAxisItem(d, m), l.graphics = r, r.index = b, this.addEventListeners(r, l));\r\n                    }\r\n                if (c = c.chartCursor)\r\n                    B ? c.fixHeight(this.cellWidth) : (c.fixWidth(this.cellWidth), c.fullWidth && this.balloon && (this.balloon.minWidth = this.cellWidth));\r\n                this.previousHeight = A;\r\n            }\r\n            this.axisCreated = !0;\r\n            this.set.translate(this.x, this.y);\r\n            this.labelsSet.translate(this.x, this.y);\r\n            this.labelsSet.show();\r\n            this.positionTitle();\r\n            (B = this.axisLine.set) && B.toFront();\r\n            var A = this.getBBox().height;\r\n            2 < A - this.previousHeight && this.autoWrap && !this.parseDates && (this.axisCreated = this.chart.marginsUpdated = !1);\r\n        }, xToIndex: function (a) {\r\n            var b = this.data, c = this.chart, d = c.rotate, g = this.stepWidth, h;\r\n            if (this.parseDates && !this.equalSpacing)\r\n                a = this.startTime + Math.round(a / g) - this.minDuration() / 2, h = c.getClosestIndex(b, \"time\", a, !1, this.start, this.end + 1);\r\n            else if (this.widthField)\r\n                for (c = Infinity, g = this.start; g <= this.end; g++) {\r\n                    var f = this.data[g];\r\n                    f && (f = Math.abs(f.x[this.id] - a), f < c && (c = f, h = g));\r\n                }\r\n            else\r\n                this.startOnAxis || (a -= g / 2), h = this.start + Math.round(a / g);\r\n            h = e.fitToBounds(h, 0, b.length - 1);\r\n            var k;\r\n            b[h] && (k = b[h].x[this.id]);\r\n            d ? k > this.height + 1 && h-- : k > this.width + 1 &&\r\n                h--;\r\n            0 > k && h++;\r\n            return h = e.fitToBounds(h, 0, b.length - 1);\r\n        }, dateToCoordinate: function (a) { return this.parseDates && !this.equalSpacing ? (a.getTime() - this.startTime) * this.stepWidth : this.parseDates && this.equalSpacing ? (a = this.chart.getClosestIndex(this.data, \"time\", a.getTime(), !1, 0, this.data.length - 1), this.getCoordinate(a - this.start)) : NaN; }, categoryToCoordinate: function (a) {\r\n            if (this.chart) {\r\n                if (this.parseDates)\r\n                    return this.dateToCoordinate(new Date(a));\r\n                a = this.chart.getCategoryIndexByValue(a);\r\n                if (!isNaN(a))\r\n                    return this.getCoordinate(a -\r\n                        this.start);\r\n            }\r\n            else\r\n                return NaN;\r\n        }, coordinateToDate: function (a) { return this.equalSpacing ? (a = this.xToIndex(a), new Date(this.data[a].time)) : new Date(this.startTime + a / this.stepWidth); }, coordinateToValue: function (a) { a = this.xToIndex(a); if (a = this.data[a])\r\n            return this.parseDates ? a.time : a.category; }, getCoordinate: function (a) { a *= this.stepWidth; this.startOnAxis || (a += this.stepWidth / 2); return Math.round(a); }, formatValue: function (a, b) { b || (b = this.currentDateFormat); this.parseDates && (a = e.formatDate(new Date(a), b, this.chart)); return a; }, showBalloonAt: function (a, b) { void 0 === b && (b = this.parseDates ? this.dateToCoordinate(new Date(a)) : this.categoryToCoordinate(a)); return this.adjustBalloonCoordinate(b); }, formatBalloonText: function (a, b, c) {\r\n            var d = \"\", g = \"\", h = this.chart, f = this.data[b];\r\n            if (f)\r\n                if (this.parseDates)\r\n                    d = e.formatDate(f.category, c, h), b = e.changeDate(new Date(f.category), this.minPeriod, 1), g = e.formatDate(b, c, h), -1 != d.indexOf(\"fff\") && (d = e.formatMilliseconds(d, f.category), g = e.formatMilliseconds(g, b));\r\n                else {\r\n                    var k;\r\n                    this.data[b + 1] && (k = this.data[b +\r\n                        1]);\r\n                    d = e.fixNewLines(f.category);\r\n                    k && (g = e.fixNewLines(k.category));\r\n                }\r\n            a = a.replace(/\\[\\[category\\]\\]/g, String(d));\r\n            return a = a.replace(/\\[\\[toCategory\\]\\]/g, String(g));\r\n        }, adjustBalloonCoordinate: function (a, b) { var c = this.xToIndex(a), d = this.chart.chartCursor; if (this.stickBalloonToCategory) {\r\n            var e = this.data[c];\r\n            e && (a = e.x[this.id]);\r\n            this.stickBalloonToStart && (a -= this.cellWidth / 2);\r\n            var h = 0;\r\n            if (d) {\r\n                var f = d.limitToGraph;\r\n                if (f) {\r\n                    var k = f.valueAxis.id;\r\n                    f.hidden || (h = e.axes[k].graphs[f.id].y);\r\n                }\r\n                this.rotate ? (\"left\" == this.position ? (f && (h -= d.width), 0 < h && (h = 0)) : 0 > h && (h = 0), d.fixHLine(a, h)) : (\"top\" == this.position ? (f && (h -= d.height), 0 < h && (h = 0)) : 0 > h && (h = 0), d.fullWidth && (a += 1), d.fixVLine(a, h));\r\n            }\r\n        } d && !b && (d.setIndex(c), this.parseDates && d.setTimestamp(this.coordinateToDate(a).getTime())); return a; } });\r\n})();\r\n",null]}